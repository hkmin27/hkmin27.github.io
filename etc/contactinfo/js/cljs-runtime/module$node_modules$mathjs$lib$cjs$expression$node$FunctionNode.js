shadow$provide.module$node_modules$mathjs$lib$cjs$expression$node$FunctionNode=function(global,require,module,exports){function _typeof(obj$jscomp$0){"@babel/helpers - typeof";_typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};return _typeof(obj$jscomp$0)}function _extends(){_extends=Object.assign||function(target){for(var i=
1;i<arguments.length;i++){var source=arguments[i],key;for(key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target};return _extends.apply(this,arguments)}Object.defineProperty(exports,"__esModule",{value:!0});exports.createFunctionNode=void 0;var _is=require("module$node_modules$mathjs$lib$cjs$utils$is"),_string=require("module$node_modules$mathjs$lib$cjs$utils$string"),_object=require("module$node_modules$mathjs$lib$cjs$utils$object"),_array=require("module$node_modules$mathjs$lib$cjs$utils$array"),
_customs=require("module$node_modules$mathjs$lib$cjs$utils$customs");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");var _latex=require("module$node_modules$mathjs$lib$cjs$utils$latex");require=(0,global.factory)("FunctionNode",["math","Node","SymbolNode"],function(_ref){function FunctionNode(fn,args){if(!(this instanceof FunctionNode))throw new SyntaxError("Constructor must be called with the new operator");"string"===typeof fn&&(fn=new SymbolNode(fn));if(!(0,_is.isNode)(fn))throw new TypeError('Node expected as parameter "fn"');
if(!Array.isArray(args)||!args.every(_is.isNode))throw new TypeError('Array containing Nodes expected for parameter "args"');this.fn=fn;this.args=args||[];Object.defineProperty(this,"name",{get:function(){return this.fn.name||""}.bind(this),set:function(){throw Error("Cannot assign a new name, name is read-only");}})}function expandTemplate(template,node,options){for(var latex="",regex=/\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi,inputPos=0,match;null!==(match=regex.exec(template));)if(latex+=
template.substring(inputPos,match.index),inputPos=match.index,"$$"===match[0])latex+="$",inputPos++;else{inputPos+=match[0].length;var property=node[match[1]];if(!property)throw new ReferenceError("Template: Property "+match[1]+" does not exist.");if(void 0===match[2])switch(_typeof(property)){case "string":latex+=property;break;case "object":if((0,_is.isNode)(property))latex+=property.toTex(options);else if(Array.isArray(property))latex+=property.map(function(arg,index){if((0,_is.isNode)(arg))return arg.toTex(options);
throw new TypeError("Template: "+match[1]+"["+index+"] is not a Node.");}).join(",");else throw new TypeError("Template: "+match[1]+" has to be a Node, String or array of Nodes");break;default:throw new TypeError("Template: "+match[1]+" has to be a Node, String or array of Nodes");}else if((0,_is.isNode)(property[match[2]]&&property[match[2]]))latex+=property[match[2]].toTex(options);else throw new TypeError("Template: "+match[1]+"["+match[2]+"] is not a Node.");}return latex+=template.slice(inputPos)}
var math$jscomp$0=_ref.math,SymbolNode=_ref.SymbolNode;FunctionNode.prototype=new _ref.Node;FunctionNode.prototype.type="FunctionNode";FunctionNode.prototype.isFunctionNode=!0;FunctionNode.prototype._compile=function(math,argNames){if(!(this instanceof FunctionNode))throw new TypeError("No valid FunctionNode");var evalArgs=(0,_array.map)(this.args,function(arg){return arg._compile(math,argNames)});if((0,_is.isSymbolNode)(this.fn)){var resolveFn=function(scope){return _name in scope?(0,_customs.getSafeProperty)(scope,
_name):_name in math?(0,_customs.getSafeProperty)(math,_name):FunctionNode.onUndefinedFunction(_name)},_name=this.fn.name,fn$jscomp$0=_name in math?(0,_customs.getSafeProperty)(math,_name):void 0;if("function"===typeof fn$jscomp$0&&!0===fn$jscomp$0.rawArgs){var rawArgs=this.args;return function(scope,args,context){return resolveFn(scope)(rawArgs,math,_extends({},scope,args))}}if(1===evalArgs.length){var evalArg0=evalArgs[0];return function(scope,args,context){return resolveFn(scope)(evalArg0(scope,
args,context))}}if(2===evalArgs.length){var _evalArg=evalArgs[0],evalArg1=evalArgs[1];return function(scope,args,context){return resolveFn(scope)(_evalArg(scope,args,context),evalArg1(scope,args,context))}}return function(scope,args,context){return resolveFn(scope).apply(null,(0,_array.map)(evalArgs,function(evalArg){return evalArg(scope,args,context)}))}}if((0,_is.isAccessorNode)(this.fn)&&(0,_is.isIndexNode)(this.fn.index)&&this.fn.index.isObjectProperty()){var evalObject=this.fn.object._compile(math,
argNames),prop=this.fn.index.getObjectProperty(),_rawArgs=this.args;return function(scope,args,context){var object=evalObject(scope,args,context);(0,_customs.validateSafeMethod)(object,prop);return object[prop]&&object[prop].rawArgs?object[prop](_rawArgs,math,_extends({},scope,args)):object[prop].apply(object,(0,_array.map)(evalArgs,function(evalArg){return evalArg(scope,args,context)}))}}var evalFn=this.fn._compile(math,argNames),_rawArgs2=this.args;return function(scope,args,context){var fn=evalFn(scope,
args,context);return fn&&fn.rawArgs?fn(_rawArgs2,math,_extends({},scope,args)):fn.apply(fn,(0,_array.map)(evalArgs,function(evalArg){return evalArg(scope,args,context)}))}};FunctionNode.prototype.forEach=function(callback){callback(this.fn,"fn",this);for(var i=0;i<this.args.length;i++)callback(this.args[i],"args["+i+"]",this)};FunctionNode.prototype.map=function(callback){for(var fn=this._ifNode(callback(this.fn,"fn",this)),args=[],i=0;i<this.args.length;i++)args[i]=this._ifNode(callback(this.args[i],
"args["+i+"]",this));return new FunctionNode(fn,args)};FunctionNode.prototype.clone=function(){return new FunctionNode(this.fn,this.args.slice(0))};FunctionNode.onUndefinedFunction=function(name){throw Error("Undefined function "+name);};var nodeToString=FunctionNode.prototype.toString;FunctionNode.prototype.toString=function(options){var customString,name=this.fn.toString(options);options&&"object"===_typeof(options.handler)&&(0,_object.hasOwnProperty)(options.handler,name)&&(customString=options.handler[name](this,
options));return"undefined"!==typeof customString?customString:nodeToString.call(this,options)};FunctionNode.prototype._toString=function(options){var args=this.args.map(function(arg){return arg.toString(options)});return((0,_is.isFunctionAssignmentNode)(this.fn)?"("+this.fn.toString(options)+")":this.fn.toString(options))+"("+args.join(", ")+")"};FunctionNode.prototype.toJSON=function(){return{mathjs:"FunctionNode",fn:this.fn,args:this.args}};FunctionNode.fromJSON=function(json){return new FunctionNode(json.fn,
json.args)};FunctionNode.prototype.toHTML=function(options){var args=this.args.map(function(arg){return arg.toHTML(options)});return'\x3cspan class\x3d"math-function"\x3e'+(0,_string.escape)(this.fn)+'\x3c/span\x3e\x3cspan class\x3d"math-paranthesis math-round-parenthesis"\x3e(\x3c/span\x3e'+args.join('\x3cspan class\x3d"math-separator"\x3e,\x3c/span\x3e')+'\x3cspan class\x3d"math-paranthesis math-round-parenthesis"\x3e)\x3c/span\x3e'};var nodeToTex=FunctionNode.prototype.toTex;FunctionNode.prototype.toTex=
function(options){var customTex;options&&"object"===_typeof(options.handler)&&(0,_object.hasOwnProperty)(options.handler,this.name)&&(customTex=options.handler[this.name](this,options));return"undefined"!==typeof customTex?customTex:nodeToTex.call(this,options)};FunctionNode.prototype._toTex=function(options){var args=this.args.map(function(arg){return arg.toTex(options)}),latexConverter;_latex.latexFunctions[this.name]&&(latexConverter=_latex.latexFunctions[this.name]);!math$jscomp$0[this.name]||
"function"!==typeof math$jscomp$0[this.name].toTex&&"object"!==_typeof(math$jscomp$0[this.name].toTex)&&"string"!==typeof math$jscomp$0[this.name].toTex||(latexConverter=math$jscomp$0[this.name].toTex);switch(_typeof(latexConverter)){case "function":var customToTex=latexConverter(this,options);break;case "string":customToTex=expandTemplate(latexConverter,this,options);break;case "object":switch(_typeof(latexConverter[args.length])){case "function":customToTex=latexConverter[args.length](this,options);
break;case "string":customToTex=expandTemplate(latexConverter[args.length],this,options)}}return"undefined"!==typeof customToTex?customToTex:expandTemplate(_latex.defaultTemplate,this,options)};FunctionNode.prototype.getIdentifier=function(){return this.type+":"+this.name};return FunctionNode},{isClass:!0,isNode:!0});exports.createFunctionNode=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$expression$node$FunctionNode.js.map
