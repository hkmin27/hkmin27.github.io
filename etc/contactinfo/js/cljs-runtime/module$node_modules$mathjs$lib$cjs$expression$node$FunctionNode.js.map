{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$expression$node$FunctionNode.js",
"lineCount":17,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/expression/node/FunctionNode.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$expression$node$FunctionNode\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createFunctionNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _customs = require(\"../../utils/customs.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _latex = require(\"../../utils/latex.js\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nvar name = 'FunctionNode';\nvar dependencies = ['math', 'Node', 'SymbolNode'];\nvar createFunctionNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var math = _ref.math,\n      Node = _ref.Node,\n      SymbolNode = _ref.SymbolNode;\n\n  /**\n   * @constructor FunctionNode\n   * @extends {./Node}\n   * invoke a list with arguments on a node\n   * @param {./Node | string} fn Node resolving with a function on which to invoke\n   *                             the arguments, typically a SymboNode or AccessorNode\n   * @param {./Node[]} args\n   */\n  function FunctionNode(fn, args) {\n    if (!(this instanceof FunctionNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (typeof fn === 'string') {\n      fn = new SymbolNode(fn);\n    } // validate input\n\n\n    if (!(0, _is.isNode)(fn)) throw new TypeError('Node expected as parameter \"fn\"');\n\n    if (!Array.isArray(args) || !args.every(_is.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.fn = fn;\n    this.args = args || []; // readonly property name\n\n    Object.defineProperty(this, 'name', {\n      get: function () {\n        return this.fn.name || '';\n      }.bind(this),\n      set: function set() {\n        throw new Error('Cannot assign a new name, name is read-only');\n      }\n    });\n  }\n\n  FunctionNode.prototype = new Node();\n  FunctionNode.prototype.type = 'FunctionNode';\n  FunctionNode.prototype.isFunctionNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionNode.prototype._compile = function (math, argNames) {\n    if (!(this instanceof FunctionNode)) {\n      throw new TypeError('No valid FunctionNode');\n    } // compile arguments\n\n\n    var evalArgs = (0, _array.map)(this.args, function (arg) {\n      return arg._compile(math, argNames);\n    });\n\n    if ((0, _is.isSymbolNode)(this.fn)) {\n      var resolveFn = function resolveFn(scope) {\n        return _name in scope ? (0, _customs.getSafeProperty)(scope, _name) : _name in math ? (0, _customs.getSafeProperty)(math, _name) : FunctionNode.onUndefinedFunction(_name);\n      };\n\n      // we can statically determine whether the function has an rawArgs property\n      var _name = this.fn.name;\n      var fn = _name in math ? (0, _customs.getSafeProperty)(math, _name) : undefined;\n      var isRaw = typeof fn === 'function' && fn.rawArgs === true;\n\n      if (isRaw) {\n        // pass unevaluated parameters (nodes) to the function\n        // \"raw\" evaluation\n        var rawArgs = this.args;\n        return function evalFunctionNode(scope, args, context) {\n          var fn = resolveFn(scope);\n          return fn(rawArgs, math, _extends({}, scope, args));\n        };\n      } else {\n        // \"regular\" evaluation\n        if (evalArgs.length === 1) {\n          var evalArg0 = evalArgs[0];\n          return function evalFunctionNode(scope, args, context) {\n            var fn = resolveFn(scope);\n            return fn(evalArg0(scope, args, context));\n          };\n        } else if (evalArgs.length === 2) {\n          var _evalArg = evalArgs[0];\n          var evalArg1 = evalArgs[1];\n          return function evalFunctionNode(scope, args, context) {\n            var fn = resolveFn(scope);\n            return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n          };\n        } else {\n          return function evalFunctionNode(scope, args, context) {\n            var fn = resolveFn(scope);\n            return fn.apply(null, (0, _array.map)(evalArgs, function (evalArg) {\n              return evalArg(scope, args, context);\n            }));\n          };\n        }\n      }\n    } else if ((0, _is.isAccessorNode)(this.fn) && (0, _is.isIndexNode)(this.fn.index) && this.fn.index.isObjectProperty()) {\n      // execute the function with the right context: the object of the AccessorNode\n      var evalObject = this.fn.object._compile(math, argNames);\n\n      var prop = this.fn.index.getObjectProperty();\n      var _rawArgs = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var object = evalObject(scope, args, context);\n        (0, _customs.validateSafeMethod)(object, prop);\n        var isRaw = object[prop] && object[prop].rawArgs;\n        return isRaw ? object[prop](_rawArgs, math, _extends({}, scope, args)) // \"raw\" evaluation\n        : object[prop].apply(object, (0, _array.map)(evalArgs, function (evalArg) {\n          // \"regular\" evaluation\n          return evalArg(scope, args, context);\n        }));\n      };\n    } else {\n      // node.fn.isAccessorNode && !node.fn.index.isObjectProperty()\n      // we have to dynamically determine whether the function has a rawArgs property\n      var evalFn = this.fn._compile(math, argNames);\n\n      var _rawArgs2 = this.args;\n      return function evalFunctionNode(scope, args, context) {\n        var fn = evalFn(scope, args, context);\n        var isRaw = fn && fn.rawArgs;\n        return isRaw ? fn(_rawArgs2, math, _extends({}, scope, args)) // \"raw\" evaluation\n        : fn.apply(fn, (0, _array.map)(evalArgs, function (evalArg) {\n          // \"regular\" evaluation\n          return evalArg(scope, args, context);\n        }));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  FunctionNode.prototype.forEach = function (callback) {\n    callback(this.fn, 'fn', this);\n\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new FunctionNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionNode} Returns a transformed copy of the node\n   */\n\n\n  FunctionNode.prototype.map = function (callback) {\n    var fn = this._ifNode(callback(this.fn, 'fn', this));\n\n    var args = [];\n\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n\n    return new FunctionNode(fn, args);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionNode}\n   */\n\n\n  FunctionNode.prototype.clone = function () {\n    return new FunctionNode(this.fn, this.args.slice(0));\n  };\n  /**\n   * Throws an error 'Undefined function {name}'\n   * @param {string} name\n   */\n\n\n  FunctionNode.onUndefinedFunction = function (name) {\n    throw new Error('Undefined function ' + name);\n  }; // backup Node's toString function\n  // @private\n\n\n  var nodeToString = FunctionNode.prototype.toString;\n  /**\n   * Get string representation. (wrapper function)\n   * This overrides parts of Node's toString function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toString\n   * function.\n   *\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n  FunctionNode.prototype.toString = function (options) {\n    var customString;\n    var name = this.fn.toString(options);\n\n    if (options && _typeof(options.handler) === 'object' && (0, _object.hasOwnProperty)(options.handler, name)) {\n      // callback is a map of callback functions\n      customString = options.handler[name](this, options);\n    }\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    } // fall back to Node's toString\n\n\n    return nodeToString.call(this, options);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toString = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toString(options);\n    });\n    var fn = (0, _is.isFunctionAssignmentNode)(this.fn) ? '(' + this.fn.toString(options) + ')' : this.fn.toString(options); // format the arguments like \"add(2, 4.2)\"\n\n    return fn + '(' + args.join(', ') + ')';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  FunctionNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'FunctionNode',\n      fn: this.fn,\n      args: this.args\n    };\n  };\n  /**\n   * Instantiate an AssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionNode\", fn: ..., args: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionNode}\n   */\n\n\n  FunctionNode.fromJSON = function (json) {\n    return new FunctionNode(json.fn, json.args);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype.toHTML = function (options) {\n    var args = this.args.map(function (arg) {\n      return arg.toHTML(options);\n    }); // format the arguments like \"add(2, 4.2)\"\n\n    return '<span class=\"math-function\">' + (0, _string.escape)(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + args.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n  };\n  /*\n   * Expand a LaTeX template\n   *\n   * @param {string} template\n   * @param {Node} node\n   * @param {Object} options\n   * @private\n   **/\n\n\n  function expandTemplate(template, node, options) {\n    var latex = ''; // Match everything of the form ${identifier} or ${identifier[2]} or $$\n    // while submatching identifier and 2 (in the second case)\n\n    var regex = /\\$(?:\\{([a-z_][a-z_0-9]*)(?:\\[([0-9]+)\\])?\\}|\\$)/gi;\n    var inputPos = 0; // position in the input string\n\n    var match;\n\n    while ((match = regex.exec(template)) !== null) {\n      // go through all matches\n      // add everything in front of the match to the LaTeX string\n      latex += template.substring(inputPos, match.index);\n      inputPos = match.index;\n\n      if (match[0] === '$$') {\n        // escaped dollar sign\n        latex += '$';\n        inputPos++;\n      } else {\n        // template parameter\n        inputPos += match[0].length;\n        var property = node[match[1]];\n\n        if (!property) {\n          throw new ReferenceError('Template: Property ' + match[1] + ' does not exist.');\n        }\n\n        if (match[2] === undefined) {\n          // no square brackets\n          switch (_typeof(property)) {\n            case 'string':\n              latex += property;\n              break;\n\n            case 'object':\n              if ((0, _is.isNode)(property)) {\n                latex += property.toTex(options);\n              } else if (Array.isArray(property)) {\n                // make array of Nodes into comma separated list\n                latex += property.map(function (arg, index) {\n                  if ((0, _is.isNode)(arg)) {\n                    return arg.toTex(options);\n                  }\n\n                  throw new TypeError('Template: ' + match[1] + '[' + index + '] is not a Node.');\n                }).join(',');\n              } else {\n                throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n              }\n\n              break;\n\n            default:\n              throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');\n          }\n        } else {\n          // with square brackets\n          if ((0, _is.isNode)(property[match[2]] && property[match[2]])) {\n            latex += property[match[2]].toTex(options);\n          } else {\n            throw new TypeError('Template: ' + match[1] + '[' + match[2] + '] is not a Node.');\n          }\n        }\n      }\n    }\n\n    latex += template.slice(inputPos); // append rest of the template\n\n    return latex;\n  } // backup Node's toTex function\n  // @private\n\n\n  var nodeToTex = FunctionNode.prototype.toTex;\n  /**\n   * Get LaTeX representation. (wrapper function)\n   * This overrides parts of Node's toTex function.\n   * If callback is an object containing callbacks, it\n   * calls the correct callback for the current node,\n   * otherwise it falls back to calling Node's toTex\n   * function.\n   *\n   * @param {Object} options\n   * @return {string}\n   */\n\n  FunctionNode.prototype.toTex = function (options) {\n    var customTex;\n\n    if (options && _typeof(options.handler) === 'object' && (0, _object.hasOwnProperty)(options.handler, this.name)) {\n      // callback is a map of callback functions\n      customTex = options.handler[this.name](this, options);\n    }\n\n    if (typeof customTex !== 'undefined') {\n      return customTex;\n    } // fall back to Node's toTex\n\n\n    return nodeToTex.call(this, options);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionNode.prototype._toTex = function (options) {\n    var args = this.args.map(function (arg) {\n      // get LaTeX of the arguments\n      return arg.toTex(options);\n    });\n    var latexConverter;\n\n    if (_latex.latexFunctions[this.name]) {\n      latexConverter = _latex.latexFunctions[this.name];\n    } // toTex property on the function itself\n\n\n    if (math[this.name] && (typeof math[this.name].toTex === 'function' || _typeof(math[this.name].toTex) === 'object' || typeof math[this.name].toTex === 'string')) {\n      // .toTex is a callback function\n      latexConverter = math[this.name].toTex;\n    }\n\n    var customToTex;\n\n    switch (_typeof(latexConverter)) {\n      case 'function':\n        // a callback function\n        customToTex = latexConverter(this, options);\n        break;\n\n      case 'string':\n        // a template string\n        customToTex = expandTemplate(latexConverter, this, options);\n        break;\n\n      case 'object':\n        // an object with different \"converters\" for different numbers of arguments\n        switch (_typeof(latexConverter[args.length])) {\n          case 'function':\n            customToTex = latexConverter[args.length](this, options);\n            break;\n\n          case 'string':\n            customToTex = expandTemplate(latexConverter[args.length], this, options);\n            break;\n        }\n\n    }\n\n    if (typeof customToTex !== 'undefined') {\n      return customToTex;\n    }\n\n    return expandTemplate(_latex.defaultTemplate, this, options);\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  FunctionNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.name;\n  };\n\n  return FunctionNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createFunctionNode = createFunctionNode;\n};"],
"names":["shadow$provide","global","require","module","exports","_typeof","obj","Symbol","iterator","constructor","prototype","_extends","Object","assign","target","i","arguments","length","source","key","hasOwnProperty","call","apply","defineProperty","value","createFunctionNode","_is","_string","_object","_array","_customs","_factory","_latex","factory","name","dependencies","_ref","FunctionNode","fn","args","SyntaxError","SymbolNode","isNode","TypeError","Array","isArray","every","get","bind","set","Error","expandTemplate","template","node","options","latex","regex","inputPos","match","exec","substring","index","property","ReferenceError","undefined","toTex","map","arg","join","slice","math","Node","type","isFunctionNode","_compile","FunctionNode.prototype._compile","argNames","evalArgs","isSymbolNode","resolveFn","scope","_name","getSafeProperty","onUndefinedFunction","rawArgs","evalFunctionNode","context","evalArg0","_evalArg","evalArg1","evalArg","isAccessorNode","isIndexNode","isObjectProperty","evalObject","object","prop","getObjectProperty","_rawArgs","validateSafeMethod","evalFn","_rawArgs2","forEach","FunctionNode.prototype.forEach","callback","FunctionNode.prototype.map","_ifNode","clone","FunctionNode.prototype.clone","FunctionNode.onUndefinedFunction","nodeToString","toString","FunctionNode.prototype.toString","customString","handler","_toString","FunctionNode.prototype._toString","isFunctionAssignmentNode","toJSON","FunctionNode.prototype.toJSON","mathjs","fromJSON","FunctionNode.fromJSON","json","toHTML","FunctionNode.prototype.toHTML","escape","nodeToTex","FunctionNode.prototype.toTex","customTex","_toTex","FunctionNode.prototype._toTex","latexConverter","latexFunctions","customToTex","defaultTemplate","getIdentifier","FunctionNode.prototype.getIdentifier","isClass"]
}
