{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$expression$parse.js",
"lineCount":41,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/expression/parse.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$expression$parse\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createParse = void 0;\n\nvar _factory = require(\"../utils/factory.js\");\n\nvar _is = require(\"../utils/is.js\");\n\nvar _collection = require(\"../utils/collection.js\");\n\nvar _object = require(\"../utils/object.js\");\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nvar name = 'parse';\nvar dependencies = ['typed', 'numeric', 'config', 'AccessorNode', 'ArrayNode', 'AssignmentNode', 'BlockNode', 'ConditionalNode', 'ConstantNode', 'FunctionAssignmentNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'RangeNode', 'RelationalNode', 'SymbolNode'];\nvar createParse = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      numeric = _ref.numeric,\n      config = _ref.config,\n      AccessorNode = _ref.AccessorNode,\n      ArrayNode = _ref.ArrayNode,\n      AssignmentNode = _ref.AssignmentNode,\n      BlockNode = _ref.BlockNode,\n      ConditionalNode = _ref.ConditionalNode,\n      ConstantNode = _ref.ConstantNode,\n      FunctionAssignmentNode = _ref.FunctionAssignmentNode,\n      FunctionNode = _ref.FunctionNode,\n      IndexNode = _ref.IndexNode,\n      ObjectNode = _ref.ObjectNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode,\n      RangeNode = _ref.RangeNode,\n      RelationalNode = _ref.RelationalNode,\n      SymbolNode = _ref.SymbolNode;\n\n  /**\n   * Parse an expression. Returns a node tree, which can be evaluated by\n   * invoking node.evaluate().\n   *\n   * Note the evaluating arbitrary expressions may involve security risks,\n   * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.\n   *\n   * Syntax:\n   *\n   *     math.parse(expr)\n   *     math.parse(expr, options)\n   *     math.parse([expr1, expr2, expr3, ...])\n   *     math.parse([expr1, expr2, expr3, ...], options)\n   *\n   * Example:\n   *\n   *     const node1 = math.parse('sqrt(3^2 + 4^2)')\n   *     node1.compile().evaluate() // 5\n   *\n   *     let scope = {a:3, b:4}\n   *     const node2 = math.parse('a * b') // 12\n   *     const code2 = node2.compile()\n   *     code2.evaluate(scope) // 12\n   *     scope.a = 5\n   *     code2.evaluate(scope) // 20\n   *\n   *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])\n   *     nodes[2].compile().evaluate() // 12\n   *\n   * See also:\n   *\n   *     evaluate, compile\n   *\n   * @param {string | string[] | Matrix} expr          Expression to be parsed\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\n   *                                                   - `nodes` a set of custom nodes\n   * @return {Node | Node[]} node\n   * @throws {Error}\n   */\n  var parse = typed(name, {\n    string: function string(expression) {\n      return parseStart(expression, {});\n    },\n    'Array | Matrix': function ArrayMatrix(expressions) {\n      return parseMultiple(expressions, {});\n    },\n    'string, Object': function stringObject(expression, options) {\n      var extraNodes = options.nodes !== undefined ? options.nodes : {};\n      return parseStart(expression, extraNodes);\n    },\n    'Array | Matrix, Object': parseMultiple\n  });\n\n  function parseMultiple(expressions) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var extraNodes = options.nodes !== undefined ? options.nodes : {}; // parse an array or matrix with expressions\n\n    return (0, _collection.deepMap)(expressions, function (elem) {\n      if (typeof elem !== 'string') throw new TypeError('String expected');\n      return parseStart(elem, extraNodes);\n    });\n  } // token types enumeration\n\n\n  var TOKENTYPE = {\n    NULL: 0,\n    DELIMITER: 1,\n    NUMBER: 2,\n    SYMBOL: 3,\n    UNKNOWN: 4\n  }; // map with all delimiters\n\n  var DELIMITERS = {\n    ',': true,\n    '(': true,\n    ')': true,\n    '[': true,\n    ']': true,\n    '{': true,\n    '}': true,\n    '\"': true,\n    '\\'': true,\n    ';': true,\n    '+': true,\n    '-': true,\n    '*': true,\n    '.*': true,\n    '/': true,\n    './': true,\n    '%': true,\n    '^': true,\n    '.^': true,\n    '~': true,\n    '!': true,\n    '&': true,\n    '|': true,\n    '^|': true,\n    '=': true,\n    ':': true,\n    '?': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '<<': true,\n    '>>': true,\n    '>>>': true\n  }; // map with all named delimiters\n\n  var NAMED_DELIMITERS = {\n    mod: true,\n    to: true,\n    \"in\": true,\n    and: true,\n    xor: true,\n    or: true,\n    not: true\n  };\n  var CONSTANTS = {\n    \"true\": true,\n    \"false\": false,\n    \"null\": null,\n    undefined: undefined\n  };\n  var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];\n\n  function initialState() {\n    return {\n      extraNodes: {},\n      // current extra nodes, must be careful not to mutate\n      expression: '',\n      // current expression\n      comment: '',\n      // last parsed comment\n      index: 0,\n      // current index in expr\n      token: '',\n      // current token\n      tokenType: TOKENTYPE.NULL,\n      // type of the token\n      nestingLevel: 0,\n      // level of nesting inside parameters, used to ignore newline characters\n      conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here\n\n    };\n  }\n  /**\n   * View upto `length` characters of the expression starting at the current character.\n   *\n   * @param {Object} state\n   * @param {number} [length=1] Number of characters to view\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentString(state, length) {\n    return state.expression.substr(state.index, length);\n  }\n  /**\n   * View the current character. Returns '' if end of expression is reached.\n   *\n   * @param {Object} state\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentCharacter(state) {\n    return currentString(state, 1);\n  }\n  /**\n   * Get the next character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n\n\n  function next(state) {\n    state.index++;\n  }\n  /**\n   * Preview the previous character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function prevCharacter(state) {\n    return state.expression.charAt(state.index - 1);\n  }\n  /**\n   * Preview the next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function nextCharacter(state) {\n    return state.expression.charAt(state.index + 1);\n  }\n  /**\n   * Get next token in the current string expr.\n   * The token and token type are available as token and tokenType\n   * @private\n   */\n\n\n  function getToken(state) {\n    state.tokenType = TOKENTYPE.NULL;\n    state.token = '';\n    state.comment = ''; // skip over whitespaces\n    // space, tab, and newline when inside parameters\n\n    while (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {\n      next(state);\n    } // skip comment\n\n\n    if (currentCharacter(state) === '#') {\n      while (currentCharacter(state) !== '\\n' && currentCharacter(state) !== '') {\n        state.comment += currentCharacter(state);\n        next(state);\n      }\n    } // check for end of expression\n\n\n    if (currentCharacter(state) === '') {\n      // token is still empty\n      state.tokenType = TOKENTYPE.DELIMITER;\n      return;\n    } // check for new line character\n\n\n    if (currentCharacter(state) === '\\n' && !state.nestingLevel) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = currentCharacter(state);\n      next(state);\n      return;\n    }\n\n    var c1 = currentCharacter(state);\n    var c2 = currentString(state, 2);\n    var c3 = currentString(state, 3);\n\n    if (c3.length === 3 && DELIMITERS[c3]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c3;\n      next(state);\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 2 characters\n\n\n    if (c2.length === 2 && DELIMITERS[c2]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c2;\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 1 character\n\n\n    if (DELIMITERS[c1]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c1;\n      next(state);\n      return;\n    } // check for a number\n\n\n    if (parse.isDigitDot(c1)) {\n      state.tokenType = TOKENTYPE.NUMBER; // check for binary, octal, or hex\n\n      var _c = currentString(state, 2);\n\n      if (_c === '0b' || _c === '0o' || _c === '0x') {\n        state.token += currentCharacter(state);\n        next(state);\n        state.token += currentCharacter(state);\n        next(state);\n\n        while (parse.isHexDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n\n        if (currentCharacter(state) === '.') {\n          // this number has a radix point\n          state.token += '.';\n          next(state); // get the digits after the radix\n\n          while (parse.isHexDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        } else if (currentCharacter(state) === 'i') {\n          // this number has a word size suffix\n          state.token += 'i';\n          next(state); // get the word size\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        }\n\n        return;\n      } // get number, can have a single dot\n\n\n      if (currentCharacter(state) === '.') {\n        state.token += currentCharacter(state);\n        next(state);\n\n        if (!parse.isDigit(currentCharacter(state))) {\n          // this is no number, it is just a dot (can be dot notation)\n          state.tokenType = TOKENTYPE.DELIMITER;\n        }\n      } else {\n        while (parse.isDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n\n        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n      }\n\n      while (parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      } // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\n\n\n      if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {\n        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {\n          state.token += currentCharacter(state);\n          next(state);\n\n          if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {\n            state.token += currentCharacter(state);\n            next(state);\n          } // Scientific notation MUST be followed by an exponent\n\n\n          if (!parse.isDigit(currentCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n\n          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n        } else if (nextCharacter(state) === '.') {\n          next(state);\n          throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n        }\n      }\n\n      return;\n    } // check for variables, functions, named operators\n\n\n    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {\n      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      }\n\n      if ((0, _object.hasOwnProperty)(NAMED_DELIMITERS, state.token)) {\n        state.tokenType = TOKENTYPE.DELIMITER;\n      } else {\n        state.tokenType = TOKENTYPE.SYMBOL;\n      }\n\n      return;\n    } // something unknown is found, wrong characters -> a syntax error\n\n\n    state.tokenType = TOKENTYPE.UNKNOWN;\n\n    while (currentCharacter(state) !== '') {\n      state.token += currentCharacter(state);\n      next(state);\n    }\n\n    throw createSyntaxError(state, 'Syntax error in part \"' + state.token + '\"');\n  }\n  /**\n   * Get next token and skip newline tokens\n   */\n\n\n  function getTokenSkipNewline(state) {\n    do {\n      getToken(state);\n    } while (state.token === '\\n'); // eslint-disable-line no-unmodified-loop-condition\n\n  }\n  /**\n   * Open parameters.\n   * New line characters will be ignored until closeParams(state) is called\n   */\n\n\n  function openParams(state) {\n    state.nestingLevel++;\n  }\n  /**\n   * Close parameters.\n   * New line characters will no longer be ignored\n   */\n\n\n  function closeParams(state) {\n    state.nestingLevel--;\n  }\n  /**\n   * Checks whether the current character `c` is a valid alpha character:\n   *\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\n   * - An underscore                        Ascii: _\n   * - A dollar sign                        Ascii: $\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\n   *\n   * The previous and next characters are needed to determine whether\n   * this character is part of a unicode surrogate pair.\n   *\n   * @param {string} c      Current character in the expression\n   * @param {string} cPrev  Previous character\n   * @param {string} cNext  Next character\n   * @return {boolean}\n   */\n\n\n  parse.isAlpha = function isAlpha(c, cPrev, cNext) {\n    return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);\n  };\n  /**\n   * Test whether a character is a valid latin, greek, or letter-like character\n   * @param {string} c\n   * @return {boolean}\n   */\n\n\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\n  };\n  /**\n   * Test whether two given 16 bit characters form a surrogate pair of a\n   * unicode math symbol.\n   *\n   * https://unicode-table.com/en/\n   * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\n   *\n   * Note: In ES6 will be unicode aware:\n   * https://stackoverflow.com/questions/280712/javascript-unicode-regexes\n   * https://mathiasbynens.be/notes/es6-unicode-regex\n   *\n   * @param {string} high\n   * @param {string} low\n   * @return {boolean}\n   */\n\n\n  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {\n    return /^[\\uD835]$/.test(high) && /^[\\uDC00-\\uDFFF]$/.test(low) && /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\n  };\n  /**\n   * Check whether given character c is a white space character: space, tab, or enter\n   * @param {string} c\n   * @param {number} nestingLevel\n   * @return {boolean}\n   */\n\n\n  parse.isWhitespace = function isWhitespace(c, nestingLevel) {\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\n    return c === ' ' || c === '\\t' || c === '\\n' && nestingLevel > 0;\n  };\n  /**\n   * Test whether the character c is a decimal mark (dot).\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\n   * @param {string} c\n   * @param {string} cNext\n   * @return {boolean}\n   */\n\n\n  parse.isDecimalMark = function isDecimalMark(c, cNext) {\n    return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\n  };\n  /**\n   * checks if the given char c is a digit or dot\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigitDot = function isDigitDot(c) {\n    return c >= '0' && c <= '9' || c === '.';\n  };\n  /**\n   * checks if the given char c is a digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigit = function isDigit(c) {\n    return c >= '0' && c <= '9';\n  };\n  /**\n   * checks if the given char c is a hex digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isHexDigit = function isHexDigit(c) {\n    return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\n  };\n  /**\n   * Start of the parse levels below, in order of precedence\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseStart(expression, extraNodes) {\n    var state = initialState();\n\n    _extends(state, {\n      expression: expression,\n      extraNodes: extraNodes\n    });\n\n    getToken(state);\n    var node = parseBlock(state); // check for garbage at the end of the expression\n    // an expression ends with a empty character '' and tokenType DELIMITER\n\n    if (state.token !== '') {\n      if (state.tokenType === TOKENTYPE.DELIMITER) {\n        // user entered a not existing operator like \"//\"\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean !== ?\"\n        throw createError(state, 'Unexpected operator ' + state.token);\n      } else {\n        throw createSyntaxError(state, 'Unexpected part \"' + state.token + '\"');\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a block with expressions. Expressions can be separated by a newline\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\n   * of the preceding line is returned.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBlock(state) {\n    var node;\n    var blocks = [];\n    var visible;\n\n    if (state.token !== '' && state.token !== '\\n' && state.token !== ';') {\n      node = parseAssignment(state);\n      node.comment = state.comment;\n    } // TODO: simplify this loop\n\n\n    while (state.token === '\\n' || state.token === ';') {\n      // eslint-disable-line no-unmodified-loop-condition\n      if (blocks.length === 0 && node) {\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n\n      getToken(state);\n\n      if (state.token !== '\\n' && state.token !== ';' && state.token !== '') {\n        node = parseAssignment(state);\n        node.comment = state.comment;\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n    }\n\n    if (blocks.length > 0) {\n      return new BlockNode(blocks);\n    } else {\n      if (!node) {\n        node = new ConstantNode(undefined);\n        node.comment = state.comment;\n      }\n\n      return node;\n    }\n  }\n  /**\n   * Assignment of a function or variable,\n   * - can be a variable like 'a=2.3'\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\n   * - defining a function like 'f(x) = x^2'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAssignment(state) {\n    var name, args, value, valid;\n    var node = parseConditional(state);\n\n    if (state.token === '=') {\n      if ((0, _is.isSymbolNode)(node)) {\n        // parse a variable assignment like 'a = 2/3'\n        name = node.name;\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(new SymbolNode(name), value);\n      } else if ((0, _is.isAccessorNode)(node)) {\n        // parse a matrix subset assignment like 'A[1,2] = 4'\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(node.object, node.index, value);\n      } else if ((0, _is.isFunctionNode)(node) && (0, _is.isSymbolNode)(node.fn)) {\n        // parse function assignment like 'f(x) = x^2'\n        valid = true;\n        args = [];\n        name = node.name;\n        node.args.forEach(function (arg, index) {\n          if ((0, _is.isSymbolNode)(arg)) {\n            args[index] = arg.name;\n          } else {\n            valid = false;\n          }\n        });\n\n        if (valid) {\n          getTokenSkipNewline(state);\n          value = parseAssignment(state);\n          return new FunctionAssignmentNode(name, args, value);\n        }\n      }\n\n      throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');\n    }\n\n    return node;\n  }\n  /**\n   * conditional operation\n   *\n   *     condition ? truePart : falsePart\n   *\n   * Note: conditional operator is right-associative\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConditional(state) {\n    var node = parseLogicalOr(state);\n\n    while (state.token === '?') {\n      // eslint-disable-line no-unmodified-loop-condition\n      // set a conditional level, the range operator will be ignored as long\n      // as conditionalLevel === state.nestingLevel.\n      var prev = state.conditionalLevel;\n      state.conditionalLevel = state.nestingLevel;\n      getTokenSkipNewline(state);\n      var condition = node;\n      var trueExpr = parseAssignment(state);\n      if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');\n      state.conditionalLevel = null;\n      getTokenSkipNewline(state);\n      var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity\n\n      node = new ConditionalNode(condition, trueExpr, falseExpr); // restore the previous conditional level\n\n      state.conditionalLevel = prev;\n    }\n\n    return node;\n  }\n  /**\n   * logical or, 'x or y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalOr(state) {\n    var node = parseLogicalXor(state);\n\n    while (state.token === 'or') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical exclusive or, 'x xor y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalXor(state) {\n    var node = parseLogicalAnd(state);\n\n    while (state.token === 'xor') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical and, 'x and y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalAnd(state) {\n    var node = parseBitwiseOr(state);\n\n    while (state.token === 'and') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise or, 'x | y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseOr(state) {\n    var node = parseBitwiseXor(state);\n\n    while (state.token === '|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise exclusive or (xor), 'x ^| y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseXor(state) {\n    var node = parseBitwiseAnd(state);\n\n    while (state.token === '^|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise and, 'x & y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseAnd(state) {\n    var node = parseRelational(state);\n\n    while (state.token === '&') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a chained conditional, like 'a > b >= c'\n   * @return {Node} node\n   */\n\n\n  function parseRelational(state) {\n    var params = [parseShift(state)];\n    var conditionals = [];\n    var operators = {\n      '==': 'equal',\n      '!=': 'unequal',\n      '<': 'smaller',\n      '>': 'larger',\n      '<=': 'smallerEq',\n      '>=': 'largerEq'\n    };\n\n    while ((0, _object.hasOwnProperty)(operators, state.token)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      var cond = {\n        name: state.token,\n        fn: operators[state.token]\n      };\n      conditionals.push(cond);\n      getTokenSkipNewline(state);\n      params.push(parseShift(state));\n    }\n\n    if (params.length === 1) {\n      return params[0];\n    } else if (params.length === 2) {\n      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);\n    } else {\n      return new RelationalNode(conditionals.map(function (c) {\n        return c.fn;\n      }), params);\n    }\n  }\n  /**\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseShift(state) {\n    var node, name, fn, params;\n    node = parseConversion(state);\n    var operators = {\n      '<<': 'leftShift',\n      '>>': 'rightArithShift',\n      '>>>': 'rightLogShift'\n    };\n\n    while ((0, _object.hasOwnProperty)(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseConversion(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * conversion operators 'to' and 'in'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConversion(state) {\n    var node, name, fn, params;\n    node = parseRange(state);\n    var operators = {\n      to: 'to',\n      \"in\": 'to' // alias of 'to'\n\n    };\n\n    while ((0, _object.hasOwnProperty)(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n\n      if (name === 'in' && state.token === '') {\n        // end of expression -> this is the unit 'in' ('inch')\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\n      } else {\n        // operator 'a to b' or 'a in b'\n        params = [node, parseRange(state)];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n  /**\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRange(state) {\n    var node;\n    var params = [];\n\n    if (state.token === ':') {\n      // implicit start=1 (one-based)\n      node = new ConstantNode(1);\n    } else {\n      // explicit start\n      node = parseAddSubtract(state);\n    }\n\n    if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {\n      // we ignore the range operator when a conditional operator is being processed on the same level\n      params.push(node); // parse step and end\n\n      while (state.token === ':' && params.length < 3) {\n        // eslint-disable-line no-unmodified-loop-condition\n        getTokenSkipNewline(state);\n\n        if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {\n          // implicit end\n          params.push(new SymbolNode('end'));\n        } else {\n          // explicit end\n          params.push(parseAddSubtract(state));\n        }\n      }\n\n      if (params.length === 3) {\n        // params = [start, step, end]\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\n      } else {\n        // length === 2\n        // params = [start, end]\n        node = new RangeNode(params[0], params[1]); // start, end\n      }\n    }\n\n    return node;\n  }\n  /**\n   * add or subtract\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAddSubtract(state) {\n    var node, name, fn, params;\n    node = parseMultiplyDivide(state);\n    var operators = {\n      '+': 'add',\n      '-': 'subtract'\n    };\n\n    while ((0, _object.hasOwnProperty)(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseMultiplyDivide(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * multiply, divide, modulus\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMultiplyDivide(state) {\n    var node, last, name, fn;\n    node = parseImplicitMultiplication(state);\n    last = node;\n    var operators = {\n      '*': 'multiply',\n      '.*': 'dotMultiply',\n      '/': 'divide',\n      './': 'dotDivide',\n      '%': 'mod',\n      mod: 'mod'\n    };\n\n    while (true) {\n      if ((0, _object.hasOwnProperty)(operators, state.token)) {\n        // explicit operators\n        name = state.token;\n        fn = operators[name];\n        getTokenSkipNewline(state);\n        last = parseImplicitMultiplication(state);\n        node = new OperatorNode(name, fn, [node, last]);\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * implicit multiplication\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseImplicitMultiplication(state) {\n    var node, last;\n    node = parseRule2(state);\n    last = node;\n\n    while (true) {\n      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && (0, _is.isConstantNode)(node) || state.tokenType === TOKENTYPE.NUMBER && !(0, _is.isConstantNode)(last) && (!(0, _is.isOperatorNode)(last) || last.op === '!') || state.token === '(') {\n        // parse implicit multiplication\n        //\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\n        // number:      implicit multiplication like '(2+3)2'\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\n        last = parseRule2(state);\n        node = new OperatorNode('*', 'multiply', [node, last], true\n        /* implicit */\n        );\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Infamous \"rule 2\" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370\n   * Explicit division gets higher precedence than implicit multiplication\n   * when the division matches this pattern: [number] / [number] [symbol]\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRule2(state) {\n    var node = parseUnary(state);\n    var last = node;\n    var tokenStates = [];\n\n    while (true) {\n      // Match the \"number /\" part of the pattern \"number / number symbol\"\n      if (state.token === '/' && (0, _is.isConstantNode)(last)) {\n        // Look ahead to see if the next token is a number\n        tokenStates.push(_extends({}, state));\n        getTokenSkipNewline(state); // Match the \"number / number\" part of the pattern\n\n        if (state.tokenType === TOKENTYPE.NUMBER) {\n          // Look ahead again\n          tokenStates.push(_extends({}, state));\n          getTokenSkipNewline(state); // Match the \"symbol\" part of the pattern, or a left parenthesis\n\n          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(') {\n            // We've matched the pattern \"number / number symbol\".\n            // Rewind once and build the \"number / number\" node; the symbol will be consumed later\n            _extends(state, tokenStates.pop());\n\n            tokenStates.pop();\n            last = parseUnary(state);\n            node = new OperatorNode('/', 'divide', [node, last]);\n          } else {\n            // Not a match, so rewind\n            tokenStates.pop();\n\n            _extends(state, tokenStates.pop());\n\n            break;\n          }\n        } else {\n          // Not a match, so rewind\n          _extends(state, tokenStates.pop());\n\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Unary plus and minus, and logical and bitwise not\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseUnary(state) {\n    var name, params, fn;\n    var operators = {\n      '-': 'unaryMinus',\n      '+': 'unaryPlus',\n      '~': 'bitNot',\n      not: 'not'\n    };\n\n    if ((0, _object.hasOwnProperty)(operators, state.token)) {\n      fn = operators[state.token];\n      name = state.token;\n      getTokenSkipNewline(state);\n      params = [parseUnary(state)];\n      return new OperatorNode(name, fn, params);\n    }\n\n    return parsePow(state);\n  }\n  /**\n   * power\n   * Note: power operator is right associative\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parsePow(state) {\n    var node, name, fn, params;\n    node = parseLeftHandOperators(state);\n\n    if (state.token === '^' || state.token === '.^') {\n      name = state.token;\n      fn = name === '^' ? 'pow' : 'dotPow';\n      getTokenSkipNewline(state);\n      params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'\n\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * Left hand operators: factorial x!, ctranspose x'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLeftHandOperators(state) {\n    var node, name, fn, params;\n    node = parseCustomNodes(state);\n    var operators = {\n      '!': 'factorial',\n      '\\'': 'ctranspose'\n    };\n\n    while ((0, _object.hasOwnProperty)(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getToken(state);\n      params = [node];\n      node = new OperatorNode(name, fn, params);\n      node = parseAccessors(state, node);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a custom node handler. A node handler can be used to process\n   * nodes in a custom way, for example for handling a plot.\n   *\n   * A handler must be passed as second argument of the parse function.\n   * - must extend math.Node\n   * - must contain a function _compile(defs: Object) : string\n   * - must contain a function find(filter: Object) : Node[]\n   * - must contain a function toString() : string\n   * - the constructor is called with a single argument containing all parameters\n   *\n   * For example:\n   *\n   *     nodes = {\n   *       'plot': PlotHandler\n   *     }\n   *\n   * The constructor of the handler is called as:\n   *\n   *     node = new PlotHandler(params)\n   *\n   * The handler will be invoked when evaluating an expression like:\n   *\n   *     node = math.parse('plot(sin(x), x)', nodes)\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseCustomNodes(state) {\n    var params = [];\n\n    if (state.tokenType === TOKENTYPE.SYMBOL && (0, _object.hasOwnProperty)(state.extraNodes, state.token)) {\n      var CustomNode = state.extraNodes[state.token];\n      getToken(state); // parse parameters\n\n      if (state.token === '(') {\n        params = [];\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ')') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ')') {\n          throw createSyntaxError(state, 'Parenthesis ) expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n      } // create a new custom node\n      // noinspection JSValidateTypes\n\n\n      return new CustomNode(params);\n    }\n\n    return parseSymbol(state);\n  }\n  /**\n   * parse symbols: functions, variables, constants, units\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSymbol(state) {\n    var node, name;\n\n    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n      name = state.token;\n      getToken(state);\n\n      if ((0, _object.hasOwnProperty)(CONSTANTS, name)) {\n        // true, false, null, ...\n        node = new ConstantNode(CONSTANTS[name]);\n      } else if (NUMERIC_CONSTANTS.indexOf(name) !== -1) {\n        // NaN, Infinity\n        node = new ConstantNode(numeric(name, 'number'));\n      } else {\n        node = new SymbolNode(name);\n      } // parse function parameters and matrix index\n\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseDoubleQuotesString(state);\n  }\n  /**\n   * parse accessors:\n   * - function invocation in round brackets (...), for example sqrt(2)\n   * - index enclosed in square brackets [...], for example A[2,3]\n   * - dot notation for properties, like foo.bar\n   * @param {Object} state\n   * @param {Node} node    Node on which to apply the parameters. If there\n   *                       are no parameters in the expression, the node\n   *                       itself is returned\n   * @param {string[]} [types]  Filter the types of notations\n   *                            can be ['(', '[', '.']\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAccessors(state, node, types) {\n    var params;\n\n    while ((state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.indexOf(state.token) !== -1)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      params = [];\n\n      if (state.token === '(') {\n        if ((0, _is.isSymbolNode)(node) || (0, _is.isAccessorNode)(node)) {\n          // function invocation like fn(2, 3) or obj.fn(2, 3)\n          openParams(state);\n          getToken(state);\n\n          if (state.token !== ')') {\n            params.push(parseAssignment(state)); // parse a list with parameters\n\n            while (state.token === ',') {\n              // eslint-disable-line no-unmodified-loop-condition\n              getToken(state);\n              params.push(parseAssignment(state));\n            }\n          }\n\n          if (state.token !== ')') {\n            throw createSyntaxError(state, 'Parenthesis ) expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          node = new FunctionNode(node, params);\n        } else {\n          // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)\n          // don't parse it here but let it be handled by parseImplicitMultiplication\n          // with correct precedence\n          return node;\n        }\n      } else if (state.token === '[') {\n        // index notation like variable[2, 3]\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ']') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ']') {\n          throw createSyntaxError(state, 'Parenthesis ] expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n        node = new AccessorNode(node, new IndexNode(params));\n      } else {\n        // dot notation like variable.prop\n        getToken(state);\n\n        if (state.tokenType !== TOKENTYPE.SYMBOL) {\n          throw createSyntaxError(state, 'Property name expected after dot');\n        }\n\n        params.push(new ConstantNode(state.token));\n        getToken(state);\n        var dotNotation = true;\n        node = new AccessorNode(node, new IndexNode(params, dotNotation));\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a double quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseDoubleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\"') {\n      str = parseDoubleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseSingleQuotesString(state);\n  }\n  /**\n   * Parse a string surrounded by double quotes \"...\"\n   * @return {string}\n   */\n\n\n  function parseDoubleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\"') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\\"'\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\"') {\n      throw createSyntaxError(state, 'End of string \" expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * Parse a single quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSingleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\\'') {\n      str = parseSingleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseMatrix(state);\n  }\n  /**\n   * Parse a string surrounded by single quotes '...'\n   * @return {string}\n   */\n\n\n  function parseSingleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\\'') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\''\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\\'') {\n      throw createSyntaxError(state, 'End of string \\' expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * parse the matrix\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMatrix(state) {\n    var array, params, rows, cols;\n\n    if (state.token === '[') {\n      // matrix [...]\n      openParams(state);\n      getToken(state);\n\n      if (state.token !== ']') {\n        // this is a non-empty matrix\n        var row = parseRow(state);\n\n        if (state.token === ';') {\n          // 2 dimensional array\n          rows = 1;\n          params = [row]; // the rows of the matrix are separated by dot-comma's\n\n          while (state.token === ';') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params[rows] = parseRow(state);\n            rows++;\n          }\n\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state); // check if the number of columns matches in all rows\n\n          cols = params[0].items.length;\n\n          for (var r = 1; r < rows; r++) {\n            if (params[r].items.length !== cols) {\n              throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');\n            }\n          }\n\n          array = new ArrayNode(params);\n        } else {\n          // 1 dimensional vector\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          array = row;\n        }\n      } else {\n        // this is an empty matrix \"[ ]\"\n        closeParams(state);\n        getToken(state);\n        array = new ArrayNode([]);\n      }\n\n      return parseAccessors(state, array);\n    }\n\n    return parseObject(state);\n  }\n  /**\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\n   * @return {ArrayNode} node\n   */\n\n\n  function parseRow(state) {\n    var params = [parseAssignment(state)];\n    var len = 1;\n\n    while (state.token === ',') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getToken(state); // parse expression\n\n      params[len] = parseAssignment(state);\n      len++;\n    }\n\n    return new ArrayNode(params);\n  }\n  /**\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseObject(state) {\n    if (state.token === '{') {\n      openParams(state);\n      var key;\n      var properties = {};\n\n      do {\n        getToken(state);\n\n        if (state.token !== '}') {\n          // parse key\n          if (state.token === '\"') {\n            key = parseDoubleQuotesStringToken(state);\n          } else if (state.token === '\\'') {\n            key = parseSingleQuotesStringToken(state);\n          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n            key = state.token;\n            getToken(state);\n          } else {\n            throw createSyntaxError(state, 'Symbol or string expected as object key');\n          } // parse key/value separator\n\n\n          if (state.token !== ':') {\n            throw createSyntaxError(state, 'Colon : expected after object key');\n          }\n\n          getToken(state); // parse key\n\n          properties[key] = parseAssignment(state);\n        }\n      } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition\n\n\n      if (state.token !== '}') {\n        throw createSyntaxError(state, 'Comma , or bracket } expected after object value');\n      }\n\n      closeParams(state);\n      getToken(state);\n      var node = new ObjectNode(properties); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseNumber(state);\n  }\n  /**\n   * parse a number\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseNumber(state) {\n    var numberStr;\n\n    if (state.tokenType === TOKENTYPE.NUMBER) {\n      // this is a number\n      numberStr = state.token;\n      getToken(state);\n      return new ConstantNode(numeric(numberStr, config.number));\n    }\n\n    return parseParentheses(state);\n  }\n  /**\n   * parentheses\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseParentheses(state) {\n    var node; // check if it is a parenthesized expression\n\n    if (state.token === '(') {\n      // parentheses (...)\n      openParams(state);\n      getToken(state);\n      node = parseAssignment(state); // start again\n\n      if (state.token !== ')') {\n        throw createSyntaxError(state, 'Parenthesis ) expected');\n      }\n\n      closeParams(state);\n      getToken(state);\n      node = new ParenthesisNode(node);\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseEnd(state);\n  }\n  /**\n   * Evaluated when the expression is not yet ended but expected to end\n   * @return {Node} res\n   * @private\n   */\n\n\n  function parseEnd(state) {\n    if (state.token === '') {\n      // syntax error or unexpected end of expression\n      throw createSyntaxError(state, 'Unexpected end of expression');\n    } else {\n      throw createSyntaxError(state, 'Value expected');\n    }\n  }\n  /**\n   * Shortcut for getting the current row value (one based)\n   * Returns the line of the currently handled expression\n   * @private\n   */\n\n  /* TODO: implement keeping track on the row number\n  function row () {\n    return null\n  }\n  */\n\n  /**\n   * Shortcut for getting the current col value (one based)\n   * Returns the column (position) where the last state.token starts\n   * @private\n   */\n\n\n  function col(state) {\n    return state.index - state.token.length + 1;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {SyntaxError} instantiated error\n   * @private\n   */\n\n\n  function createSyntaxError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error[\"char\"] = c;\n    return error;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {Error} instantiated error\n   * @private\n   */\n\n\n  function createError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error[\"char\"] = c;\n    return error;\n  }\n\n  return parse;\n});\nexports.createParse = createParse;\n};"],
"names":["shadow$provide","global","require","module","exports","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","defineProperty","value","createParse","_factory","_is","_collection","_object","factory","name","dependencies","_ref","parseMultiple","expressions","options","undefined","extraNodes","nodes","deepMap","elem","TypeError","parseStart","currentCharacter","state","expression","substr","index","next","nextCharacter","charAt","getToken","tokenType","TOKENTYPE","NULL","token","comment","parse","isWhitespace","nestingLevel","DELIMITER","c1","c2","c3","DELIMITERS","isDigitDot","NUMBER","_c","isHexDigit","isDigit","isDecimalMark","createSyntaxError","isAlpha","NAMED_DELIMITERS","SYMBOL","UNKNOWN","getTokenSkipNewline","conditionalLevel","blocks","node","parseAssignment","visible","push","BlockNode","ConstantNode","createError","parseConditional","isSymbolNode","AssignmentNode","SymbolNode","isAccessorNode","object","isFunctionNode","fn","valid","args","forEach","arg","FunctionAssignmentNode","parseLogicalXor","OperatorNode","prev","trueExpr","falseExpr","ConditionalNode","condition","parseLogicalAnd","parseBitwiseOr","parseBitwiseXor","parseBitwiseAnd","parseRelational","params","parseShift","conditionals","operators","cond","RelationalNode","map","c","parseConversion","parseRange","to","parseAddSubtract","RangeNode","parseMultiplyDivide","parseImplicitMultiplication","mod","last","parseRule2","isConstantNode","isOperatorNode","op","parseUnary","tokenStates","pop","not","CustomNode","CONSTANTS","NUMERIC_CONSTANTS","indexOf","numeric","parseAccessors","str","parseDoubleQuotesStringToken","parseSingleQuotesStringToken","row","parseRow","rows","cols","items","r","array","ArrayNode","properties","ObjectNode","numberStr","config","number","ParenthesisNode","types","FunctionNode","AccessorNode","IndexNode","dotNotation","JSON","len","message","error","SyntaxError","typed","string","ArrayMatrix","stringObject","and","xor","or","parse.isAlpha","cPrev","cNext","isValidLatinOrGreek","isValidMathSymbol","parse.isValidLatinOrGreek","test","parse.isValidMathSymbol","high","low","parse.isWhitespace","parse.isDecimalMark","parse.isDigitDot","parse.isDigit","parse.isHexDigit"]
}
