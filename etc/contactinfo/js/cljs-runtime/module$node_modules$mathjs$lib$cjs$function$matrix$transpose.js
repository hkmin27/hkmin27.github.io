shadow$provide.module$node_modules$mathjs$lib$cjs$function$matrix$transpose=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createTranspose=void 0;var _object=require("module$node_modules$mathjs$lib$cjs$utils$object"),_string=require("module$node_modules$mathjs$lib$cjs$utils$string");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");global=(0,global.factory)("transpose",["typed","matrix"],function(_ref){var typed=_ref.typed,matrix=
_ref.matrix;return typed("transpose",{Array:function(x){return this(matrix(x)).valueOf()},Matrix:function(x$jscomp$0){var size=x$jscomp$0.size();switch(size.length){case 1:var c=x$jscomp$0.clone();break;case 2:var rows=size[0],columns=size[1];if(0===columns)throw new RangeError("Cannot transpose a 2D matrix with no columns (size: "+(0,_string.format)(size)+")");switch(x$jscomp$0.storage()){case "dense":size=x$jscomp$0._data;c=[];for(var transposedRow,j=0;j<columns;j++){transposedRow=c[j]=[];for(var i=
0;i<rows;i++)transposedRow[i]=(0,_object.clone)(size[i][j])}c=x$jscomp$0.createDenseMatrix({data:c,size:[columns,rows],datatype:x$jscomp$0._datatype});break;case "sparse":size=x$jscomp$0._values;c=x$jscomp$0._index;transposedRow=x$jscomp$0._ptr;j=size?[]:void 0;i=[];for(var cptr=[],w=[],x=0;x<rows;x++)w[x]=0;var l;x=0;for(l=c.length;x<l;x++)w[c[x]]++;for(l=x=0;l<rows;l++)cptr.push(x),x+=w[l],w[l]=cptr[l];cptr.push(x);for(x=0;x<columns;x++){l=transposedRow[x+1];for(var k=transposedRow[x];k<l;k++){var q=
w[c[k]]++;i[q]=x;size&&(j[q]=(0,_object.clone)(size[k]))}}c=x$jscomp$0.createSparseMatrix({values:j,index:i,ptr:cptr,size:[columns,rows],datatype:x$jscomp$0._datatype})}break;default:throw new RangeError("Matrix must be a vector or two dimensional (size: "+(0,_string.format)(this._size)+")");}return c},any:function(x){return(0,_object.clone)(x)}})});exports.createTranspose=global}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$function$matrix$transpose.js.map
