shadow$provide.module$node_modules$mathjs$lib$cjs$function$matrix$inv=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createInv=void 0;var _is=require("module$node_modules$mathjs$lib$cjs$utils$is"),_array=require("module$node_modules$mathjs$lib$cjs$utils$array");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");var _string=require("module$node_modules$mathjs$lib$cjs$utils$string");require=(0,global.factory)("inv","typed matrix divideScalar addScalar multiply unaryMinus det identity abs".split(" "),
function(_ref){function _inv(mat,rows,cols){if(1===rows){rows=mat[0][0];if(0===rows)throw Error("Cannot calculate inverse, determinant is zero");return[[divideScalar(1,rows)]]}if(2===rows){rows=det(mat);if(0===rows)throw Error("Cannot calculate inverse, determinant is zero");return[[divideScalar(mat[1][1],rows),divideScalar(unaryMinus(mat[0][1]),rows)],[divideScalar(unaryMinus(mat[1][0]),rows),divideScalar(mat[0][0],rows)]]}var A=mat.concat();for(mat=0;mat<rows;mat++)A[mat]=A[mat].concat();for(var B=
identity(rows).valueOf(),c=0;c<cols;c++){var s=abs(A[c][c]);var f=c;for(mat=c+1;mat<rows;)abs(A[mat][c])>s&&(s=abs(A[mat][c]),f=mat),mat++;if(0===s)throw Error("Cannot calculate inverse, determinant is zero");mat=f;mat!==c&&(s=A[c],A[c]=A[mat],A[mat]=s,s=B[c],B[c]=B[mat],B[mat]=s);var Ac=A[c],Bc=B[c];for(mat=0;mat<rows;mat++){var Ar=A[mat],Br=B[mat];if(mat!==c){if(0!==Ar[c]){f=divideScalar(unaryMinus(Ar[c]),Ac[c]);for(s=c;s<cols;s++)Ar[s]=addScalar(Ar[s],multiply(f,Ac[s]));for(s=0;s<cols;s++)Br[s]=
addScalar(Br[s],multiply(f,Bc[s]))}}else{f=Ac[c];for(s=c;s<cols;s++)Ar[s]=divideScalar(Ar[s],f);for(s=0;s<cols;s++)Br[s]=divideScalar(Br[s],f)}}}return B}var typed=_ref.typed,matrix=_ref.matrix,divideScalar=_ref.divideScalar,addScalar=_ref.addScalar,multiply=_ref.multiply,unaryMinus=_ref.unaryMinus,det=_ref.det,identity=_ref.identity,abs=_ref.abs;return typed("inv",{"Array | Matrix":function(x){var size=(0,_is.isMatrix)(x)?x.size():(0,_array.arraySize)(x);switch(size.length){case 1:if(1===size[0])return(0,
_is.isMatrix)(x)?matrix([divideScalar(1,x.valueOf()[0])]):[divideScalar(1,x[0])];throw new RangeError("Matrix must be square (size: "+(0,_string.format)(size)+")");case 2:var rows=size[0],cols=size[1];if(rows===cols)return(0,_is.isMatrix)(x)?matrix(_inv(x.valueOf(),rows,cols),x.storage()):_inv(x,rows,cols);throw new RangeError("Matrix must be square (size: "+(0,_string.format)(size)+")");default:throw new RangeError("Matrix must be two dimensional (size: "+(0,_string.format)(size)+")");}},any:function(x){return divideScalar(1,
x)}})});exports.createInv=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$function$matrix$inv.js.map
