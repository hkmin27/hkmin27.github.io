{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$expression$transform$filter_transform.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/expression/transform/filter.transform.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$expression$transform$filter_transform\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createFilterTransform = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _function = require(\"../../utils/function.js\");\n\nvar _compileInlineExpression = require(\"./utils/compileInlineExpression.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'filter';\nvar dependencies = ['typed'];\nvar createFilterTransform = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed;\n\n  /**\n   * Attach a transform function to math.filter\n   * Adds a property transform containing the transform function.\n   *\n   * This transform adds support for equations as test function for math.filter,\n   * so you can do something like 'filter([3, -2, 5], x > 0)'.\n   */\n  function filterTransform(args, math, scope) {\n    var x, callback;\n\n    if (args[0]) {\n      x = args[0].compile().evaluate(scope);\n    }\n\n    if (args[1]) {\n      if ((0, _is.isSymbolNode)(args[1]) || (0, _is.isFunctionAssignmentNode)(args[1])) {\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\n        callback = args[1].compile().evaluate(scope);\n      } else {\n        // an expression like filter([3, -2, 5], x > 0)\n        callback = (0, _compileInlineExpression.compileInlineExpression)(args[1], math, scope);\n      }\n    }\n\n    return filter(x, callback);\n  }\n\n  filterTransform.rawArgs = true; // one based version of function filter\n\n  var filter = typed('filter', {\n    'Array, function': _filter,\n    'Matrix, function': function MatrixFunction(x, test) {\n      return x.create(_filter(x.toArray(), test));\n    },\n    'Array, RegExp': _array.filterRegExp,\n    'Matrix, RegExp': function MatrixRegExp(x, test) {\n      return x.create((0, _array.filterRegExp)(x.toArray(), test));\n    }\n  });\n  return filterTransform;\n}, {\n  isTransformFunction: true\n});\n/**\n * Filter values in a callback given a callback function\n *\n * !!! Passes a one-based index !!!\n *\n * @param {Array} x\n * @param {Function} callback\n * @return {Array} Returns the filtered array\n * @private\n */\n\nexports.createFilterTransform = createFilterTransform;\n\nfunction _filter(x, callback) {\n  // figure out what number of arguments the callback function expects\n  var args = (0, _function.maxArgumentCount)(callback);\n  return (0, _array.filter)(x, function (value, index, array) {\n    // invoke the callback function with the right number of arguments\n    if (args === 1) {\n      return callback(value);\n    } else if (args === 2) {\n      return callback(value, [index + 1]);\n    } else {\n      // 3 or -1\n      return callback(value, [index + 1], array);\n    }\n  });\n}\n};"],
"names":["shadow$provide","global","require","module","exports","_filter","x","callback","args","_function","maxArgumentCount","_array","filter","value","index","array","Object","defineProperty","createFilterTransform","_is","_compileInlineExpression","_factory","factory","name","dependencies","_ref","filterTransform","math","scope","compile","evaluate","isSymbolNode","isFunctionAssignmentNode","compileInlineExpression","typed","rawArgs","MatrixFunction","test","create","toArray","filterRegExp","MatrixRegExp","isTransformFunction"]
}
