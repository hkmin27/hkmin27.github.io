{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$expression$node$RangeNode.js",
"lineCount":10,
"mappings":"AAAAA,cAAA,CAAA,4DAAA,CAAiF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGzHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,eAAR,CAA0B,IAAK,EAE/B,KAAIC,IAAMP,OAAA,CAAQ,6CAAR,CAENQ,OAAAA,CAAWR,OAAA,CAAQ,kDAAR,CAEf,KAAIS,WAAaT,OAAA,CAAQ,yDAAR,CAIbM,QAAAA,CAAiC,CAAC,CAAA,CAAGE,MAASE,CAAAA,OAAb,EAF1BC,WAE0B,CADlBC,CAAC,MAADA,CACkB,CAA0C,QAAS,CAACC,IAAD,CAAO,CAW7FC,QAASA,UAAS,CAACC,KAAD;AAAQC,GAAR,CAAaC,IAAb,CAAmB,CACnC,GAAI,EAAE,IAAF,WAAkBH,UAAlB,CAAJ,CACE,KAAM,KAAII,WAAJ,CAAgB,kDAAhB,CAAN,CAIF,GAAI,CAAC,CAAC,CAAA,CAAGX,GAAIY,CAAAA,MAAR,EAAgBJ,KAAhB,CAAL,CAA6B,KAAM,KAAIK,SAAJ,CAAc,eAAd,CAAN,CAC7B,GAAI,CAAC,CAAC,CAAA,CAAGb,GAAIY,CAAAA,MAAR,EAAgBH,GAAhB,CAAL,CAA2B,KAAM,KAAII,SAAJ,CAAc,eAAd,CAAN,CAC3B,GAAIH,IAAJ,EAAY,CAAC,CAAC,CAAA,CAAGV,GAAIY,CAAAA,MAAR,EAAgBF,IAAhB,CAAb,CAAoC,KAAM,KAAIG,SAAJ,CAAc,eAAd,CAAN,CACpC,GAAuB,CAAvB,CAAIC,SAAUC,CAAAA,MAAd,CAA0B,KAAUC,MAAJ,CAAU,oBAAV,CAAN,CAC1B,IAAKR,CAAAA,KAAL,CAAaA,KAEb,KAAKC,CAAAA,GAAL,CAAWA,GAEX,KAAKC,CAAAA,IAAL,CAAYA,IAAZ,EAAoB,IAde,CA8GrCO,QAASA,8BAA6B,CAACC,IAAD,CAAOC,WAAP,CAAoB,CACxD,IAAIC,WAAa,CAAC,CAAA,CAAGlB,UAAWmB,CAAAA,aAAf,EAA8BH,IAA9B;AAAoCC,WAApC,CAAjB,CACIG,OAAS,EADb,CAEIC,gBAAkB,CAAC,CAAA,CAAGrB,UAAWmB,CAAAA,aAAf,EAA8BH,IAAKV,CAAAA,KAAnC,CAA0CW,WAA1C,CACtBG,OAAOd,CAAAA,KAAP,CAAmC,IAAnC,GAAee,eAAf,EAA2CA,eAA3C,EAA8DH,UAA9D,EAA4F,KAA5F,GAA4ED,WAExED,KAAKR,CAAAA,IAAT,GACMc,eACJ,CADqB,CAAC,CAAA,CAAGtB,UAAWmB,CAAAA,aAAf,EAA8BH,IAAKR,CAAAA,IAAnC,CAAyCS,WAAzC,CACrB,CAAAG,MAAOZ,CAAAA,IAAP,CAAiC,IAAjC,GAAcc,eAAd,EAAyCA,eAAzC,EAA2DJ,UAA3D,EAAyF,KAAzF,GAAyED,WAF3E,CAKIM,KAAAA,CAAgB,CAAC,CAAA,CAAGvB,UAAWmB,CAAAA,aAAf,EAA8BH,IAAKT,CAAAA,GAAnC,CAAwCU,WAAxC,CACpBG,OAAOb,CAAAA,GAAP,CAA+B,IAA/B,GAAagB,IAAb,EAAuCA,IAAvC,EAAwDL,UAAxD,EAAsF,KAAtF,GAAsED,WACtE,OAAOG,OAbiD,CA7F1Df,SAAUmB,CAAAA,SAAV,CAAsB,IA3BXpB,IAAKqB,CAAAA,IA4BhBpB;SAAUmB,CAAAA,SAAUE,CAAAA,IAApB,CAA2B,WAC3BrB,UAAUmB,CAAAA,SAAUG,CAAAA,WAApB,CAAkC,CAAA,CAOlCtB,UAAUmB,CAAAA,SAAUI,CAAAA,QAApB,CAA+BC,QAAS,EAAG,CAKzC,MAA2B,EAA3B,CAHiB,IAAKC,CAAAA,MAALC,CAAY,QAAS,CAACf,IAAD,CAAO,CAC3C,MAAO,CAAC,CAAA,CAAGlB,GAAIkC,CAAAA,YAAR,EAAsBhB,IAAtB,CAAP,EAAoD,KAApD,GAAsCA,IAAKd,CAAAA,IADA,CAA5B6B,CAGClB,CAAAA,MALuB,CAsB3CR,UAAUmB,CAAAA,SAAUS,CAAAA,QAApB,CAA+BC,QAAS,CAACC,IAAD,CAAOC,QAAP,CAAiB,CACvD,IAAIC,MAAQF,IAAKE,CAAAA,KAAjB,CAEIC,UAAY,IAAKhC,CAAAA,KAAM2B,CAAAA,QAAX,CAAoBE,IAApB,CAA0BC,QAA1B,CAFhB,CAIIG,QAAU,IAAKhC,CAAAA,GAAI0B,CAAAA,QAAT,CAAkBE,IAAlB,CAAwBC,QAAxB,CAEd,IAAI,IAAK5B,CAAAA,IAAT,CAAe,CACb,IAAIgC,SAAW,IAAKhC,CAAAA,IAAKyB,CAAAA,QAAV,CAAmBE,IAAnB,CAAyBC,QAAzB,CAEf,OAAOK,SAAsB,CAACC,KAAD,CAAQC,IAAR,CAAcC,OAAd,CAAuB,CAClD,MAAOP,MAAA,CAAMC,SAAA,CAAUI,KAAV,CAAiBC,IAAjB;AAAuBC,OAAvB,CAAN,CAAuCL,OAAA,CAAQG,KAAR,CAAeC,IAAf,CAAqBC,OAArB,CAAvC,CAAsEJ,QAAA,CAASE,KAAT,CAAgBC,IAAhB,CAAsBC,OAAtB,CAAtE,CAD2C,CAHvC,CAOb,MAAOH,SAAsB,CAACC,KAAD,CAAQC,IAAR,CAAcC,OAAd,CAAuB,CAClD,MAAOP,MAAA,CAAMC,SAAA,CAAUI,KAAV,CAAiBC,IAAjB,CAAuBC,OAAvB,CAAN,CAAuCL,OAAA,CAAQG,KAAR,CAAeC,IAAf,CAAqBC,OAArB,CAAvC,CAD2C,CAdC,CAyBzDvC,UAAUmB,CAAAA,SAAUqB,CAAAA,OAApB,CAA8BC,QAAS,CAACC,QAAD,CAAW,CAChDA,QAAA,CAAS,IAAKzC,CAAAA,KAAd,CAAqB,OAArB,CAA8B,IAA9B,CACAyC,SAAA,CAAS,IAAKxC,CAAAA,GAAd,CAAmB,KAAnB,CAA0B,IAA1B,CAEI,KAAKC,CAAAA,IAAT,EACEuC,QAAA,CAAS,IAAKvC,CAAAA,IAAd,CAAoB,MAApB,CAA4B,IAA5B,CAL8C,CAgBlDH,UAAUmB,CAAAA,SAAUwB,CAAAA,GAApB,CAA0BC,QAAS,CAACF,QAAD,CAAW,CAC5C,MAAO,KAAI1C,SAAJ,CAAc,IAAK6C,CAAAA,OAAL,CAAaH,QAAA,CAAS,IAAKzC,CAAAA,KAAd,CAAqB,OAArB,CAA8B,IAA9B,CAAb,CAAd,CAAiE,IAAK4C,CAAAA,OAAL,CAAaH,QAAA,CAAS,IAAKxC,CAAAA,GAAd,CAAmB,KAAnB,CAA0B,IAA1B,CAAb,CAAjE,CAAgH,IAAKC,CAAAA,IAArH,EAA6H,IAAK0C,CAAAA,OAAL,CAAaH,QAAA,CAAS,IAAKvC,CAAAA,IAAd;AAAoB,MAApB,CAA4B,IAA5B,CAAb,CAA7H,CADqC,CAS9CH,UAAUmB,CAAAA,SAAU2B,CAAAA,KAApB,CAA4BC,QAAS,EAAG,CACtC,MAAO,KAAI/C,SAAJ,CAAc,IAAKC,CAAAA,KAAnB,CAA0B,IAAKC,CAAAA,GAA/B,CAAoC,IAAKC,CAAAA,IAAzC,EAAiD,IAAKA,CAAAA,IAAtD,CAD+B,CAkCxCH,UAAUmB,CAAAA,SAAU6B,CAAAA,SAApB,CAAgCC,QAAS,CAACC,OAAD,CAAU,CAEjD,IAAInC,OAASL,6BAAA,CAA8B,IAA9B,CADKwC,OAAAtC,EAAWsC,OAAQtC,CAAAA,WAAnBA,CAAiCsC,OAAQtC,CAAAA,WAAzCA,CAAuD,MAC5D,CAGTX,KAAAA,IAAQ,IAAKA,CAAAA,KAAMkD,CAAAA,QAAX,CAAoBD,OAApB,CAERnC,OAAOd,CAAAA,KAAX,GACEA,GADF,CACU,GADV,CACgBA,GADhB,CACwB,GADxB,CAMA,IAAI,IAAKE,CAAAA,IAAT,CAAe,CACb,IAAIA,KAAO,IAAKA,CAAAA,IAAKgD,CAAAA,QAAV,CAAmBD,OAAnB,CAEPnC,OAAOZ,CAAAA,IAAX,GACEA,IADF,CACS,GADT,CACeA,IADf,CACsB,GADtB,CAIAiD,IAAA,EAAO,GAAP,CAAajD,IAPA,CAUXD,OAAAA,CAAM,IAAKA,CAAAA,GAAIiD,CAAAA,QAAT,CAAkBD,OAAlB,CAENnC,OAAOb,CAAAA,GAAX,GACEA,OADF,CACQ,GADR,CACcA,OADd;AACoB,GADpB,CAKA,OADAkD,IACA,EADO,GACP,CADalD,OACb,CA9BiD,CAsCnDF,UAAUmB,CAAAA,SAAUkC,CAAAA,MAApB,CAA6BC,QAAS,EAAG,CACvC,MAAO,CACLC,OAAQ,WADH,CAELtD,MAAO,IAAKA,CAAAA,KAFP,CAGLC,IAAK,IAAKA,CAAAA,GAHL,CAILC,KAAM,IAAKA,CAAAA,IAJN,CADgC,CAiBzCH,UAAUwD,CAAAA,QAAV,CAAqBC,QAAS,CAACC,IAAD,CAAO,CACnC,MAAO,KAAI1D,SAAJ,CAAc0D,IAAKzD,CAAAA,KAAnB,CAA0ByD,IAAKxD,CAAAA,GAA/B,CAAoCwD,IAAKvD,CAAAA,IAAzC,CAD4B,CAUrCH,UAAUmB,CAAAA,SAAUwC,CAAAA,MAApB,CAA6BC,QAAS,CAACV,OAAD,CAAU,CAE9C,IAAInC,OAASL,6BAAA,CAA8B,IAA9B,CADKwC,OAAAtC,EAAWsC,OAAQtC,CAAAA,WAAnBA,CAAiCsC,OAAQtC,CAAAA,WAAzCA,CAAuD,MAC5D,CAGTX,KAAAA,IAAQ,IAAKA,CAAAA,KAAM0D,CAAAA,MAAX,CAAkBT,OAAlB,CAERnC,OAAOd,CAAAA,KAAX,GACEA,GADF,CACU,+EADV;AAC6EA,GAD7E,CACqF,+EADrF,CAMA,IAAI,IAAKE,CAAAA,IAAT,CAAe,CACb,IAAIA,KAAO,IAAKA,CAAAA,IAAKwD,CAAAA,MAAV,CAAiBT,OAAjB,CAEPnC,OAAOZ,CAAAA,IAAX,GACEA,IADF,CACS,+EADT,CAC4EA,IAD5E,CACmF,+EADnF,CAIAiD,IAAA,EAAO,yEAAP,CAAoEjD,IAPvD,CAUXD,OAAAA,CAAM,IAAKA,CAAAA,GAAIyD,CAAAA,MAAT,CAAgBT,OAAhB,CAENnC,OAAOb,CAAAA,GAAX,GACEA,OADF,CACQ,+EADR;AAC2EA,OAD3E,CACiF,+EADjF,CAKA,OADAkD,IACA,EADO,yEACP,CADoElD,OACpE,CA9B8C,CAuChDF,UAAUmB,CAAAA,SAAU0C,CAAAA,MAApB,CAA6BC,QAAS,CAACZ,OAAD,CAAU,CAE9C,IAAInC,OAASL,6BAAA,CAA8B,IAA9B,CADKwC,OAAAtC,EAAWsC,OAAQtC,CAAAA,WAAnBA,CAAiCsC,OAAQtC,CAAAA,WAAzCA,CAAuD,MAC5D,CAAb,CACIwC,IAAM,IAAKnD,CAAAA,KAAM8D,CAAAA,KAAX,CAAiBb,OAAjB,CAENnC,OAAOd,CAAAA,KAAX,GACEmD,GADF,CACQ,SAAUY,CAAAA,MAAV,CAAiBZ,GAAjB,CAAsB,UAAtB,CADR,CAIA,IAAI,IAAKjD,CAAAA,IAAT,CAAe,CACb,IAAIA,KAAO,IAAKA,CAAAA,IAAK4D,CAAAA,KAAV,CAAgBb,OAAhB,CAEPnC,OAAOZ,CAAAA,IAAX,GACEA,IADF,CACS,SAAU6D,CAAAA,MAAV,CAAiB7D,IAAjB;AAAuB,UAAvB,CADT,CAIAiD,IAAA,EAAO,GAAP,CAAajD,IAPA,CAUXD,OAAAA,CAAM,IAAKA,CAAAA,GAAI6D,CAAAA,KAAT,CAAeb,OAAf,CAENnC,OAAOb,CAAAA,GAAX,GACEA,OADF,CACQ,SAAU8D,CAAAA,MAAV,CAAiB9D,OAAjB,CAAsB,UAAtB,CADR,CAKA,OADAkD,IACA,EADO,GACP,CADalD,OACb,CA1B8C,CA6BhD,OAAOF,UApRsF,CAA1D,CAqRlC,CACDiE,QAAS,CAAA,CADR,CAED5D,OAAQ,CAAA,CAFP,CArRkC,CAyRrCjB,QAAQI,CAAAA,eAAR,CAA0BA,OAzS+F;",
"sources":["node_modules/mathjs/lib/cjs/expression/node/RangeNode.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$expression$node$RangeNode\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRangeNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _operators = require(\"../operators.js\");\n\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nvar createRangeNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * @constructor RangeNode\n   * @extends {Node}\n   * create a range\n   * @param {Node} start  included lower-bound\n   * @param {Node} end    included upper-bound\n   * @param {Node} [step] optional step\n   */\n  function RangeNode(start, end, step) {\n    if (!(this instanceof RangeNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate inputs\n\n\n    if (!(0, _is.isNode)(start)) throw new TypeError('Node expected');\n    if (!(0, _is.isNode)(end)) throw new TypeError('Node expected');\n    if (step && !(0, _is.isNode)(step)) throw new TypeError('Node expected');\n    if (arguments.length > 3) throw new Error('Too many arguments');\n    this.start = start; // included lower-bound\n\n    this.end = end; // included upper-bound\n\n    this.step = step || null; // optional step\n  }\n\n  RangeNode.prototype = new Node();\n  RangeNode.prototype.type = 'RangeNode';\n  RangeNode.prototype.isRangeNode = true;\n  /**\n   * Check whether the RangeNode needs the `end` symbol to be defined.\n   * This end is the size of the Matrix in current dimension.\n   * @return {boolean}\n   */\n\n  RangeNode.prototype.needsEnd = function () {\n    // find all `end` symbols in this RangeNode\n    var endSymbols = this.filter(function (node) {\n      return (0, _is.isSymbolNode)(node) && node.name === 'end';\n    });\n    return endSymbols.length > 0;\n  };\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n\n  RangeNode.prototype._compile = function (math, argNames) {\n    var range = math.range;\n\n    var evalStart = this.start._compile(math, argNames);\n\n    var evalEnd = this.end._compile(math, argNames);\n\n    if (this.step) {\n      var evalStep = this.step._compile(math, argNames);\n\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n      };\n    } else {\n      return function evalRangeNode(scope, args, context) {\n        return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RangeNode.prototype.forEach = function (callback) {\n    callback(this.start, 'start', this);\n    callback(this.end, 'end', this);\n\n    if (this.step) {\n      callback(this.step, 'step', this);\n    }\n  };\n  /**\n   * Create a new RangeNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RangeNode} Returns a transformed copy of the node\n   */\n\n\n  RangeNode.prototype.map = function (callback) {\n    return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RangeNode}\n   */\n\n\n  RangeNode.prototype.clone = function () {\n    return new RangeNode(this.start, this.end, this.step && this.step);\n  };\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @return {Object} parentheses\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(node, parenthesis) {\n    var precedence = (0, _operators.getPrecedence)(node, parenthesis);\n    var parens = {};\n    var startPrecedence = (0, _operators.getPrecedence)(node.start, parenthesis);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n\n    if (node.step) {\n      var stepPrecedence = (0, _operators.getPrecedence)(node.step, parenthesis);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n\n    var endPrecedence = (0, _operators.getPrecedence)(node.end, parenthesis);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toString(options);\n\n    if (parens.start) {\n      start = '(' + start + ')';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toString(options);\n\n      if (parens.step) {\n        step = '(' + step + ')';\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toString(options);\n\n    if (parens.end) {\n      end = '(' + end + ')';\n    }\n\n    str += ':' + end;\n    return str;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RangeNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RangeNode',\n      start: this.start,\n      end: this.end,\n      step: this.step\n    };\n  };\n  /**\n   * Instantiate an RangeNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RangeNode}\n   */\n\n\n  RangeNode.fromJSON = function (json) {\n    return new RangeNode(json.start, json.end, json.step);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis); // format string as start:step:stop\n\n    var str;\n    var start = this.start.toHTML(options);\n\n    if (parens.start) {\n      start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str = start;\n\n    if (this.step) {\n      var step = this.step.toHTML(options);\n\n      if (parens.step) {\n        step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n    }\n\n    var end = this.end.toHTML(options);\n\n    if (parens.end) {\n      end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n    return str;\n  };\n  /**\n   * Get LaTeX representation\n   * @params {Object} options\n   * @return {string} str\n   */\n\n\n  RangeNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var parens = calculateNecessaryParentheses(this, parenthesis);\n    var str = this.start.toTex(options);\n\n    if (parens.start) {\n      str = \"\\\\left(\".concat(str, \"\\\\right)\");\n    }\n\n    if (this.step) {\n      var step = this.step.toTex(options);\n\n      if (parens.step) {\n        step = \"\\\\left(\".concat(step, \"\\\\right)\");\n      }\n\n      str += ':' + step;\n    }\n\n    var end = this.end.toTex(options);\n\n    if (parens.end) {\n      end = \"\\\\left(\".concat(end, \"\\\\right)\");\n    }\n\n    str += ':' + end;\n    return str;\n  };\n\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createRangeNode = createRangeNode;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","createRangeNode","_is","_factory","_operators","factory","name","dependencies","_ref","RangeNode","start","end","step","SyntaxError","isNode","TypeError","arguments","length","Error","calculateNecessaryParentheses","node","parenthesis","precedence","getPrecedence","parens","startPrecedence","stepPrecedence","endPrecedence","prototype","Node","type","isRangeNode","needsEnd","RangeNode.prototype.needsEnd","filter","endSymbols","isSymbolNode","_compile","RangeNode.prototype._compile","math","argNames","range","evalStart","evalEnd","evalStep","evalRangeNode","scope","args","context","forEach","RangeNode.prototype.forEach","callback","map","RangeNode.prototype.map","_ifNode","clone","RangeNode.prototype.clone","_toString","RangeNode.prototype._toString","options","toString","str","toJSON","RangeNode.prototype.toJSON","mathjs","fromJSON","RangeNode.fromJSON","json","toHTML","RangeNode.prototype.toHTML","_toTex","RangeNode.prototype._toTex","toTex","concat","isClass"]
}
