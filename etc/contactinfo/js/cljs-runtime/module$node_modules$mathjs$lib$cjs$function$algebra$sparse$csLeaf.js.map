{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csLeaf.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,iEAAA,CAAsF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG9HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,MAAR,CAkBAA,QAAe,CAACC,CAAD,CAAIC,CAAJ,CAAOC,CAAP,CAAUC,KAAV,CAAiBC,QAAjB,CAA2BC,QAA3B,CAAqCC,QAArC,CAA+C,CAM5D,GAAIN,CAAJ,EAASC,CAAT,EAAcC,CAAA,CAAEC,KAAF,CAAUF,CAAV,CAAd,EAA8BC,CAAA,CAAEE,QAAF,CAAaJ,CAAb,CAA9B,CACE,MAAO,EAITE,EAAA,CAAEE,QAAF,CAAaJ,CAAb,CAAA,CAAkBE,CAAA,CAAEC,KAAF,CAAUF,CAAV,CAEdM,MAAAA,CAAQL,CAAA,CAAEG,QAAF,CAAaL,CAAb,CACZE,EAAA,CAAEG,QAAF,CAAaL,CAAb,CAAA,CAAkBC,CAElB,IAAc,EAAd,GAAIM,KAAJ,CAEEC,CAAA,CAAQ,CAFV,KAIO,CAELA,CAAA,CAAQ,CAER,KAAKC,CAAL,CAASF,KAAT,CAAgBE,CAAhB,GAAsBP,CAAA,CAAEI,QAAF,CAAaG,CAAb,CAAtB,CAAuCA,CAAvC,CAA2CP,CAAA,CAAEI,QAAF,CAAaG,CAAb,CAA3C,EAIA,IAAKC,QAAL,CAASH,KAAT,CAAgBG,QAAhB,GAAsBD,CAAtB,CAAyBC,QAAzB,CAA6BC,KAA7B,CAEEA,KACA,CADUT,CAAA,CAAEI,QAAF,CAAaI,QAAb,CACV,CAAAR,CAAA,CAAEI,QAAF;AAAaI,QAAb,CAAA,CAAkBD,CAXf,CAeP,MAAO,CACLD,MAAOA,CADF,CAELC,EAAGA,CAFE,CAnCqD,CAxBgE;",
"sources":["node_modules/mathjs/lib/cjs/function/algebra/sparse/csLeaf.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csLeaf\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.csLeaf = csLeaf;\n\n/**\n * This function determines if j is a leaf of the ith row subtree.\n * Consider A(i,j), node j in ith row subtree and return lca(jprev,j)\n *\n * @param {Number}  i               The ith row subtree\n * @param {Number}  j               The node to test\n * @param {Array}   w               The workspace array\n * @param {Number}  first           The index offset within the workspace for the first array\n * @param {Number}  maxfirst        The index offset within the workspace for the maxfirst array\n * @param {Number}  prevleaf        The index offset within the workspace for the prevleaf array\n * @param {Number}  ancestor        The index offset within the workspace for the ancestor array\n *\n * @return {Object}\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nfunction csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {\n  var s, sparent; // our result\n\n  var jleaf = 0;\n  var q; // check j is a leaf\n\n  if (i <= j || w[first + j] <= w[maxfirst + i]) {\n    return -1;\n  } // update max first[j] seen so far\n\n\n  w[maxfirst + i] = w[first + j]; // jprev = previous leaf of ith subtree\n\n  var jprev = w[prevleaf + i];\n  w[prevleaf + i] = j; // check j is first or subsequent leaf\n\n  if (jprev === -1) {\n    // 1st leaf, q = root of ith subtree\n    jleaf = 1;\n    q = i;\n  } else {\n    // update jleaf\n    jleaf = 2; // q = least common ancester (jprev,j)\n\n    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) {\n      ;\n    }\n\n    for (s = jprev; s !== q; s = sparent) {\n      // path compression\n      sparent = w[ancestor + s];\n      w[ancestor + s] = q;\n    }\n  }\n\n  return {\n    jleaf: jleaf,\n    q: q\n  };\n}\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","csLeaf","i","j","w","first","maxfirst","prevleaf","ancestor","jprev","jleaf","q","s","sparent"]
}
