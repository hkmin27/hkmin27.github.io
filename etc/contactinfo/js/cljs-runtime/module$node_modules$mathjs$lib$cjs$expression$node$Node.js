shadow$provide.module$node_modules$mathjs$lib$cjs$expression$node$Node=function(global,require,module,exports){function _typeof(obj$jscomp$0){"@babel/helpers - typeof";_typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};return _typeof(obj$jscomp$0)}Object.defineProperty(exports,"__esModule",{value:!0});exports.createNode=void 0;
var _is=require("module$node_modules$mathjs$lib$cjs$utils$is"),_keywords=require("module$node_modules$mathjs$lib$cjs$expression$keywords"),_object=require("module$node_modules$mathjs$lib$cjs$utils$object");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");global=(0,global.factory)("Node",["mathWithTransform"],function(_ref){function Node(){if(!(this instanceof Node))throw new SyntaxError("Constructor must be called with the new operator");}var mathWithTransform=_ref.mathWithTransform;
Node.prototype.evaluate=function(scope){return this.compile().evaluate(scope)};Node.prototype.type="Node";Node.prototype.isNode=!0;Node.prototype.comment="";Node.prototype.compile=function(){var expr=this._compile(mathWithTransform,{}),args={};return{evaluate:function(scope){scope=scope||{};for(var symbol in scope)if((0,_object.hasOwnProperty)(scope,symbol)&&symbol in _keywords.keywords)throw Error('Scope contains an illegal symbol, "'+symbol+'" is a reserved keyword');return expr(scope,args,null)}}};
Node.prototype._compile=function(math,argNames){throw Error("Method _compile should be implemented by type "+this.type);};Node.prototype.forEach=function(callback){throw Error("Cannot run forEach on a Node interface");};Node.prototype.map=function(callback){throw Error("Cannot run map on a Node interface");};Node.prototype._ifNode=function(node){if(!(0,_is.isNode)(node))throw new TypeError("Callback function must return a Node");return node};Node.prototype.traverse=function(callback$jscomp$0){function _traverse(node,
callback){node.forEach(function(child,path,parent){callback(child,path,parent);_traverse(child,callback)})}callback$jscomp$0(this,null,null);_traverse(this,callback$jscomp$0)};Node.prototype.transform=function(callback){function _transform(child,path,parent){path=callback(child,path,parent);return path!==child?path:child.map(_transform)}return _transform(this,null,null)};Node.prototype.filter=function(callback){var nodes=[];this.traverse(function(node,path,parent){callback(node,path,parent)&&nodes.push(node)});
return nodes};Node.prototype.clone=function(){throw Error("Cannot clone a Node interface");};Node.prototype.cloneDeep=function(){return this.map(function(node){return node.cloneDeep()})};Node.prototype.equals=function(other){return other?(0,_object.deepStrictEqual)(this,other):!1};Node.prototype.toString=function(options){var customString=this._getCustomString(options);return"undefined"!==typeof customString?customString:this._toString(options)};Node.prototype.toJSON=function(){throw Error("Cannot serialize object: toJSON not implemented by "+
this.type);};Node.prototype.toHTML=function(options){var customString=this._getCustomString(options);return"undefined"!==typeof customString?customString:this.toHTML(options)};Node.prototype._toString=function(){throw Error("_toString not implemented for "+this.type);};Node.prototype.toTex=function(options){var customString=this._getCustomString(options);return"undefined"!==typeof customString?customString:this._toTex(options)};Node.prototype._toTex=function(options){throw Error("_toTex not implemented for "+
this.type);};Node.prototype._getCustomString=function(options){if(options&&"object"===_typeof(options))switch(_typeof(options.handler)){case "object":case "undefined":break;case "function":return options.handler(this,options);default:throw new TypeError("Object or function expected as callback");}};Node.prototype.getIdentifier=function(){return this.type};Node.prototype.getContent=function(){return this};return Node},{isClass:!0,isNode:!0});exports.createNode=global}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$expression$node$Node.js.map
