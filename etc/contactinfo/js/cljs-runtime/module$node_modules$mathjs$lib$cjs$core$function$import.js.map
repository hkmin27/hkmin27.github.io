{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$core$function$import.js",
"lineCount":13,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/core/function/import.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$core$function$import\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importFactory = importFactory;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _ArgumentsError = require(\"../../error/ArgumentsError.js\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction importFactory(typed, load, math, importedFactories) {\n  /**\n   * Import functions from an object or a module.\n   *\n   * This function is only available on a mathjs instance created using `create`.\n   *\n   * Syntax:\n   *\n   *    math.import(functions)\n   *    math.import(functions, options)\n   *\n   * Where:\n   *\n   * - `functions: Object`\n   *   An object with functions or factories to be imported.\n   * - `options: Object` An object with import options. Available options:\n   *   - `override: boolean`\n   *     If true, existing functions will be overwritten. False by default.\n   *   - `silent: boolean`\n   *     If true, the function will not throw errors on duplicates or invalid\n   *     types. False by default.\n   *   - `wrap: boolean`\n   *     If true, the functions will be wrapped in a wrapper function\n   *     which converts data types like Matrix to primitive data types like Array.\n   *     The wrapper is needed when extending math.js with libraries which do not\n   *     support these data type. False by default.\n   *\n   * Examples:\n   *\n   *    import { create, all } from 'mathjs'\n   *    import * as numbers from 'numbers'\n   *\n   *    // create a mathjs instance\n   *    const math = create(all)\n   *\n   *    // define new functions and variables\n   *    math.import({\n   *      myvalue: 42,\n   *      hello: function (name) {\n   *        return 'hello, ' + name + '!'\n   *      }\n   *    })\n   *\n   *    // use the imported function and variable\n   *    math.myvalue * 2               // 84\n   *    math.hello('user')             // 'hello, user!'\n   *\n   *    // import the npm module 'numbers'\n   *    // (must be installed first with `npm install numbers`)\n   *    math.import(numbers, {wrap: true})\n   *\n   *    math.fibonacci(7) // returns 13\n   *\n   * @param {Object | Array} functions  Object with functions to be imported.\n   * @param {Object} [options]          Import options.\n   */\n  function mathImport(functions, options) {\n    var num = arguments.length;\n\n    if (num !== 1 && num !== 2) {\n      throw new _ArgumentsError.ArgumentsError('import', num, 1, 2);\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    function flattenImports(flatValues, value, name) {\n      if (Array.isArray(value)) {\n        value.forEach(function (item) {\n          return flattenImports(flatValues, item);\n        });\n      } else if (_typeof(value) === 'object') {\n        for (var _name in value) {\n          if ((0, _object.hasOwnProperty)(value, _name)) {\n            flattenImports(flatValues, value[_name], _name);\n          }\n        }\n      } else if ((0, _factory.isFactory)(value) || name !== undefined) {\n        var flatName = (0, _factory.isFactory)(value) ? isTransformFunctionFactory(value) ? value.fn + '.transform' : // TODO: this is ugly\n        value.fn : name; // we allow importing the same function twice if it points to the same implementation\n\n        if ((0, _object.hasOwnProperty)(flatValues, flatName) && flatValues[flatName] !== value && !options.silent) {\n          throw new Error('Cannot import \"' + flatName + '\" twice');\n        }\n\n        flatValues[flatName] = value;\n      } else {\n        if (!options.silent) {\n          throw new TypeError('Factory, Object, or Array expected');\n        }\n      }\n    }\n\n    var flatValues = {};\n    flattenImports(flatValues, functions);\n\n    for (var name in flatValues) {\n      if ((0, _object.hasOwnProperty)(flatValues, name)) {\n        // console.log('import', name)\n        var value = flatValues[name];\n\n        if ((0, _factory.isFactory)(value)) {\n          // we ignore name here and enforce the name of the factory\n          // maybe at some point we do want to allow overriding it\n          // in that case we can implement an option overrideFactoryNames: true\n          _importFactory(value, options);\n        } else if (isSupportedType(value)) {\n          _import(name, value, options);\n        } else {\n          if (!options.silent) {\n            throw new TypeError('Factory, Object, or Array expected');\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Add a property to the math namespace\n   * @param {string} name\n   * @param {*} value\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n\n\n  function _import(name, value, options) {\n    // TODO: refactor this function, it's to complicated and contains duplicate code\n    if (options.wrap && typeof value === 'function') {\n      // create a wrapper around the function\n      value = _wrap(value);\n    } // turn a plain function with a typed-function signature into a typed-function\n\n\n    if (hasTypedFunctionSignature(value)) {\n      value = typed(name, _defineProperty({}, value.signature, value));\n    }\n\n    if (isTypedFunction(math[name]) && isTypedFunction(value)) {\n      if (options.override) {\n        // give the typed function the right name\n        value = typed(name, value.signatures);\n      } else {\n        // merge the existing and typed function\n        value = typed(math[name], value);\n      }\n\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (math[name] === undefined || options.override) {\n      math[name] = value;\n      delete importedFactories[name];\n\n      _importTransform(name, value);\n\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (!options.silent) {\n      throw new Error('Cannot import \"' + name + '\": already exists');\n    }\n  }\n\n  function _importTransform(name, value) {\n    if (value && typeof value.transform === 'function') {\n      math.expression.transform[name] = value.transform;\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value.transform;\n      }\n    } else {\n      // remove existing transform\n      delete math.expression.transform[name];\n\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value;\n      }\n    }\n  }\n\n  function _deleteTransform(name) {\n    delete math.expression.transform[name];\n\n    if (allowedInExpressions(name)) {\n      math.expression.mathWithTransform[name] = math[name];\n    } else {\n      delete math.expression.mathWithTransform[name];\n    }\n  }\n  /**\n   * Create a wrapper a round an function which converts the arguments\n   * to their primitive values (like convert a Matrix to Array)\n   * @param {Function} fn\n   * @return {Function} Returns the wrapped function\n   * @private\n   */\n\n\n  function _wrap(fn) {\n    var wrapper = function wrapper() {\n      var args = [];\n\n      for (var i = 0, len = arguments.length; i < len; i++) {\n        var arg = arguments[i];\n        args[i] = arg && arg.valueOf();\n      }\n\n      return fn.apply(math, args);\n    };\n\n    if (fn.transform) {\n      wrapper.transform = fn.transform;\n    }\n\n    return wrapper;\n  }\n  /**\n   * Import an instance of a factory into math.js\n   * @param {function(scope: object)} factory\n   * @param {Object} options  See import for a description of the options\n   * @param {string} [name=factory.name] Optional custom name\n   * @private\n   */\n\n\n  function _importFactory(factory, options) {\n    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : factory.fn;\n\n    if ((0, _array.contains)(name, '.')) {\n      throw new Error('Factory name should not contain a nested path. ' + 'Name: ' + JSON.stringify(name));\n    }\n\n    var namespace = isTransformFunctionFactory(factory) ? math.expression.transform : math;\n    var existingTransform = (name in math.expression.transform);\n    var existing = (0, _object.hasOwnProperty)(namespace, name) ? namespace[name] : undefined;\n\n    var resolver = function resolver() {\n      // collect all dependencies, handle finding both functions and classes and other special cases\n      var dependencies = {};\n      factory.dependencies.map(_factory.stripOptionalNotation).forEach(function (dependency) {\n        if ((0, _array.contains)(dependency, '.')) {\n          throw new Error('Factory dependency should not contain a nested path. ' + 'Name: ' + JSON.stringify(dependency));\n        }\n\n        if (dependency === 'math') {\n          dependencies.math = math;\n        } else if (dependency === 'mathWithTransform') {\n          dependencies.mathWithTransform = math.expression.mathWithTransform;\n        } else if (dependency === 'classes') {\n          // special case for json reviver\n          dependencies.classes = math;\n        } else {\n          dependencies[dependency] = math[dependency];\n        }\n      });\n      var instance = /* #__PURE__ */factory(dependencies);\n\n      if (instance && typeof instance.transform === 'function') {\n        throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n      }\n\n      if (existing === undefined || options.override) {\n        return instance;\n      }\n\n      if (isTypedFunction(existing) && isTypedFunction(instance)) {\n        // merge the existing and new typed function\n        return typed(existing, instance);\n      }\n\n      if (options.silent) {\n        // keep existing, ignore imported function\n        return existing;\n      } else {\n        throw new Error('Cannot import \"' + name + '\": already exists');\n      }\n    }; // TODO: add unit test with non-lazy factory\n\n\n    if (!factory.meta || factory.meta.lazy !== false) {\n      (0, _object.lazy)(namespace, name, resolver); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          (0, _object.lazy)(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } else {\n      namespace[name] = resolver(); // FIXME: remove the `if (existing &&` condition again. Can we make sure subset is loaded before subset.transform? (Name collision, and no dependencies between the two)\n\n      if (existing && existingTransform) {\n        _deleteTransform(name);\n      } else {\n        if (isTransformFunctionFactory(factory) || factoryAllowedInExpressions(factory)) {\n          (0, _object.lazy)(math.expression.mathWithTransform, name, function () {\n            return namespace[name];\n          });\n        }\n      }\n    } // TODO: improve factories, store a list with imports instead which can be re-played\n\n\n    importedFactories[name] = factory;\n    math.emit('import', name, resolver);\n  }\n  /**\n   * Check whether given object is a type which can be imported\n   * @param {Function | number | string | boolean | null | Unit | Complex} object\n   * @return {boolean}\n   * @private\n   */\n\n\n  function isSupportedType(object) {\n    return typeof object === 'function' || typeof object === 'number' || typeof object === 'string' || typeof object === 'boolean' || object === null || (0, _is.isUnit)(object) || (0, _is.isComplex)(object) || (0, _is.isBigNumber)(object) || (0, _is.isFraction)(object) || (0, _is.isMatrix)(object) || Array.isArray(object);\n  }\n  /**\n   * Test whether a given thing is a typed-function\n   * @param {*} fn\n   * @return {boolean} Returns true when `fn` is a typed-function\n   */\n\n\n  function isTypedFunction(fn) {\n    return typeof fn === 'function' && _typeof(fn.signatures) === 'object';\n  }\n\n  function hasTypedFunctionSignature(fn) {\n    return typeof fn === 'function' && typeof fn.signature === 'string';\n  }\n\n  function allowedInExpressions(name) {\n    return !(0, _object.hasOwnProperty)(unsafe, name);\n  }\n\n  function factoryAllowedInExpressions(factory) {\n    return factory.fn.indexOf('.') === -1 && // FIXME: make checking on path redundant, check on meta data instead\n    !(0, _object.hasOwnProperty)(unsafe, factory.fn) && (!factory.meta || !factory.meta.isClass);\n  }\n\n  function isTransformFunctionFactory(factory) {\n    return factory !== undefined && factory.meta !== undefined && factory.meta.isTransformFunction === true || false;\n  } // namespaces and functions not available in the parser for safety reasons\n\n\n  var unsafe = {\n    expression: true,\n    type: true,\n    docs: true,\n    error: true,\n    json: true,\n    chain: true // chain method not supported. Note that there is a unit chain too.\n\n  };\n  return mathImport;\n}\n};"],
"names":["shadow$provide","global","require","module","exports","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_typeof","Symbol","iterator","constructor","prototype","importFactory","typed","load","math","importedFactories","_import","name","options","wrap","_wrap","signature","isTypedFunction","override","signatures","_importTransform","emit","resolver","undefined","silent","Error","transform","expression","allowedInExpressions","mathWithTransform","_deleteTransform","fn","wrapper","args","i","len","arguments","length","arg","valueOf","apply","_importFactory","factory","_array","contains","JSON","stringify","namespace","isTransformFunctionFactory","existingTransform","existing","_object","hasOwnProperty","dependencies","map","_factory","stripOptionalNotation","forEach","dependency","classes","instance","meta","lazy","factoryAllowedInExpressions","isSupportedType","object","_is","isUnit","isComplex","isBigNumber","isFraction","isMatrix","Array","isArray","unsafe","indexOf","isClass","isTransformFunction","type","docs","error","json","chain","mathImport","functions","flattenImports","flatValues","item","_name","isFactory","flatName","TypeError","num","_ArgumentsError","ArgumentsError"]
}
