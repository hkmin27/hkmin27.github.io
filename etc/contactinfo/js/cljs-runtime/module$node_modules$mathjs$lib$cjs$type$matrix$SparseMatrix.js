shadow$provide.module$node_modules$mathjs$lib$cjs$type$matrix$SparseMatrix=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createSparseMatrixClass=void 0;var _is=require("module$node_modules$mathjs$lib$cjs$utils$is"),_number=require("module$node_modules$mathjs$lib$cjs$utils$number"),_string=require("module$node_modules$mathjs$lib$cjs$utils$string"),_object=require("module$node_modules$mathjs$lib$cjs$utils$object"),_array=require("module$node_modules$mathjs$lib$cjs$utils$array");
global=require("module$node_modules$mathjs$lib$cjs$utils$factory");var _DimensionError=require("module$node_modules$mathjs$lib$cjs$error$DimensionError");require=(0,global.factory)("SparseMatrix",["typed","equalScalar","Matrix"],function(_ref){function SparseMatrix(data,datatype){if(!(this instanceof SparseMatrix))throw new SyntaxError("Constructor must be called with the new operator");if(datatype&&!(0,_is.isString)(datatype))throw Error("Invalid datatype: "+datatype);if((0,_is.isMatrix)(data))"SparseMatrix"===
data.type?(this._values=data._values?(0,_object.clone)(data._values):void 0,this._index=(0,_object.clone)(data._index),this._ptr=(0,_object.clone)(data._ptr),this._size=(0,_object.clone)(data._size),this._datatype=datatype||data._datatype):_createFromArray(this,data.valueOf(),datatype||data._datatype);else if(data&&(0,_is.isArray)(data.index)&&(0,_is.isArray)(data.ptr)&&(0,_is.isArray)(data.size))this._values=data.values,this._index=data.index,this._ptr=data.ptr,this._size=data.size,this._datatype=
datatype||data.datatype;else if((0,_is.isArray)(data))_createFromArray(this,data,datatype);else{if(data)throw new TypeError("Unsupported type of data ("+(0,_is.typeOf)(data)+")");this._values=[];this._index=[];this._ptr=[0];this._size=[0,0];this._datatype=datatype}}function _createFromArray(matrix,data,datatype){matrix._values=[];matrix._index=[];matrix._ptr=[];matrix._datatype=datatype;var rows=data.length,columns=0,eq=equalScalar,zero=0;(0,_is.isString)(datatype)&&(eq=typed.find(equalScalar,[datatype,
datatype])||equalScalar,zero=typed.convert(0,datatype));if(0<rows){datatype=0;do{matrix._ptr.push(matrix._index.length);for(var i=0;i<rows;i++){var row=data[i];(0,_is.isArray)(row)?(0===datatype&&columns<row.length&&(columns=row.length),datatype<row.length&&(row=row[datatype],eq(row,zero)||(matrix._values.push(row),matrix._index.push(i)))):(0===datatype&&1>columns&&(columns=1),eq(row,zero)||(matrix._values.push(row),matrix._index.push(i)))}datatype++}while(datatype<columns)}matrix._ptr.push(matrix._index.length);
matrix._size=[rows,columns]}function _getsubset(matrix,idx){if(!(0,_is.isIndex)(idx))throw new TypeError("Invalid index");if(idx.isScalar())return matrix.get(idx.min());var size=idx.size();if(size.length!==matrix._size.length)throw new _DimensionError.DimensionError(size.length,matrix._size.length);var ii,k,kk,min=idx.min(),max=idx.max();var i$jscomp$0=0;for(ii=matrix._size.length;i$jscomp$0<ii;i$jscomp$0++)(0,_array.validateIndex)(min[i$jscomp$0],matrix._size[i$jscomp$0]),(0,_array.validateIndex)(max[i$jscomp$0],
matrix._size[i$jscomp$0]);var mvalues=matrix._values,mindex=matrix._index,mptr=matrix._ptr;ii=idx.dimension(0);idx=idx.dimension(1);var w=[],pv=[];ii.forEach(function(i,r){pv[i]=r[0];w[i]=!0});var values=mvalues?[]:void 0,index=[],ptr=[];idx.forEach(function(j){ptr.push(index.length);k=mptr[j];for(kk=mptr[j+1];k<kk;k++)i$jscomp$0=mindex[k],!0===w[i$jscomp$0]&&(index.push(pv[i$jscomp$0]),values&&values.push(mvalues[k]))});ptr.push(index.length);return new SparseMatrix({values:values,index:index,ptr:ptr,
size:size,datatype:matrix._datatype})}function _getValueIndex(i,top,bottom,index){if(0===bottom-top)return bottom;for(var r=top;r<bottom;r++)if(index[r]===i)return r;return top}function _insert(k,i,j,v,values,index,ptr){values.splice(k,0,v);index.splice(k,0,i);for(k=j+1;k<ptr.length;k++)ptr[k]++}function _resize(matrix,rows,columns,defaultValue){defaultValue=defaultValue||0;var eq=equalScalar,zero=0;(0,_is.isString)(matrix._datatype)&&(eq=typed.find(equalScalar,[matrix._datatype,matrix._datatype])||
equalScalar,zero=typed.convert(0,matrix._datatype),defaultValue=typed.convert(defaultValue,matrix._datatype));var ins=!eq(defaultValue,zero),r=matrix._size[0];eq=matrix._size[1];var j;if(columns>eq){for(j=eq;j<columns;j++)if(matrix._ptr[j]=matrix._values.length,ins)for(zero=0;zero<r;zero++)matrix._values.push(defaultValue),matrix._index.push(zero);matrix._ptr[columns]=matrix._values.length}else columns<eq&&(matrix._ptr.splice(columns+1,eq-columns),matrix._values.splice(matrix._ptr[columns],matrix._values.length),
matrix._index.splice(matrix._ptr[columns],matrix._index.length));eq=columns;if(rows>r){if(ins){var n=0;for(j=0;j<eq;j++){matrix._ptr[j]+=n;ins=matrix._ptr[j+1]+n;var p=0;for(zero=r;zero<rows;zero++,p++)matrix._values.splice(ins+p,0,defaultValue),matrix._index.splice(ins+p,0,zero),n++}matrix._ptr[eq]=matrix._values.length}}else if(rows<r){for(j=defaultValue=0;j<eq;j++)for(matrix._ptr[j]-=defaultValue,r=matrix._ptr[j+1]-defaultValue,ins=matrix._ptr[j];ins<r;ins++)zero=matrix._index[ins],zero>rows-1&&
(matrix._values.splice(ins,1),matrix._index.splice(ins,1),defaultValue++);matrix._ptr[j]=matrix._values.length}matrix._size[0]=rows;matrix._size[1]=columns;return matrix}function _map(matrix,minRow,maxRow,minColumn,maxColumn,callback,skipZeros){var values=[],index=[],ptr=[],eq=equalScalar,zero=0;(0,_is.isString)(matrix._datatype)&&(eq=typed.find(equalScalar,[matrix._datatype,matrix._datatype])||equalScalar,zero=typed.convert(0,matrix._datatype));for(var invoke=function(v,x,y){v=callback(v,x,y);eq(v,
zero)||(values.push(v),index.push(x))},j=minColumn;j<=maxColumn;j++){ptr.push(values.length);var k0=matrix._ptr[j],k1=matrix._ptr[j+1];if(skipZeros)for(var k=k0;k<k1;k++)k0=matrix._index[k],k0>=minRow&&k0<=maxRow&&invoke(matrix._values[k],k0-minRow,j-minColumn);else{for(k={};k0<k1;k0++)k[matrix._index[k0]]=matrix._values[k0];for(k1=minRow;k1<=maxRow;k1++)invoke(k1 in k?k[k1]:0,k1-minRow,j-minColumn)}}ptr.push(values.length);return new SparseMatrix({values:values,index:index,ptr:ptr,size:[maxRow-minRow+
1,maxColumn-minColumn+1]})}function _toArray(values,index,ptr,size,copy){var rows=size[0];size=size[1];var a=[],i,j;for(i=0;i<rows;i++)for(a[i]=[],j=0;j<size;j++)a[i][j]=0;for(j=0;j<size;j++){rows=ptr[j+1];for(var k=ptr[j];k<rows;k++)i=index[k],a[i][j]=values?copy?(0,_object.clone)(values[k]):values[k]:1}return a}var typed=_ref.typed,equalScalar=_ref.equalScalar;SparseMatrix.prototype=new _ref.Matrix;SparseMatrix.prototype.createSparseMatrix=function(data,datatype){return new SparseMatrix(data,datatype)};
SparseMatrix.prototype.type="SparseMatrix";SparseMatrix.prototype.isSparseMatrix=!0;SparseMatrix.prototype.getDataType=function(){return(0,_array.getArrayDataType)(this._values,_is.typeOf)};SparseMatrix.prototype.storage=function(){return"sparse"};SparseMatrix.prototype.datatype=function(){return this._datatype};SparseMatrix.prototype.create=function(data,datatype){return new SparseMatrix(data,datatype)};SparseMatrix.prototype.density=function(){var rows=this._size[0],columns=this._size[1];return 0!==
rows&&0!==columns?this._index.length/(rows*columns):0};SparseMatrix.prototype.subset=function(index,replacement,defaultValue){if(!this._values)throw Error("Cannot invoke subset on a Pattern only matrix");switch(arguments.length){case 1:return _getsubset(this,index);case 2:case 3:var submatrix=replacement;if(!index||!0!==index.isIndex)throw new TypeError("Invalid index");var iSize=index.size(),isScalar=index.isScalar();if((0,_is.isMatrix)(submatrix)){var sSize=submatrix.size();submatrix=submatrix.toArray()}else sSize=
(0,_array.arraySize)(submatrix);if(isScalar){if(0!==sSize.length)throw new TypeError("Scalar expected");this.set(index.min(),submatrix,defaultValue)}else{if(1!==iSize.length&&2!==iSize.length)throw new _DimensionError.DimensionError(iSize.length,this._size.length,"\x3c");if(sSize.length<iSize.length){for(var outer=isScalar=0;1===iSize[isScalar]&&1===sSize[isScalar];)isScalar++;for(;1===iSize[isScalar];)outer++,isScalar++;submatrix=(0,_array.unsqueeze)(submatrix,iSize.length,outer,sSize)}if(!(0,_object.deepStrictEqual)(iSize,
sSize))throw new _DimensionError.DimensionError(iSize,sSize,"\x3e");iSize=index.min()[0];isScalar=index.min()[1];outer=sSize[0];sSize=sSize[1];for(var x=0;x<outer;x++)for(var y=0;y<sSize;y++)this.set([x+iSize,y+isScalar],submatrix[x][y],defaultValue)}return this;default:throw new SyntaxError("Wrong number of arguments");}};SparseMatrix.prototype.get=function(index){if(!(0,_is.isArray)(index))throw new TypeError("Array expected");if(index.length!==this._size.length)throw new _DimensionError.DimensionError(index.length,
this._size.length);if(!this._values)throw Error("Cannot invoke get on a Pattern only matrix");var i=index[0];index=index[1];(0,_array.validateIndex)(i,this._size[0]);(0,_array.validateIndex)(index,this._size[1]);var k=_getValueIndex(i,this._ptr[index],this._ptr[index+1],this._index);return k<this._ptr[index+1]&&this._index[k]===i?this._values[k]:0};SparseMatrix.prototype.set=function(index,v,defaultValue){if(!(0,_is.isArray)(index))throw new TypeError("Array expected");if(index.length!==this._size.length)throw new _DimensionError.DimensionError(index.length,
this._size.length);if(!this._values)throw Error("Cannot invoke set on a Pattern only matrix");var i=index[0];index=index[1];var rows=this._size[0],columns=this._size[1],eq=equalScalar,zero=0;(0,_is.isString)(this._datatype)&&(eq=typed.find(equalScalar,[this._datatype,this._datatype])||equalScalar,zero=typed.convert(0,this._datatype));if(i>rows-1||index>columns-1)_resize(this,Math.max(i+1,rows),Math.max(index+1,columns),defaultValue),rows=this._size[0],columns=this._size[1];(0,_array.validateIndex)(i,
rows);(0,_array.validateIndex)(index,columns);defaultValue=_getValueIndex(i,this._ptr[index],this._ptr[index+1],this._index);if(defaultValue<this._ptr[index+1]&&this._index[defaultValue]===i)if(eq(v,zero))for(i=this._index,v=this._ptr,this._values.splice(defaultValue,1),i.splice(defaultValue,1),index+=1;index<v.length;index++)v[index]--;else this._values[defaultValue]=v;else _insert(defaultValue,i,index,v,this._values,this._index,this._ptr);return this};SparseMatrix.prototype.resize=function(size,
defaultValue,copy){if(!(0,_is.isCollection)(size))throw new TypeError("Array or Matrix expected");var sizeArray=size.valueOf().map(function(value){return Array.isArray(value)&&1===value.length?value[0]:value});if(2!==sizeArray.length)throw Error("Only two dimensions matrix are supported");sizeArray.forEach(function(value){if(!(0,_is.isNumber)(value)||!(0,_number.isInteger)(value)||0>value)throw new TypeError("Invalid size, must contain positive integers (size: "+(0,_string.format)(sizeArray)+")");
});size=copy?this.clone():this;return _resize(size,sizeArray[0],sizeArray[1],defaultValue)};SparseMatrix.prototype.reshape=function(sizes,copy){if(!(0,_is.isArray)(sizes))throw new TypeError("Array expected");if(2!==sizes.length)throw Error("Sparse matrices can only be reshaped in two dimensions");sizes.forEach(function(value){if(!(0,_is.isNumber)(value)||!(0,_number.isInteger)(value)||-2>=value||0===value)throw new TypeError("Invalid size, must contain positive integers or -1 (size: "+(0,_string.format)(sizes)+
")");});var currentLength=this._size[0]*this._size[1];sizes=(0,_array.processSizesWildcard)(sizes,currentLength);if(currentLength!==sizes[0]*sizes[1])throw Error("Reshaping sparse matrix will result in the wrong number of elements");copy=copy?this.clone():this;if(this._size[0]===sizes[0]&&this._size[1]===sizes[1])return copy;currentLength=[];for(var i=0;i<copy._ptr.length;i++)for(var j=0;j<copy._ptr[i+1]-copy._ptr[i];j++)currentLength.push(i);i=copy._values.slice();j=copy._index.slice();for(var _i=
0;_i<copy._index.length;_i++){var flat=j[_i]*copy._size[1]+currentLength[_i];currentLength[_i]=flat%sizes[1];j[_i]=Math.floor(flat/sizes[1])}copy._values.length=0;copy._index.length=0;copy._ptr.length=sizes[1]+1;copy._size=sizes.slice();for(_i=0;_i<copy._ptr.length;_i++)copy._ptr[_i]=0;for(_i=0;_i<i.length;_i++){flat=j[_i];var _j=currentLength[_i],v=i[_i],k=_getValueIndex(flat,copy._ptr[_j],copy._ptr[_j+1],copy._index);_insert(k,flat,_j,v,copy._values,copy._index,copy._ptr)}return copy};SparseMatrix.prototype.clone=
function(){return new SparseMatrix({values:this._values?(0,_object.clone)(this._values):void 0,index:(0,_object.clone)(this._index),ptr:(0,_object.clone)(this._ptr),size:(0,_object.clone)(this._size),datatype:this._datatype})};SparseMatrix.prototype.size=function(){return this._size.slice(0)};SparseMatrix.prototype.map=function(callback,skipZeros){if(!this._values)throw Error("Cannot invoke map on a Pattern only matrix");var me=this;return _map(this,0,this._size[0]-1,0,this._size[1]-1,function(v,
i,j){return callback(v,[i,j],me)},skipZeros)};SparseMatrix.prototype.forEach=function(callback,skipZeros){if(!this._values)throw Error("Cannot invoke forEach on a Pattern only matrix");for(var rows=this._size[0],columns=this._size[1],j=0;j<columns;j++){var k0=this._ptr[j],k1=this._ptr[j+1];if(skipZeros)for(var k=k0;k<k1;k++)callback(this._values[k],[this._index[k],j],this);else{for(k={};k0<k1;k0++)k[this._index[k0]]=this._values[k0];for(k1=0;k1<rows;k1++)callback(k1 in k?k[k1]:0,[k1,j],this)}}};SparseMatrix.prototype.toArray=
function(){return _toArray(this._values,this._index,this._ptr,this._size,!0)};SparseMatrix.prototype.valueOf=function(){return _toArray(this._values,this._index,this._ptr,this._size,!1)};SparseMatrix.prototype.format=function(options){var rows=this._size[0],columns=this._size[1],density=this.density();rows="Sparse Matrix ["+(0,_string.format)(rows,options)+" x "+(0,_string.format)(columns,options)+"] density: "+(0,_string.format)(density,options)+"\n";for(density=0;density<columns;density++)for(var k1=
this._ptr[density+1],k=this._ptr[density];k<k1;k++){var i=this._index[k];rows+="\n    ("+(0,_string.format)(i,options)+", "+(0,_string.format)(density,options)+") \x3d\x3d\x3e "+(this._values?(0,_string.format)(this._values[k],options):"X")}return rows};SparseMatrix.prototype.toString=function(){return(0,_string.format)(this.toArray())};SparseMatrix.prototype.toJSON=function(){return{mathjs:"SparseMatrix",values:this._values,index:this._index,ptr:this._ptr,size:this._size,datatype:this._datatype}};
SparseMatrix.prototype.diagonal=function(k){if(k){if((0,_is.isBigNumber)(k)&&(k=k.toNumber()),!(0,_is.isNumber)(k)||!(0,_number.isInteger)(k))throw new TypeError("The parameter k must be an integer number");}else k=0;var kSuper=0<k?k:0;k=0>k?-k:0;for(var columns=this._size[1],n=Math.min(this._size[0]-k,columns-kSuper),values=[],index=[],ptr=[0],j=kSuper;j<columns&&values.length<n;j++)for(var k1=this._ptr[j+1],x=this._ptr[j];x<k1;x++){var i=this._index[x];if(i===j-kSuper+k){values.push(this._values[x]);
index[values.length-1]=i-k;break}}ptr.push(values.length);return new SparseMatrix({values:values,index:index,ptr:ptr,size:[n,1]})};SparseMatrix.fromJSON=function(json){return new SparseMatrix(json)};SparseMatrix.diagonal=function(size,value,k,defaultValue,datatype){if(!(0,_is.isArray)(size))throw new TypeError("Array expected, size parameter");if(2!==size.length)throw Error("Only two dimensions matrix are supported");size=size.map(function(s){(0,_is.isBigNumber)(s)&&(s=s.toNumber());if(!(0,_is.isNumber)(s)||
!(0,_number.isInteger)(s)||1>s)throw Error("Size values must be positive integers");return s});if(k){if((0,_is.isBigNumber)(k)&&(k=k.toNumber()),!(0,_is.isNumber)(k)||!(0,_number.isInteger)(k))throw new TypeError("The parameter k must be an integer number");}else k=0;defaultValue=equalScalar;var zero=0;(0,_is.isString)(datatype)&&(defaultValue=typed.find(equalScalar,[datatype,datatype])||equalScalar,zero=typed.convert(0,datatype));datatype=0<k?k:0;k=0>k?-k:0;var rows=size[0];size=size[1];var n=Math.min(rows-
k,size-datatype);if((0,_is.isArray)(value)){if(value.length!==n)throw Error("Invalid value array length");var _value=function(i){return value[i]}}else if((0,_is.isMatrix)(value)){_value=value.size();if(1!==_value.length||_value[0]!==n)throw Error("Invalid matrix length");_value=function(i){return value.get([i])}}else _value=function(){return value};for(var values=[],index=[],ptr=[],j=0;j<size;j++){ptr.push(values.length);var i$jscomp$0=j-datatype;if(0<=i$jscomp$0&&i$jscomp$0<n){var v=_value(i$jscomp$0);
defaultValue(v,zero)||(index.push(i$jscomp$0+k),values.push(v))}}ptr.push(values.length);return new SparseMatrix({values:values,index:index,ptr:ptr,size:[rows,size]})};SparseMatrix.prototype.swapRows=function(i,j){if(!((0,_is.isNumber)(i)&&(0,_number.isInteger)(i)&&(0,_is.isNumber)(j)&&(0,_number.isInteger)(j)))throw Error("Row index must be positive integers");if(2!==this._size.length)throw Error("Only two dimensional matrix is supported");(0,_array.validateIndex)(i,this._size[0]);(0,_array.validateIndex)(j,
this._size[0]);SparseMatrix._swapRows(i,j,this._size[1],this._values,this._index,this._ptr);return this};SparseMatrix._forEachRow=function(j,values,index,ptr,callback){var k1=ptr[j+1];for(j=ptr[j];j<k1;j++)callback(index[j],values[j])};SparseMatrix._swapRows=function(x,y,columns,values,index,ptr){for(var j=0;j<columns;j++){var k0=ptr[j],k1=ptr[j+1],kx=_getValueIndex(x,k0,k1,index);k0=_getValueIndex(y,k0,k1,index);kx<k1&&k0<k1&&index[kx]===x&&index[k0]===y?values&&(k1=values[kx],values[kx]=values[k0],
values[k0]=k1):kx<k1&&index[kx]===x&&(k0>=k1||index[k0]!==y)?(k1=values?values[kx]:void 0,index.splice(k0,0,y),values&&values.splice(k0,0,k1),index.splice(k0<=kx?kx+1:kx,1),values&&values.splice(k0<=kx?kx+1:kx,1)):k0<k1&&index[k0]===y&&(kx>=k1||index[kx]!==x)&&(k1=values?values[k0]:void 0,index.splice(kx,0,x),values&&values.splice(kx,0,k1),index.splice(kx<=k0?k0+1:k0,1),values&&values.splice(kx<=k0?k0+1:k0,1))}};return SparseMatrix},{isClass:!0});exports.createSparseMatrixClass=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$type$matrix$SparseMatrix.js.map
