shadow$provide.module$node_modules$mathjs$lib$cjs$function$statistics$quantileSeq=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createQuantileSeq=void 0;var _is=require("module$node_modules$mathjs$lib$cjs$utils$is"),_number=require("module$node_modules$mathjs$lib$cjs$utils$number"),_array=require("module$node_modules$mathjs$lib$cjs$utils$array");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");global=(0,global.factory)("quantileSeq",
["typed","add","multiply","partitionSelect","compare"],function(_ref){function _quantileSeq(array,prob,sorted){array=(0,_array.flatten)(array);var len=array.length;if(0===len)throw Error("Cannot calculate quantile of an empty sequence");if((0,_is.isNumber)(prob)){len=prob*(len-1);prob=len%1;if(0===prob)return array=sorted?array[len]:partitionSelect(array,len),validate(array),array;len=Math.floor(len);if(sorted){sorted=array[len];var _right=array[len+1]}else{_right=partitionSelect(array,len+1);sorted=
array[len];for(var i=0;i<len;++i)0<compare(array[i],sorted)&&(sorted=array[i])}validate(sorted);validate(_right);return add(multiply(sorted,1-prob),multiply(_right,prob))}prob=prob.times(len-1);if(prob.isInteger())return prob=prob.toNumber(),array=sorted?array[prob]:partitionSelect(array,prob),validate(array),array;len=prob.floor();prob=prob.minus(len);len=len.toNumber();if(sorted)sorted=array[len],_right=array[len+1];else for(_right=partitionSelect(array,len+1),sorted=array[len],i=0;i<len;++i)0<
compare(array[i],sorted)&&(sorted=array[i]);validate(sorted);validate(_right);array=new prob.constructor(1);return add(multiply(sorted,array.minus(prob)),multiply(_right,prob))}var typed=_ref.typed,add=_ref.add,multiply=_ref.multiply,partitionSelect=_ref.partitionSelect,compare=_ref.compare,validate=typed({"number | BigNumber | Unit":function(x){return x}});return function(data,probOrN,sorted){var one;if(2>arguments.length||3<arguments.length)throw new SyntaxError("Function quantileSeq requires two or three parameters");
if((0,_is.isCollection)(data)&&(sorted=sorted||!1,"boolean"===typeof sorted)){var dataArr=data.valueOf();if((0,_is.isNumber)(probOrN)){if(0>probOrN)throw Error("N/prob must be non-negative");if(1>=probOrN)return _quantileSeq(dataArr,probOrN,sorted);if(1<probOrN){if(!(0,_number.isInteger)(probOrN))throw Error("N must be a positive integer");var nPlusOne=probOrN+1;var probArr=Array(probOrN);for(one=0;one<probOrN;)probArr[one]=_quantileSeq(dataArr,++one/nPlusOne,sorted);return probArr}}if((0,_is.isBigNumber)(probOrN)){nPlusOne=
probOrN.constructor;if(probOrN.isNegative())throw Error("N/prob must be non-negative");one=new nPlusOne(1);if(probOrN.lte(one))return new nPlusOne(_quantileSeq(dataArr,probOrN,sorted));if(probOrN.gt(one)){if(!probOrN.isInteger())throw Error("N must be a positive integer");one=probOrN.toNumber();if(4294967295<one)throw Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");var _nPlusOne=new nPlusOne(one+1);probArr=Array(one);for(var _i=0;_i<one;)probArr[_i]=new nPlusOne(_quantileSeq(dataArr,
(new nPlusOne(++_i)).div(_nPlusOne),sorted));return probArr}}if(Array.isArray(probOrN)){probArr=Array(probOrN.length);for(nPlusOne=0;nPlusOne<probArr.length;++nPlusOne){_nPlusOne=probOrN[nPlusOne];if((0,_is.isNumber)(_nPlusOne)){if(0>_nPlusOne||1<_nPlusOne)throw Error("Probability must be between 0 and 1, inclusive");}else if((0,_is.isBigNumber)(_nPlusOne)){if(one=new _nPlusOne.constructor(1),_nPlusOne.isNegative()||_nPlusOne.gt(one))throw Error("Probability must be between 0 and 1, inclusive");}else throw new TypeError("Unexpected type of argument in function quantileSeq");
probArr[nPlusOne]=_quantileSeq(dataArr,_nPlusOne,sorted)}return probArr}}throw new TypeError("Unexpected type of argument in function quantileSeq");}});exports.createQuantileSeq=global}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$function$statistics$quantileSeq.js.map
