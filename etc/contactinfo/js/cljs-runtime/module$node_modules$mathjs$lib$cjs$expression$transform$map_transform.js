shadow$provide.module$node_modules$mathjs$lib$cjs$expression$transform$map_transform=function(global,require,module,exports){function _map(array,callback,orig){function recurse(value,index){return Array.isArray(value)?(0,_array.map)(value,function(child,i){return recurse(child,index.concat(i+1))}):1===argsCount?callback(value):2===argsCount?callback(value,index):callback(value,index,orig)}var argsCount=(0,_function.maxArgumentCount)(callback);return recurse(array,[])}Object.defineProperty(exports,
"__esModule",{value:!0});exports.createMapTransform=void 0;var _is=require("module$node_modules$mathjs$lib$cjs$utils$is"),_function=require("module$node_modules$mathjs$lib$cjs$utils$function"),_array=require("module$node_modules$mathjs$lib$cjs$utils$array");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");var _compileInlineExpression=require("module$node_modules$mathjs$lib$cjs$expression$transform$utils$compileInlineExpression");require=(0,global.factory)("map",["typed"],function(_ref){function mapTransform(args,
math,scope){var x,callback;args[0]&&(x=args[0].compile().evaluate(scope));args[1]&&(callback=(0,_is.isSymbolNode)(args[1])||(0,_is.isFunctionAssignmentNode)(args[1])?args[1].compile().evaluate(scope):(0,_compileInlineExpression.compileInlineExpression)(args[1],math,scope));return map(x,callback)}_ref=_ref.typed;mapTransform.rawArgs=!0;var map=_ref("map",{"Array, function":function(x,callback){return _map(x,callback,x)},"Matrix, function":function(x,callback){return x.create(_map(x.valueOf(),callback,
x))}});return mapTransform},{isTransformFunction:!0});exports.createMapTransform=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$expression$transform$map_transform.js.map
