{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$expression$node$SymbolNode.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/expression/node/SymbolNode.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$expression$node$SymbolNode\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSymbolNode = void 0;\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _customs = require(\"../../utils/customs.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _latex = require(\"../../utils/latex.js\");\n\nvar name = 'SymbolNode';\nvar dependencies = ['math', '?Unit', 'Node'];\nvar createSymbolNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var math = _ref.math,\n      Unit = _ref.Unit,\n      Node = _ref.Node;\n\n  /**\n   * Check whether some name is a valueless unit like \"inch\".\n   * @param {string} name\n   * @return {boolean}\n   */\n  function isValuelessUnit(name) {\n    return Unit ? Unit.isValuelessUnit(name) : false;\n  }\n  /**\n   * @constructor SymbolNode\n   * @extends {Node}\n   * A symbol node can hold and resolve a symbol\n   * @param {string} name\n   * @extends {Node}\n   */\n\n\n  function SymbolNode(name) {\n    if (!(this instanceof SymbolNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    this.name = name;\n  }\n\n  SymbolNode.prototype = new Node();\n  SymbolNode.prototype.type = 'SymbolNode';\n  SymbolNode.prototype.isSymbolNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  SymbolNode.prototype._compile = function (math, argNames) {\n    var name = this.name;\n\n    if (argNames[name] === true) {\n      // this is a FunctionAssignment argument\n      // (like an x when inside the expression of a function assignment `f(x) = ...`)\n      return function (scope, args, context) {\n        return args[name];\n      };\n    } else if (name in math) {\n      return function (scope, args, context) {\n        return name in scope ? (0, _customs.getSafeProperty)(scope, name) : (0, _customs.getSafeProperty)(math, name);\n      };\n    } else {\n      var isUnit = isValuelessUnit(name);\n      return function (scope, args, context) {\n        return name in scope ? (0, _customs.getSafeProperty)(scope, name) : isUnit ? new Unit(null, name) : SymbolNode.onUndefinedSymbol(name);\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  SymbolNode.prototype.forEach = function (callback) {// nothing to do, we don't have childs\n  };\n  /**\n   * Create a new SymbolNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node) : Node} callback\n   * @returns {SymbolNode} Returns a clone of the node\n   */\n\n\n  SymbolNode.prototype.map = function (callback) {\n    return this.clone();\n  };\n  /**\n   * Throws an error 'Undefined symbol {name}'\n   * @param {string} name\n   */\n\n\n  SymbolNode.onUndefinedSymbol = function (name) {\n    throw new Error('Undefined symbol ' + name);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {SymbolNode}\n   */\n\n\n  SymbolNode.prototype.clone = function () {\n    return new SymbolNode(this.name);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toString = function (options) {\n    return this.name;\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype.toHTML = function (options) {\n    var name = (0, _string.escape)(this.name);\n\n    if (name === 'true' || name === 'false') {\n      return '<span class=\"math-symbol math-boolean\">' + name + '</span>';\n    } else if (name === 'i') {\n      return '<span class=\"math-symbol math-imaginary-symbol\">' + name + '</span>';\n    } else if (name === 'Infinity') {\n      return '<span class=\"math-symbol math-infinity-symbol\">' + name + '</span>';\n    } else if (name === 'NaN') {\n      return '<span class=\"math-symbol math-nan-symbol\">' + name + '</span>';\n    } else if (name === 'null') {\n      return '<span class=\"math-symbol math-null-symbol\">' + name + '</span>';\n    } else if (name === 'undefined') {\n      return '<span class=\"math-symbol math-undefined-symbol\">' + name + '</span>';\n    }\n\n    return '<span class=\"math-symbol\">' + name + '</span>';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  SymbolNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'SymbolNode',\n      name: this.name\n    };\n  };\n  /**\n   * Instantiate a SymbolNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"SymbolNode\", name: \"x\"}`,\n   *                       where mathjs is optional\n   * @returns {SymbolNode}\n   */\n\n\n  SymbolNode.fromJSON = function (json) {\n    return new SymbolNode(json.name);\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  SymbolNode.prototype._toTex = function (options) {\n    var isUnit = false;\n\n    if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {\n      isUnit = true;\n    }\n\n    var symbol = (0, _latex.toSymbol)(this.name, isUnit);\n\n    if (symbol[0] === '\\\\') {\n      // no space needed if the symbol starts with '\\'\n      return symbol;\n    } // the space prevents symbols from breaking stuff like '\\cdot' if it's written right before the symbol\n\n\n    return ' ' + symbol;\n  };\n\n  return SymbolNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createSymbolNode = createSymbolNode;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","createSymbolNode","_string","_customs","_factory","_latex","factory","name","dependencies","_ref","SymbolNode","SyntaxError","TypeError","math","Unit","prototype","Node","type","isSymbolNode","_compile","SymbolNode.prototype._compile","argNames","scope","args","context","getSafeProperty","isUnit","isValuelessUnit","onUndefinedSymbol","forEach","SymbolNode.prototype.forEach","callback","map","SymbolNode.prototype.map","clone","SymbolNode.onUndefinedSymbol","Error","SymbolNode.prototype.clone","_toString","SymbolNode.prototype._toString","options","toHTML","SymbolNode.prototype.toHTML","escape","toJSON","SymbolNode.prototype.toJSON","mathjs","fromJSON","SymbolNode.fromJSON","json","_toTex","SymbolNode.prototype._toTex","symbol","toSymbol","isClass","isNode"]
}
