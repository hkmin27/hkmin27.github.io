shadow$provide.module$node_modules$mathjs$lib$cjs$expression$node$AccessorNode=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createAccessorNode=void 0;var _is=require("module$node_modules$mathjs$lib$cjs$utils$is"),_customs=require("module$node_modules$mathjs$lib$cjs$utils$customs");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");var _access=require("module$node_modules$mathjs$lib$cjs$expression$node$utils$access");require=
(0,global.factory)("AccessorNode",["subset","Node"],function(_ref){function AccessorNode(object,index){if(!(this instanceof AccessorNode))throw new SyntaxError("Constructor must be called with the new operator");if(!(0,_is.isNode)(object))throw new TypeError('Node expected for parameter "object"');if(!(0,_is.isIndexNode)(index))throw new TypeError('IndexNode expected for parameter "index"');this.object=object||null;this.index=index;Object.defineProperty(this,"name",{get:function(){return this.index?
this.index.isObjectProperty()?this.index.getObjectProperty():"":this.object.name||""}.bind(this),set:function(){throw Error("Cannot assign a new name, name is read-only");}})}function needParenthesis(node){return!((0,_is.isAccessorNode)(node)||(0,_is.isArrayNode)(node)||(0,_is.isConstantNode)(node)||(0,_is.isFunctionNode)(node)||(0,_is.isObjectNode)(node)||(0,_is.isParenthesisNode)(node)||(0,_is.isSymbolNode)(node))}var subset=_ref.subset;_ref=_ref.Node;var access=(0,_access.accessFactory)({subset:subset});
AccessorNode.prototype=new _ref;AccessorNode.prototype.type="AccessorNode";AccessorNode.prototype.isAccessorNode=!0;AccessorNode.prototype._compile=function(math,argNames){var evalObject=this.object._compile(math,argNames),evalIndex=this.index._compile(math,argNames);if(this.index.isObjectProperty()){var prop=this.index.getObjectProperty();return function(scope,args,context){return(0,_customs.getSafeProperty)(evalObject(scope,args,context),prop)}}return function(scope,args,context){context=evalObject(scope,
args,context);scope=evalIndex(scope,args,context);return access(context,scope)}};AccessorNode.prototype.forEach=function(callback){callback(this.object,"object",this);callback(this.index,"index",this)};AccessorNode.prototype.map=function(callback){return new AccessorNode(this._ifNode(callback(this.object,"object",this)),this._ifNode(callback(this.index,"index",this)))};AccessorNode.prototype.clone=function(){return new AccessorNode(this.object,this.index)};AccessorNode.prototype._toString=function(options){var object=
this.object.toString(options);needParenthesis(this.object)&&(object="("+object+")");return object+this.index.toString(options)};AccessorNode.prototype.toHTML=function(options){var object=this.object.toHTML(options);needParenthesis(this.object)&&(object='\x3cspan class\x3d"math-parenthesis math-round-parenthesis"\x3e(\x3c/span\x3e'+object+'\x3cspan class\x3d"math-parenthesis math-round-parenthesis"\x3e)\x3c/span\x3e');return object+this.index.toHTML(options)};AccessorNode.prototype._toTex=function(options){var object=
this.object.toTex(options);needParenthesis(this.object)&&(object="\\left(' + object + '\\right)");return object+this.index.toTex(options)};AccessorNode.prototype.toJSON=function(){return{mathjs:"AccessorNode",object:this.object,index:this.index}};AccessorNode.fromJSON=function(json){return new AccessorNode(json.object,json.index)};return AccessorNode},{isClass:!0,isNode:!0});exports.createAccessorNode=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$expression$node$AccessorNode.js.map
