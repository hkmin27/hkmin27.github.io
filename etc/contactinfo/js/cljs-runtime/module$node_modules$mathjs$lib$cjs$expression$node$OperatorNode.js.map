{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$expression$node$OperatorNode.js",
"lineCount":24,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/expression/node/OperatorNode.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$expression$node$OperatorNode\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createOperatorNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _string = require(\"../../utils/string.js\");\n\nvar _customs = require(\"../../utils/customs.js\");\n\nvar _operators = require(\"../operators.js\");\n\nvar _latex = require(\"../../utils/latex.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'OperatorNode';\nvar dependencies = ['Node'];\nvar createOperatorNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * @constructor OperatorNode\n   * @extends {Node}\n   * An operator with two arguments, like 2+3\n   *\n   * @param {string} op           Operator name, for example '+'\n   * @param {string} fn           Function name, for example 'add'\n   * @param {Node[]} args         Operator arguments\n   * @param {boolean} [implicit]  Is this an implicit multiplication?\n   */\n  function OperatorNode(op, fn, args, implicit) {\n    if (!(this instanceof OperatorNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof op !== 'string') {\n      throw new TypeError('string expected for parameter \"op\"');\n    }\n\n    if (typeof fn !== 'string') {\n      throw new TypeError('string expected for parameter \"fn\"');\n    }\n\n    if (!Array.isArray(args) || !args.every(_is.isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n    }\n\n    this.implicit = implicit === true;\n    this.op = op;\n    this.fn = fn;\n    this.args = args || [];\n  }\n\n  OperatorNode.prototype = new Node();\n  OperatorNode.prototype.type = 'OperatorNode';\n  OperatorNode.prototype.isOperatorNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  OperatorNode.prototype._compile = function (math, argNames) {\n    // validate fn\n    if (typeof this.fn !== 'string' || !(0, _customs.isSafeMethod)(math, this.fn)) {\n      if (!math[this.fn]) {\n        throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n      } else {\n        throw new Error('No access to function \"' + this.fn + '\"');\n      }\n    }\n\n    var fn = (0, _customs.getSafeProperty)(math, this.fn);\n    var evalArgs = (0, _array.map)(this.args, function (arg) {\n      return arg._compile(math, argNames);\n    });\n\n    if (evalArgs.length === 1) {\n      var evalArg0 = evalArgs[0];\n      return function evalOperatorNode(scope, args, context) {\n        return fn(evalArg0(scope, args, context));\n      };\n    } else if (evalArgs.length === 2) {\n      var _evalArg = evalArgs[0];\n      var evalArg1 = evalArgs[1];\n      return function evalOperatorNode(scope, args, context) {\n        return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n      };\n    } else {\n      return function evalOperatorNode(scope, args, context) {\n        return fn.apply(null, (0, _array.map)(evalArgs, function (evalArg) {\n          return evalArg(scope, args, context);\n        }));\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  OperatorNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.args.length; i++) {\n      callback(this.args[i], 'args[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new OperatorNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {OperatorNode} Returns a transformed copy of the node\n   */\n\n\n  OperatorNode.prototype.map = function (callback) {\n    var args = [];\n\n    for (var i = 0; i < this.args.length; i++) {\n      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n    }\n\n    return new OperatorNode(this.op, this.fn, args, this.implicit);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {OperatorNode}\n   */\n\n\n  OperatorNode.prototype.clone = function () {\n    return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit);\n  };\n  /**\n   * Check whether this is an unary OperatorNode:\n   * has exactly one argument, like `-a`.\n   * @return {boolean} Returns true when an unary operator node, false otherwise.\n   */\n\n\n  OperatorNode.prototype.isUnary = function () {\n    return this.args.length === 1;\n  };\n  /**\n   * Check whether this is a binary OperatorNode:\n   * has exactly two arguments, like `a + b`.\n   * @return {boolean} Returns true when a binary operator node, false otherwise.\n   */\n\n\n  OperatorNode.prototype.isBinary = function () {\n    return this.args.length === 2;\n  };\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = (0, _operators.getPrecedence)(root, parenthesis);\n    var associativity = (0, _operators.getAssociativity)(root, parenthesis);\n\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      return args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n\n          default:\n            return true;\n        }\n      });\n    }\n\n    var result;\n\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n\n      case 1:\n        // unary operators\n        {\n          // precedence of the operand\n          var operandPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis); // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n          if (latex && operandPrecedence !== null) {\n            var operandIdentifier;\n            var rootIdentifier;\n\n            if (parenthesis === 'keep') {\n              operandIdentifier = args[0].getIdentifier();\n              rootIdentifier = root.getIdentifier();\n            } else {\n              // Ignore Parenthesis Nodes when not in 'keep' mode\n              operandIdentifier = args[0].getContent().getIdentifier();\n              rootIdentifier = root.getContent().getIdentifier();\n            }\n\n            if (_operators.properties[precedence][rootIdentifier].latexLeftParens === false) {\n              result = [false];\n              break;\n            }\n\n            if (_operators.properties[operandPrecedence][operandIdentifier].latexParens === false) {\n              result = [false];\n              break;\n            }\n          }\n\n          if (operandPrecedence === null) {\n            // if the operand has no defined precedence, no parens are needed\n            result = [false];\n            break;\n          }\n\n          if (operandPrecedence <= precedence) {\n            // if the operands precedence is lower, parens are needed\n            result = [true];\n            break;\n          } // otherwise, no parens needed\n\n\n          result = [false];\n        }\n        break;\n\n      case 2:\n        // binary operators\n        {\n          var lhsParens; // left hand side needs parenthesis?\n          // precedence of the left hand side\n\n          var lhsPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis); // is the root node associative with the left hand side\n\n          var assocWithLhs = (0, _operators.isAssociativeWith)(root, args[0], parenthesis);\n\n          if (lhsPrecedence === null) {\n            // if the left hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            lhsParens = false;\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n            // In case of equal precedence, if the root node is left associative\n            // parens are **never** necessary for the left hand side.\n            // If it is right associative however, parens are necessary\n            // if the root node isn't associative with the left hand side\n            lhsParens = true;\n          } else if (lhsPrecedence < precedence) {\n            lhsParens = true;\n          } else {\n            lhsParens = false;\n          }\n\n          var rhsParens; // right hand side needs parenthesis?\n          // precedence of the right hand side\n\n          var rhsPrecedence = (0, _operators.getPrecedence)(args[1], parenthesis); // is the root node associative with the right hand side?\n\n          var assocWithRhs = (0, _operators.isAssociativeWith)(root, args[1], parenthesis);\n\n          if (rhsPrecedence === null) {\n            // if the right hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            rhsParens = false;\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n            // In case of equal precedence, if the root node is right associative\n            // parens are **never** necessary for the right hand side.\n            // If it is left associative however, parens are necessary\n            // if the root node isn't associative with the right hand side\n            rhsParens = true;\n          } else if (rhsPrecedence < precedence) {\n            rhsParens = true;\n          } else {\n            rhsParens = false;\n          } // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n\n          if (latex) {\n            var _rootIdentifier;\n\n            var lhsIdentifier;\n            var rhsIdentifier;\n\n            if (parenthesis === 'keep') {\n              _rootIdentifier = root.getIdentifier();\n              lhsIdentifier = root.args[0].getIdentifier();\n              rhsIdentifier = root.args[1].getIdentifier();\n            } else {\n              // Ignore ParenthesisNodes when not in 'keep' mode\n              _rootIdentifier = root.getContent().getIdentifier();\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\n            }\n\n            if (lhsPrecedence !== null) {\n              if (_operators.properties[precedence][_rootIdentifier].latexLeftParens === false) {\n                lhsParens = false;\n              }\n\n              if (_operators.properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n                lhsParens = false;\n              }\n            }\n\n            if (rhsPrecedence !== null) {\n              if (_operators.properties[precedence][_rootIdentifier].latexRightParens === false) {\n                rhsParens = false;\n              }\n\n              if (_operators.properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n                rhsParens = false;\n              }\n            }\n          }\n\n          result = [lhsParens, rhsParens];\n        }\n        break;\n\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = (0, _operators.getPrecedence)(arg, parenthesis);\n            var assocWithArg = (0, _operators.isAssociativeWith)(root, arg, parenthesis);\n            var argAssociativity = (0, _operators.getAssociativity)(arg, parenthesis);\n\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n\n            return false;\n          });\n        }\n\n        break;\n    } // handles an edge case of 'auto' parentheses with implicit multiplication of ConstantNode\n    // In that case print parentheses for ParenthesisNodes even though they normally wouldn't be\n    // printed.\n\n\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis === 'auto' && implicit === 'hide') {\n      result = args.map(function (arg, index) {\n        var isParenthesisNode = arg.getIdentifier() === 'ParenthesisNode';\n\n        if (result[index] || isParenthesisNode) {\n          // put in parenthesis?\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    return result;\n  }\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n      var operand = args[0].toString(options);\n\n      if (parens[0]) {\n        operand = '(' + operand + ')';\n      } // for example for \"not\", we want a space between operand and argument\n\n\n      var opIsNamed = /[a-zA-Z]+/.test(this.op);\n\n      if (assoc === 'right') {\n        // prefix operator\n        return this.op + (opIsNamed ? ' ' : '') + operand;\n      } else if (assoc === 'left') {\n        // postfix\n        return operand + (opIsNamed ? ' ' : '') + this.op;\n      } // fall back to postfix\n\n\n      return operand + this.op;\n    } else if (args.length === 2) {\n      var lhs = args[0].toString(options); // left hand side\n\n      var rhs = args[1].toString(options); // right hand side\n\n      if (parens[0]) {\n        // left hand side in parenthesis?\n        lhs = '(' + lhs + ')';\n      }\n\n      if (parens[1]) {\n        // right hand side in parenthesis?\n        rhs = '(' + rhs + ')';\n      }\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return lhs + ' ' + rhs;\n      }\n\n      return lhs + ' ' + this.op + ' ' + rhs;\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toString(options);\n\n        if (parens[index]) {\n          // put in parenthesis?\n          arg = '(' + arg + ')';\n        }\n\n        return arg;\n      });\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return stringifiedArgs.join(' ');\n      }\n\n      return stringifiedArgs.join(' ' + this.op + ' ');\n    } else {\n      // fallback to formatting as a function call\n      return this.fn + '(' + this.args.join(', ') + ')';\n    }\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  OperatorNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'OperatorNode',\n      op: this.op,\n      fn: this.fn,\n      args: this.args,\n      implicit: this.implicit\n    };\n  };\n  /**\n   * Instantiate an OperatorNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"OperatorNode\", \"op\": \"+\", \"fn\": \"add\", \"args\": [...], \"implicit\": false}`,\n   *                       where mathjs is optional\n   * @returns {OperatorNode}\n   */\n\n\n  OperatorNode.fromJSON = function (json) {\n    return new OperatorNode(json.op, json.fn, json.args, json.implicit);\n  };\n  /**\n   * Get HTML representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n      var operand = args[0].toHTML(options);\n\n      if (parens[0]) {\n        operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (assoc === 'right') {\n        // prefix operator\n        return '<span class=\"math-operator math-unary-operator math-lefthand-unary-operator\">' + (0, _string.escape)(this.op) + '</span>' + operand;\n      } else {\n        // postfix when assoc === 'left' or undefined\n        return operand + '<span class=\"math-operator math-unary-operator math-righthand-unary-operator\">' + (0, _string.escape)(this.op) + '</span>';\n      }\n    } else if (args.length === 2) {\n      // binary operatoes\n      var lhs = args[0].toHTML(options); // left hand side\n\n      var rhs = args[1].toHTML(options); // right hand side\n\n      if (parens[0]) {\n        // left hand side in parenthesis?\n        lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (parens[1]) {\n        // right hand side in parenthesis?\n        rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n        return lhs + '<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>' + rhs;\n      }\n\n      return lhs + '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + (0, _string.escape)(this.op) + '</span>' + rhs;\n    } else {\n      var stringifiedArgs = args.map(function (arg, index) {\n        arg = arg.toHTML(options);\n\n        if (parens[index]) {\n          // put in parenthesis?\n          arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        return arg;\n      });\n\n      if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-implicit-binary-operator\"></span>');\n        }\n\n        return stringifiedArgs.join('<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + (0, _string.escape)(this.op) + '</span>');\n      } else {\n        // fallback to formatting as a function call\n        return '<span class=\"math-function\">' + (0, _string.escape)(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n      }\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  OperatorNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var implicit = options && options.implicit ? options.implicit : 'hide';\n    var args = this.args;\n    var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n    var op = _latex.latexOperators[this.fn];\n    op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n    if (args.length === 1) {\n      // unary operators\n      var assoc = (0, _operators.getAssociativity)(this, parenthesis);\n      var operand = args[0].toTex(options);\n\n      if (parens[0]) {\n        operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n      }\n\n      if (assoc === 'right') {\n        // prefix operator\n        return op + operand;\n      } else if (assoc === 'left') {\n        // postfix operator\n        return operand + op;\n      } // fall back to postfix\n\n\n      return operand + op;\n    } else if (args.length === 2) {\n      // binary operators\n      var lhs = args[0]; // left hand side\n\n      var lhsTex = lhs.toTex(options);\n\n      if (parens[0]) {\n        lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n      }\n\n      var rhs = args[1]; // right hand side\n\n      var rhsTex = rhs.toTex(options);\n\n      if (parens[1]) {\n        rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n      } // handle some exceptions (due to the way LaTeX works)\n\n\n      var lhsIdentifier;\n\n      if (parenthesis === 'keep') {\n        lhsIdentifier = lhs.getIdentifier();\n      } else {\n        // Ignore ParenthesisNodes if in 'keep' mode\n        lhsIdentifier = lhs.getContent().getIdentifier();\n      }\n\n      switch (this.getIdentifier()) {\n        case 'OperatorNode:divide':\n          // op contains '\\\\frac' at this point\n          return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n\n        case 'OperatorNode:pow':\n          lhsTex = '{' + lhsTex + '}';\n          rhsTex = '{' + rhsTex + '}';\n\n          switch (lhsIdentifier) {\n            case 'ConditionalNode': //\n\n            case 'OperatorNode:divide':\n              lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n          }\n\n          break;\n\n        case 'OperatorNode:multiply':\n          if (this.implicit && implicit === 'hide') {\n            return lhsTex + '~' + rhsTex;\n          }\n\n      }\n\n      return lhsTex + op + rhsTex;\n    } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n      var texifiedArgs = args.map(function (arg, index) {\n        arg = arg.toTex(options);\n\n        if (parens[index]) {\n          arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n        }\n\n        return arg;\n      });\n\n      if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit) {\n        return texifiedArgs.join('~');\n      }\n\n      return texifiedArgs.join(op);\n    } else {\n      // fall back to formatting as a function call\n      // as this is a fallback, it doesn't use\n      // fancy function names\n      return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n        return arg.toTex(options);\n      }).join(',') + '\\\\right)';\n    }\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  OperatorNode.prototype.getIdentifier = function () {\n    return this.type + ':' + this.fn;\n  };\n\n  return OperatorNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createOperatorNode = createOperatorNode;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","createOperatorNode","_is","_array","_string","_customs","_operators","_latex","_factory","factory","name","dependencies","_ref","OperatorNode","op","fn","args","implicit","SyntaxError","TypeError","Array","isArray","every","isNode","calculateNecessaryParentheses","root","parenthesis","latex","precedence","getPrecedence","associativity","getAssociativity","length","getIdentifier","map","arg","getContent","type","result","operandPrecedence","operandIdentifier","rootIdentifier","properties","latexLeftParens","latexParens","lhsPrecedence","assocWithLhs","isAssociativeWith","lhsParens","rhsPrecedence","assocWithRhs","rhsParens","_rootIdentifier","lhsIdentifier","rhsIdentifier","latexRightParens","argPrecedence","assocWithArg","argAssociativity","index","isParenthesisNode","prototype","Node","isOperatorNode","_compile","OperatorNode.prototype._compile","math","argNames","isSafeMethod","Error","getSafeProperty","evalArgs","evalArg0","evalOperatorNode","scope","context","_evalArg","evalArg1","apply","evalArg","forEach","OperatorNode.prototype.forEach","callback","i","OperatorNode.prototype.map","_ifNode","clone","OperatorNode.prototype.clone","slice","isUnary","OperatorNode.prototype.isUnary","isBinary","OperatorNode.prototype.isBinary","_toString","OperatorNode.prototype._toString","options","parens","assoc","operand","toString","opIsNamed","test","lhs","rhs","stringifiedArgs","join","toJSON","OperatorNode.prototype.toJSON","mathjs","fromJSON","OperatorNode.fromJSON","json","toHTML","OperatorNode.prototype.toHTML","escape","_toTex","OperatorNode.prototype._toTex","latexOperators","toTex","concat","lhsTex","rhsTex","texifiedArgs","OperatorNode.prototype.getIdentifier","isClass"]
}
