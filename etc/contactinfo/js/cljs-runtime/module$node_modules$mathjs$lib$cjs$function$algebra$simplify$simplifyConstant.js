shadow$provide.module$node_modules$mathjs$lib$cjs$function$algebra$simplify$simplifyConstant=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createSimplifyConstant=void 0;var _is=require("module$node_modules$mathjs$lib$cjs$utils$is");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");var _util=require("module$node_modules$mathjs$lib$cjs$function$algebra$simplify$util"),_noop=require("module$node_modules$mathjs$lib$cjs$utils$noop");
require=(0,global.factory)("simplifyConstant","typed config mathWithTransform ?fraction ?bignumber ConstantNode OperatorNode FunctionNode SymbolNode".split(" "),function(_ref){function _eval(fnname,args,options){try{return _toNumber(mathWithTransform[fnname].apply(null,args),options)}catch(ignore){return args=args.map(function(x){return(0,_is.isFraction)(x)?x.valueOf():x}),_toNumber(mathWithTransform[fnname].apply(null,args),options)}}function _exactFraction(n,options){if(options&&!1!==options.exactFractions&&
isFinite(n)&&fraction){var f=fraction(n);options=options&&"number"===typeof options.fractionsLimit?options.fractionsLimit:Infinity;if(f.valueOf()===n&&f.n<options&&f.d<options)return f}return n}function foldOp(fn,args,makeNode,options){return args.reduce(function(a,b){if((0,_is.isNode)(a)||(0,_is.isNode)(b))(0,_is.isNode)(a)?(0,_is.isNode)(b)||(b=_toNode(b)):a=_toNode(a);else{try{return _eval(fn,[a,b],options)}catch(ignoreandcontinue){}a=_toNode(a);b=_toNode(b)}return makeNode([a,b])})}function foldFraction(node,
options){switch(node.type){case "SymbolNode":return node;case "ConstantNode":return"number"!==typeof node.value&&isNaN(node.value)?node:_toNumber(node.value,options);case "FunctionNode":if(mathWithTransform[node.name]&&mathWithTransform[node.name].rawArgs)return node;if(-1===["add","multiply"].indexOf(node.name)){var args=node.args.map(function(arg){return foldFraction(arg,options)});if(!args.some(_is.isNode))try{return _eval(node.name,args,options)}catch(ignoreandcontine){}args=args.map(function(arg){return(0,
_is.isNode)(arg)?arg:_toNode(arg)});return new FunctionNode(node.name,args)}case "OperatorNode":args=node.fn.toString();var makeNode=createMakeNodeFunction(node);if((0,_is.isOperatorNode)(node)&&node.isUnary()){var _args=[foldFraction(node.args[0],options)];_args=(0,_is.isNode)(_args[0])?makeNode(_args):_eval(args,_args,options)}else if(isAssociative(node))if(_args=allChildren(node),_args=_args.map(function(arg){return foldFraction(arg,options)}),isCommutative(args)){var consts=[];node=[];for(var i=
0;i<_args.length;i++)(0,_is.isNode)(_args[i])?node.push(_args[i]):consts.push(_args[i]);1<consts.length?(_args=foldOp(args,consts,makeNode,options),node.unshift(_args),_args=foldOp(args,node,makeNode,options)):_args=foldOp(args,_args,makeNode,options)}else _args=foldOp(args,_args,makeNode,options);else _args=node.args.map(function(arg){return foldFraction(arg,options)}),_args=foldOp(args,_args,makeNode,options);return _args;case "ParenthesisNode":return foldFraction(node.content,options);default:throw Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
}}var typed=_ref.typed,config=_ref.config,mathWithTransform=_ref.mathWithTransform,fraction=_ref.fraction,bignumber=_ref.bignumber,ConstantNode=_ref.ConstantNode,OperatorNode=_ref.OperatorNode,FunctionNode=_ref.FunctionNode;_ref=_ref.SymbolNode;_ref=(0,_util.createUtil)({FunctionNode:FunctionNode,OperatorNode:OperatorNode,SymbolNode:_ref});var isCommutative=_ref.isCommutative,isAssociative=_ref.isAssociative,allChildren=_ref.allChildren,createMakeNodeFunction=_ref.createMakeNodeFunction,_toNode=typed({Fraction:function(f){var n=
f.s*f.n;n=0>n?new OperatorNode("-","unaryMinus",[new ConstantNode(-n)]):new ConstantNode(n);return 1===f.d?n:new OperatorNode("/","divide",[n,new ConstantNode(f.d)])},number:function(n){return 0>n?new OperatorNode("-","unaryMinus",[new ConstantNode(-n)]):new ConstantNode(n)},BigNumber:function(n){return 0>n?new OperatorNode("-","unaryMinus",[new ConstantNode(-n)]):new ConstantNode(n)},Complex:function(s){throw Error("Cannot convert Complex number to Node");}}),_toNumber=typed({"string, Object":function(s,
options){if("BigNumber"===config.number)return void 0===bignumber&&(0,_noop.noBignumber)(),bignumber(s);if("Fraction"===config.number)return void 0===fraction&&(0,_noop.noFraction)(),fraction(s);s=parseFloat(s);return _exactFraction(s,options)},"Fraction, Object":function(s,options){return s},"BigNumber, Object":function(s,options){return s},"number, Object":function(s,options){return _exactFraction(s,options)},"Complex, Object":function(s,options){return 0!==s.im?s:_exactFraction(s.re,options)}});
return function(expr,options){expr=foldFraction(expr,options);return(0,_is.isNode)(expr)?expr:_toNode(expr)}});exports.createSimplifyConstant=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$function$algebra$simplify$simplifyConstant.js.map
