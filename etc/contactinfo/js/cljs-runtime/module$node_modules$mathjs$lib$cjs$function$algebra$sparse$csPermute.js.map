{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csPermute.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,oEAAA,CAAyF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGjIC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,SAAR,CAcAA,QAAkB,CAACC,CAAD,CAAIC,IAAJ,CAAUC,CAAV,CAAaC,MAAb,CAAqB,CAErC,IAAIC,QAAUJ,CAAEK,CAAAA,OAAhB,CACIC,OAASN,CAAEO,CAAAA,MADf,CAEIC,KAAOR,CAAES,CAAAA,IAFb,CAGIC,MAAQV,CAAEW,CAAAA,KAHd,CAIIC,IAAMZ,CAAEa,CAAAA,SAJZ,CAMIC,EAAIJ,KAAA,CAAM,CAAN,CACJK,MAAAA,CAAIL,KAAA,CAAM,CAAN,CAEJM,OAAAA,CAAUb,MAAA,EAAUH,CAAEK,CAAAA,OAAZ,CAAsB,EAAtB,CAA2B,IAQzC,KAPA,IAAIY,OAAS,EAAb,CAEIC,KAAO,EAFX,CAKIC,GAAK,CALT,CAOSC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBL,KAApB,CAAuBK,CAAA,EAAvB,CAA4B,CAE1BF,IAAA,CAAKE,CAAL,CAAA,CAAUD,EAEV,KAAIE,EAAInB,CAAA,CAAIA,CAAA,CAAEkB,CAAF,CAAJ,CAAWA,CAAnB,CAEuBE,GAAKd,IAAA,CAAKa,CAAL,CAAS,CAAT,CAA5B,KAAyCE,CAAzC,CAAcf,IAAAgB,CAAKH,CAALG,CAAd,CAAiDD,CAAjD,CAAqDD,EAArD,CAAyDC,CAAA,EAAzD,CAIEN,MAAA,CAAOE,EAAP,CAOA,CATQlB,IAAAwB,CAAOxB,IAAA,CAAKK,MAAA,CAAOiB,CAAP,CAAL,CAAPE;AAAyBnB,MAAA,CAAOiB,CAAP,CASjC,CALIP,MAKJ,GAJEA,MAAA,CAAQG,EAAR,CAIF,CAJgBf,OAAA,CAAQmB,CAAR,CAIhB,EAAAJ,EAAA,EAjBwB,CAsB5BD,IAAA,CAAKH,KAAL,CAAA,CAAUI,EAEV,OAAOnB,EAAE0B,CAAAA,kBAAF,CAAqB,CAC1BvB,OAAQa,MADkB,CAE1BW,MAAOV,MAFmB,CAG1BW,IAAKV,IAHqB,CAI1BW,KAAM,CAACf,CAAD,CAAIC,KAAJ,CAJoB,CAK1Be,SAAUlB,GALgB,CAArB,CA3C8B,CApB0F;",
"sources":["node_modules/mathjs/lib/cjs/function/algebra/sparse/csPermute.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csPermute\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.csPermute = csPermute;\n\n/**\n * Permutes a sparse matrix C = P * A * Q\n *\n * @param {SparseMatrix}  a         The Matrix A\n * @param {Array}   pinv            The row permutation vector\n * @param {Array}   q               The column permutation vector\n * @param {boolean} values          Create a pattern matrix (false), values and pattern otherwise\n *\n * @return {Matrix}                 C = P * A * Q, null on error\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nfunction csPermute(a, pinv, q, values) {\n  // a arrays\n  var avalues = a._values;\n  var aindex = a._index;\n  var aptr = a._ptr;\n  var asize = a._size;\n  var adt = a._datatype; // rows & columns\n\n  var m = asize[0];\n  var n = asize[1]; // c arrays\n\n  var cvalues = values && a._values ? [] : null;\n  var cindex = []; // (aptr[n])\n\n  var cptr = []; // (n + 1)\n  // initialize vars\n\n  var nz = 0; // loop columns\n\n  for (var k = 0; k < n; k++) {\n    // column k of C is column q[k] of A\n    cptr[k] = nz; // apply column permutation\n\n    var j = q ? q[k] : k; // loop values in column j of A\n\n    for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {\n      // row i of A is row pinv[i] of C\n      var r = pinv ? pinv[aindex[t]] : aindex[t]; // index\n\n      cindex[nz] = r; // check we need to populate values\n\n      if (cvalues) {\n        cvalues[nz] = avalues[t];\n      } // increment number of nonzero elements\n\n\n      nz++;\n    }\n  } // finalize the last column of C\n\n\n  cptr[n] = nz; // return C matrix\n\n  return a.createSparseMatrix({\n    values: cvalues,\n    index: cindex,\n    ptr: cptr,\n    size: [m, n],\n    datatype: adt\n  });\n}\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","csPermute","a","pinv","q","values","avalues","_values","aindex","_index","aptr","_ptr","asize","_size","adt","_datatype","m","n","cvalues","cindex","cptr","nz","k","j","t1","t","t0","r","createSparseMatrix","index","ptr","size","datatype"]
}
