{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$function$algebra$simplify.js",
"lineCount":21,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/function/algebra/simplify.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$simplify\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSimplify = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _util = require(\"./simplify/util.js\");\n\nvar _simplifyCore = require(\"./simplify/simplifyCore.js\");\n\nvar _simplifyConstant = require(\"./simplify/simplifyConstant.js\");\n\nvar _resolve = require(\"./simplify/resolve.js\");\n\nvar _object = require(\"../../utils/object.js\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar name = 'simplify';\nvar dependencies = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', '?fraction', '?bignumber', 'mathWithTransform', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nvar createSimplify = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var config = _ref.config,\n      typed = _ref.typed,\n      parse = _ref.parse,\n      add = _ref.add,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      divide = _ref.divide,\n      pow = _ref.pow,\n      isZero = _ref.isZero,\n      equal = _ref.equal,\n      fraction = _ref.fraction,\n      bignumber = _ref.bignumber,\n      mathWithTransform = _ref.mathWithTransform,\n      ConstantNode = _ref.ConstantNode,\n      FunctionNode = _ref.FunctionNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode,\n      SymbolNode = _ref.SymbolNode;\n  var simplifyConstant = (0, _simplifyConstant.createSimplifyConstant)({\n    typed: typed,\n    config: config,\n    mathWithTransform: mathWithTransform,\n    fraction: fraction,\n    bignumber: bignumber,\n    ConstantNode: ConstantNode,\n    OperatorNode: OperatorNode,\n    FunctionNode: FunctionNode,\n    SymbolNode: SymbolNode\n  });\n  var simplifyCore = (0, _simplifyCore.createSimplifyCore)({\n    equal: equal,\n    isZero: isZero,\n    add: add,\n    subtract: subtract,\n    multiply: multiply,\n    divide: divide,\n    pow: pow,\n    ConstantNode: ConstantNode,\n    OperatorNode: OperatorNode,\n    FunctionNode: FunctionNode,\n    ParenthesisNode: ParenthesisNode\n  });\n  var resolve = (0, _resolve.createResolve)({\n    parse: parse,\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    ParenthesisNode: ParenthesisNode\n  });\n\n  var _createUtil = (0, _util.createUtil)({\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    SymbolNode: SymbolNode\n  }),\n      isCommutative = _createUtil.isCommutative,\n      isAssociative = _createUtil.isAssociative,\n      flatten = _createUtil.flatten,\n      unflattenr = _createUtil.unflattenr,\n      unflattenl = _createUtil.unflattenl,\n      createMakeNodeFunction = _createUtil.createMakeNodeFunction;\n  /**\n   * Simplify an expression tree.\n   *\n   * A list of rules are applied to an expression, repeating over the list until\n   * no further changes are made.\n   * It's possible to pass a custom set of rules to the function as second\n   * argument. A rule can be specified as an object, string, or function:\n   *\n   *     const rules = [\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\n   *       function (node) {\n   *         // ... return a new node or return the node unchanged\n   *         return node\n   *       }\n   *     ]\n   *\n   * String and object rules consist of a left and right pattern. The left is\n   * used to match against the expression and the right determines what matches\n   * are replaced with. The main difference between a pattern and a normal\n   * expression is that variables starting with the following characters are\n   * interpreted as wildcards:\n   *\n   * - 'n' - matches any Node\n   * - 'c' - matches any ConstantNode\n   * - 'v' - matches any Node that is not a ConstantNode\n   *\n   * The default list of rules is exposed on the function as `simplify.rules`\n   * and can be used as a basis to built a set of custom rules.\n   *\n   * For more details on the theory, see:\n   *\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\n   *\n   *  An optional `options` argument can be passed as last argument of `simplify`.\n   *  There is currently one option available:\n   *  - `exactFractions`: a boolean which is `true` by default.\n   *  - `fractionsLimit`: when `exactFractions` is true, a fraction will be returned\n   *    only when both numerator and denominator are smaller than `fractionsLimit`.\n   *    Default value is 10000.\n   *\n   * Syntax:\n   *\n   *     simplify(expr)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules)\n   *     simplify(expr, rules, scope)\n   *     simplify(expr, rules, scope, options)\n   *     simplify(expr, scope)\n   *     simplify(expr, scope, options)\n   *\n   * Examples:\n   *\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \"2 * x\"\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \"24\"\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify(f)                          // Node \"2 * x\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \"x * 2 / 5\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \"0.4 * x\"\n   *\n   * See also:\n   *\n   *     derivative, parse, evaluate, rationalize\n   *\n   * @param {Node | string} expr\n   *            The expression to be simplified\n   * @param {Array<{l:string, r: string} | string | function>} [rules]\n   *            Optional list with custom rules\n   * @return {Node} Returns the simplified form of `expr`\n   */\n\n\n  var simplify = typed('simplify', {\n    string: function string(expr) {\n      return this(parse(expr), this.rules, {}, {});\n    },\n    'string, Object': function stringObject(expr, scope) {\n      return this(parse(expr), this.rules, scope, {});\n    },\n    'string, Object, Object': function stringObjectObject(expr, scope, options) {\n      return this(parse(expr), this.rules, scope, options);\n    },\n    'string, Array': function stringArray(expr, rules) {\n      return this(parse(expr), rules, {}, {});\n    },\n    'string, Array, Object': function stringArrayObject(expr, rules, scope) {\n      return this(parse(expr), rules, scope, {});\n    },\n    'string, Array, Object, Object': function stringArrayObjectObject(expr, rules, scope, options) {\n      return this(parse(expr), rules, scope, options);\n    },\n    'Node, Object': function NodeObject(expr, scope) {\n      return this(expr, this.rules, scope, {});\n    },\n    'Node, Object, Object': function NodeObjectObject(expr, scope, options) {\n      return this(expr, this.rules, scope, options);\n    },\n    Node: function Node(expr) {\n      return this(expr, this.rules, {}, {});\n    },\n    'Node, Array': function NodeArray(expr, rules) {\n      return this(expr, rules, {}, {});\n    },\n    'Node, Array, Object': function NodeArrayObject(expr, rules, scope) {\n      return this(expr, rules, scope, {});\n    },\n    'Node, Array, Object, Object': function NodeArrayObjectObject(expr, rules, scope, options) {\n      rules = _buildRules(rules);\n      var res = resolve(expr, scope);\n      res = removeParens(res);\n      var visited = {};\n      var str = res.toString({\n        parenthesis: 'all'\n      });\n\n      while (!visited[str]) {\n        visited[str] = true;\n        _lastsym = 0; // counter for placeholder symbols\n\n        for (var i = 0; i < rules.length; i++) {\n          if (typeof rules[i] === 'function') {\n            res = rules[i](res, options);\n          } else {\n            flatten(res);\n            res = applyRule(res, rules[i]);\n          }\n\n          unflattenl(res); // using left-heavy binary tree here since custom rule functions may expect it\n        }\n\n        str = res.toString({\n          parenthesis: 'all'\n        });\n      }\n\n      return res;\n    }\n  });\n  simplify.simplifyCore = simplifyCore;\n  simplify.resolve = resolve;\n\n  function removeParens(node) {\n    return node.transform(function (node, path, parent) {\n      return (0, _is.isParenthesisNode)(node) ? removeParens(node.content) : node;\n    });\n  } // All constants that are allowed in rules\n\n\n  var SUPPORTED_CONSTANTS = {\n    \"true\": true,\n    \"false\": true,\n    e: true,\n    i: true,\n    Infinity: true,\n    LN2: true,\n    LN10: true,\n    LOG2E: true,\n    LOG10E: true,\n    NaN: true,\n    phi: true,\n    pi: true,\n    SQRT1_2: true,\n    SQRT2: true,\n    tau: true // null: false,\n    // undefined: false,\n    // version: false,\n\n  }; // Array of strings, used to build the ruleSet.\n  // Each l (left side) and r (right side) are parsed by\n  // the expression parser into a node tree.\n  // Left hand sides are matched to subtrees within the\n  // expression to be parsed and replaced with the right\n  // hand side.\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\n  // It is possible to get into an infinite loop with conflicting rules\n\n  simplify.rules = [simplifyCore, // { l: 'n+0', r: 'n' },     // simplifyCore\n  // { l: 'n^0', r: '1' },     // simplifyCore\n  // { l: '0*n', r: '0' },     // simplifyCore\n  // { l: 'n/n', r: '1'},      // simplifyCore\n  // { l: 'n^1', r: 'n' },     // simplifyCore\n  // { l: '+n1', r:'n1' },     // simplifyCore\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\n  {\n    l: 'log(e)',\n    r: '1'\n  }, // temporary rules\n  {\n    l: 'n-n1',\n    r: 'n+-n1'\n  }, // temporarily replace 'subtract' so we can further flatten the 'add' operator\n  {\n    l: '-(c*v)',\n    r: '(-c) * v'\n  }, // make non-constant terms positive\n  {\n    l: '-v',\n    r: '(-1) * v'\n  }, {\n    l: 'n/n1^n2',\n    r: 'n*n1^-n2'\n  }, // temporarily replace 'divide' so we can further flatten the 'multiply' operator\n  {\n    l: 'n/n1',\n    r: 'n*n1^-1'\n  }, // expand nested exponentiation\n  {\n    l: '(n ^ n1) ^ n2',\n    r: 'n ^ (n1 * n2)'\n  }, // collect like factors\n  {\n    l: 'n*n',\n    r: 'n^2'\n  }, {\n    l: 'n * n^n1',\n    r: 'n^(n1+1)'\n  }, {\n    l: 'n^n1 * n^n2',\n    r: 'n^(n1+n2)'\n  }, // collect like terms\n  {\n    l: 'n+n',\n    r: '2*n'\n  }, {\n    l: 'n+-n',\n    r: '0'\n  }, {\n    l: 'n1*n2 + n2',\n    r: '(n1+1)*n2'\n  }, {\n    l: 'n1*n3 + n2*n3',\n    r: '(n1+n2)*n3'\n  }, // remove parenthesis in the case of negating a quantitiy\n  {\n    l: 'n1 + -1 * (n2 + n3)',\n    r: 'n1 + -1 * n2 + -1 * n3'\n  }, simplifyConstant, {\n    l: '(-n)*n1',\n    r: '-(n*n1)'\n  }, // make factors positive (and undo 'make non-constant terms positive')\n  // ordering of constants\n  {\n    l: 'c+v',\n    r: 'v+c',\n    context: {\n      add: {\n        commutative: false\n      }\n    }\n  }, {\n    l: 'v*c',\n    r: 'c*v',\n    context: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // undo temporary rules\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\n  {\n    l: 'n+-n1',\n    r: 'n-n1'\n  }, // undo replace 'subtract'\n  {\n    l: 'n*(n1^-1)',\n    r: 'n/n1'\n  }, // undo replace 'divide'\n  {\n    l: 'n*n1^-n2',\n    r: 'n/n1^n2'\n  }, {\n    l: 'n1^-1',\n    r: '1/n1'\n  }, {\n    l: 'n*(n1/n2)',\n    r: '(n*n1)/n2'\n  }, // '*' before '/'\n  {\n    l: 'n-(n1+n2)',\n    r: 'n-n1-n2'\n  }, // '-' before '+'\n  // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\n  {\n    l: '1*n',\n    r: 'n'\n  }, // this pattern can be produced by simplifyConstant\n  {\n    l: 'n1/(n2/n3)',\n    r: '(n1*n3)/n2'\n  }];\n  /**\n   * Parse the string array of rules into nodes\n   *\n   * Example syntax for rules:\n   *\n   * Position constants to the left in a product:\n   * { l: 'n1 * c1', r: 'c1 * n1' }\n   * n1 is any Node, and c1 is a ConstantNode.\n   *\n   * Apply difference of squares formula:\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\n   * n1, n2 mean any Node.\n   *\n   * Short hand notation:\n   * 'n1 * c1 -> c1 * n1'\n   */\n\n  function _buildRules(rules) {\n    // Array of rules to be used to simplify expressions\n    var ruleSet = [];\n\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      var newRule = void 0;\n\n      var ruleType = _typeof(rule);\n\n      switch (ruleType) {\n        case 'string':\n          {\n            var lr = rule.split('->');\n\n            if (lr.length === 2) {\n              rule = {\n                l: lr[0],\n                r: lr[1]\n              };\n            } else {\n              throw SyntaxError('Could not parse rule: ' + rule);\n            }\n          }\n\n        /* falls through */\n\n        case 'object':\n          newRule = {\n            l: removeParens(parse(rule.l)),\n            r: removeParens(parse(rule.r))\n          };\n\n          if (rule.context) {\n            newRule.evaluate = rule.context;\n          }\n\n          if (rule.evaluate) {\n            newRule.evaluate = parse(rule.evaluate);\n          }\n\n          if (isAssociative(newRule.l)) {\n            var makeNode = createMakeNodeFunction(newRule.l);\n\n            var expandsym = _getExpandPlaceholderSymbol();\n\n            newRule.expanded = {};\n            newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]); // Push the expandsym into the deepest possible branch.\n            // This helps to match the newRule against nodes returned from getSplits() later on.\n\n            flatten(newRule.expanded.l);\n            unflattenr(newRule.expanded.l);\n            newRule.expanded.r = makeNode([newRule.r, expandsym]);\n          }\n\n          break;\n\n        case 'function':\n          newRule = rule;\n          break;\n\n        default:\n          throw TypeError('Unsupported type of rule: ' + ruleType);\n      } // console.log('Adding rule: ' + rules[i])\n      // console.log(newRule)\n\n\n      ruleSet.push(newRule);\n    }\n\n    return ruleSet;\n  }\n\n  var _lastsym = 0;\n\n  function _getExpandPlaceholderSymbol() {\n    return new SymbolNode('_p' + _lastsym++);\n  }\n  /**\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\n   */\n\n\n  var applyRule = typed('applyRule', {\n    'Node, Object': function NodeObject(node, rule) {\n      // console.log('Entering applyRule(' + node.toString() + ')')\n      // Do not clone node unless we find a match\n      var res = node; // First replace our child nodes with their simplified versions\n      // If a child could not be simplified, the assignments will have\n      // no effect since the node is returned unchanged\n\n      if (res instanceof OperatorNode || res instanceof FunctionNode) {\n        if (res.args) {\n          for (var i = 0; i < res.args.length; i++) {\n            res.args[i] = applyRule(res.args[i], rule);\n          }\n        }\n      } else if (res instanceof ParenthesisNode) {\n        if (res.content) {\n          res.content = applyRule(res.content, rule);\n        }\n      } // Try to match a rule against this node\n\n\n      var repl = rule.r;\n\n      var matches = _ruleMatch(rule.l, res)[0]; // If the rule is associative operator, we can try matching it while allowing additional terms.\n      // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\n\n\n      if (!matches && rule.expanded) {\n        repl = rule.expanded.r;\n        matches = _ruleMatch(rule.expanded.l, res)[0];\n      }\n\n      if (matches) {\n        // const before = res.toString({parenthesis: 'all'})\n        // Create a new node by cloning the rhs of the matched rule\n        // we keep any implicit multiplication state if relevant\n        var implicit = res.implicit;\n        res = repl.clone();\n\n        if (implicit && 'implicit' in repl) {\n          res.implicit = true;\n        } // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\n\n\n        res = res.transform(function (node) {\n          if (node.isSymbolNode && (0, _object.hasOwnProperty)(matches.placeholders, node.name)) {\n            return matches.placeholders[node.name].clone();\n          } else {\n            return node;\n          }\n        }); // const after = res.toString({parenthesis: 'all'})\n        // console.log('Simplified ' + before + ' to ' + after)\n      }\n\n      return res;\n    }\n  });\n  /**\n   * Get (binary) combinations of a flattened binary node\n   * e.g. +(node1, node2, node3) -> [\n   *        +(node1,  +(node2, node3)),\n   *        +(node2,  +(node1, node3)),\n   *        +(node3,  +(node1, node2))]\n   *\n   */\n\n  function getSplits(node, context) {\n    var res = [];\n    var right, rightArgs;\n    var makeNode = createMakeNodeFunction(node);\n\n    if (isCommutative(node, context)) {\n      for (var i = 0; i < node.args.length; i++) {\n        rightArgs = node.args.slice(0);\n        rightArgs.splice(i, 1);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([node.args[i], right]));\n      }\n    } else {\n      rightArgs = node.args.slice(1);\n      right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n      res.push(makeNode([node.args[0], right]));\n    }\n\n    return res;\n  }\n  /**\n   * Returns the set union of two match-placeholders or null if there is a conflict.\n   */\n\n\n  function mergeMatch(match1, match2) {\n    var res = {\n      placeholders: {}\n    }; // Some matches may not have placeholders; this is OK\n\n    if (!match1.placeholders && !match2.placeholders) {\n      return res;\n    } else if (!match1.placeholders) {\n      return match2;\n    } else if (!match2.placeholders) {\n      return match1;\n    } // Placeholders with the same key must match exactly\n\n\n    for (var key in match1.placeholders) {\n      if ((0, _object.hasOwnProperty)(match1.placeholders, key)) {\n        res.placeholders[key] = match1.placeholders[key];\n\n        if ((0, _object.hasOwnProperty)(match2.placeholders, key)) {\n          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\n            return null;\n          }\n        }\n      }\n    }\n\n    for (var _key in match2.placeholders) {\n      if ((0, _object.hasOwnProperty)(match2.placeholders, _key)) {\n        res.placeholders[_key] = match2.placeholders[_key];\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   */\n\n\n  function combineChildMatches(list1, list2) {\n    var res = [];\n\n    if (list1.length === 0 || list2.length === 0) {\n      return res;\n    }\n\n    var merged;\n\n    for (var i1 = 0; i1 < list1.length; i1++) {\n      for (var i2 = 0; i2 < list2.length; i2++) {\n        merged = mergeMatch(list1[i1], list2[i2]);\n\n        if (merged) {\n          res.push(merged);\n        }\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   * Returns a list of unique matches.\n   */\n\n\n  function mergeChildMatches(childMatches) {\n    if (childMatches.length === 0) {\n      return childMatches;\n    }\n\n    var sets = childMatches.reduce(combineChildMatches);\n    var uniqueSets = [];\n    var unique = {};\n\n    for (var i = 0; i < sets.length; i++) {\n      var s = JSON.stringify(sets[i]);\n\n      if (!unique[s]) {\n        unique[s] = true;\n        uniqueSets.push(sets[i]);\n      }\n    }\n\n    return uniqueSets;\n  }\n  /**\n   * Determines whether node matches rule.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _ruleMatch(rule, node, isSplit) {\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\n    //    console.log('rule = ' + rule)\n    //    console.log('node = ' + node)\n    //    console.log('Entering _ruleMatch(' + rule.toString() + ', ' + node.toString() + ')')\n    var res = [{\n      placeholders: {}\n    }];\n\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\n      if (rule instanceof OperatorNode) {\n        if (rule.op !== node.op || rule.fn !== node.fn) {\n          return [];\n        }\n      } else if (rule instanceof FunctionNode) {\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } // rule and node match. Search the children of rule and node.\n\n\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node) && node.args.length === rule.args.length || isSplit) {\n        // Expect non-associative operators to match exactly\n        var childMatches = [];\n\n        for (var i = 0; i < rule.args.length; i++) {\n          var childMatch = _ruleMatch(rule.args[i], node.args[i]);\n\n          if (childMatch.length === 0) {\n            // Child did not match, so stop searching immediately\n            return [];\n          } // The child matched, so add the information returned from the child to our result\n\n\n          childMatches.push(childMatch);\n        }\n\n        res = mergeChildMatches(childMatches);\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\n        // node is flattened, rule is not\n        // Associative operators/functions can be split in different ways so we check if the rule matches each\n        // them and return their union.\n        var splits = getSplits(node, rule.context);\n        var splitMatches = [];\n\n        for (var _i = 0; _i < splits.length; _i++) {\n          var matchSet = _ruleMatch(rule, splits[_i], true); // recursing at the same tree depth here\n\n\n          splitMatches = splitMatches.concat(matchSet);\n        }\n\n        return splitMatches;\n      } else if (rule.args.length > 2) {\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\n      } else {\n        // Incorrect number of arguments in rule and node, so no match\n        return [];\n      }\n    } else if (rule instanceof SymbolNode) {\n      // If the rule is a SymbolNode, then it carries a special meaning\n      // according to the first character of the symbol node name.\n      // c.* matches a ConstantNode\n      // n.* matches any node\n      if (rule.name.length === 0) {\n        throw new Error('Symbol in rule has 0 length...!?');\n      }\n\n      if (SUPPORTED_CONSTANTS[rule.name]) {\n        // built-in constant must match exactly\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } else if (rule.name[0] === 'n' || rule.name.substring(0, 2) === '_p') {\n        // rule matches _anything_, so assign this node to the rule.name placeholder\n        // Assign node to the rule.name placeholder.\n        // Our parent will check for matches among placeholders.\n        res[0].placeholders[rule.name] = node;\n      } else if (rule.name[0] === 'v') {\n        // rule matches any variable thing (not a ConstantNode)\n        if (!(0, _is.isConstantNode)(node)) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting something other than a ConstantNode\n          return [];\n        }\n      } else if (rule.name[0] === 'c') {\n        // rule matches any ConstantNode\n        if (node instanceof ConstantNode) {\n          res[0].placeholders[rule.name] = node;\n        } else {\n          // Mis-match: rule was expecting a ConstantNode\n          return [];\n        }\n      } else {\n        throw new Error('Invalid symbol in rule: ' + rule.name);\n      }\n    } else if (rule instanceof ConstantNode) {\n      // Literal constant must match exactly\n      if (!equal(rule.value, node.value)) {\n        return [];\n      }\n    } else {\n      // Some other node was encountered which we aren't prepared for, so no match\n      return [];\n    } // It's a match!\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\n\n\n    return res;\n  }\n  /**\n   * Determines whether p and q (and all their children nodes) are identical.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\n   * @return {Object} Information about the match, if it exists.\n   */\n\n\n  function _exactMatch(p, q) {\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\n      if (!equal(p.value, q.value)) {\n        return false;\n      }\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\n      if (p.name !== q.name) {\n        return false;\n      }\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\n      if (p instanceof OperatorNode) {\n        if (p.op !== q.op || p.fn !== q.fn) {\n          return false;\n        }\n      } else if (p instanceof FunctionNode) {\n        if (p.name !== q.name) {\n          return false;\n        }\n      }\n\n      if (p.args.length !== q.args.length) {\n        return false;\n      }\n\n      for (var i = 0; i < p.args.length; i++) {\n        if (!_exactMatch(p.args[i], q.args[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  return simplify;\n});\nexports.createSimplify = createSimplify;\n};"],
"names":["shadow$provide","global","require","module","exports","_typeof","obj","Symbol","iterator","constructor","prototype","Object","defineProperty","value","createSimplify","_is","_factory","_util","_simplifyCore","_simplifyConstant","_resolve","_object","factory","name","dependencies","_ref","removeParens","node","transform","path","parent","isParenthesisNode","content","mergeMatch","match1","match2","res","placeholders","key","hasOwnProperty","_exactMatch","_key","combineChildMatches","list1","list2","length","merged","i1","i2","push","_ruleMatch","rule","isSplit","OperatorNode","FunctionNode","op","fn","args","isAssociative","childMatches","i","childMatch","sets","reduce","uniqueSets","unique","s","JSON","stringify","context","makeNode","createMakeNodeFunction","isCommutative","rightArgs","slice","splice","right","splitMatches","_i","matchSet","concat","Error","toString","SymbolNode","SUPPORTED_CONSTANTS","substring","isConstantNode","ConstantNode","equal","p","q","config","typed","parse","add","subtract","multiply","divide","pow","isZero","fraction","bignumber","mathWithTransform","ParenthesisNode","simplifyConstant","createSimplifyConstant","simplifyCore","createSimplifyCore","resolve","createResolve","_createUtil","createUtil","flatten","unflattenr","unflattenl","simplify","string","expr","rules","stringObject","scope","stringObjectObject","options","stringArray","stringArrayObject","stringArrayObjectObject","NodeObject","NodeObjectObject","Node","NodeArray","NodeArrayObject","NodeArrayObjectObject","ruleSet","ruleType","lr","split","l","r","SyntaxError","newRule","evaluate","expandsym","_lastsym","expanded","clone","TypeError","visited","str","parenthesis","applyRule","e","Infinity","LN2","LN10","LOG2E","LOG10E","NaN","phi","pi","SQRT1_2","SQRT2","tau","commutative","repl","matches","implicit","isSymbolNode"]
}
