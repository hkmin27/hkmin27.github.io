shadow$provide.module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csLu=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createCsLu=void 0;global=require("module$node_modules$mathjs$lib$cjs$utils$factory");var _csSpsolve=require("module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csSpsolve");require=(0,global.factory)("csLu","abs divideScalar multiply subtract larger largerEq SparseMatrix".split(" "),function(_ref){var abs=_ref.abs,
divideScalar=_ref.divideScalar,multiply=_ref.multiply,subtract=_ref.subtract,larger=_ref.larger,largerEq=_ref.largerEq,SparseMatrix=_ref.SparseMatrix,csSpsolve=(0,_csSpsolve.createCsSpsolve)({divideScalar:divideScalar,multiply:multiply,subtract:subtract});return function(m,s,tol){if(!m)return null;var n=m._size[1],unz;if(s)var q=s.q;var lvalues=[],lindex=[],lptr=[],L=new SparseMatrix({values:lvalues,index:lindex,ptr:lptr,size:[n,n]}),uvalues=[],uindex=[],uptr=[],U=new SparseMatrix({values:uvalues,
index:uindex,ptr:uptr,size:[n,n]}),pinv=[],i,p,x=[],xi=[];for(i=0;i<n;i++)x[i]=0,pinv[i]=-1,lptr[i+1]=0;for(var k=unz=s=0;k<n;k++){lptr[k]=s;uptr[k]=unz;var col=q?q[k]:k,top=csSpsolve(L,m,col,xi,x,pinv,1),ipiv=-1,a=-1;for(p=top;p<n;p++)if(i=xi[p],0>pinv[i]){var xabs=abs(x[i]);larger(xabs,a)&&(a=xabs,ipiv=i)}else uindex[unz]=pinv[i],uvalues[unz++]=x[i];if(-1===ipiv||0>=a)return null;0>pinv[col]&&largerEq(abs(x[col]),multiply(a,tol))&&(ipiv=col);col=x[ipiv];uindex[unz]=k;uvalues[unz++]=col;pinv[ipiv]=
k;lindex[s]=ipiv;lvalues[s++]=1;for(p=top;p<n;p++)i=xi[p],0>pinv[i]&&(lindex[s]=i,lvalues[s++]=divideScalar(x[i],col)),x[i]=0}lptr[n]=s;uptr[n]=unz;for(p=0;p<s;p++)lindex[p]=pinv[lindex[p]];lvalues.splice(s,lvalues.length-s);lindex.splice(s,lindex.length-s);uvalues.splice(unz,uvalues.length-unz);uindex.splice(unz,uindex.length-unz);return{L:L,U:U,pinv:pinv}}});exports.createCsLu=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csLu.js.map
