{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csLu.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/function/algebra/sparse/csLu.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csLu\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCsLu = void 0;\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _csSpsolve = require(\"./csSpsolve.js\");\n\nvar name = 'csLu';\nvar dependencies = ['abs', 'divideScalar', 'multiply', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\nvar createCsLu = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var abs = _ref.abs,\n      divideScalar = _ref.divideScalar,\n      multiply = _ref.multiply,\n      subtract = _ref.subtract,\n      larger = _ref.larger,\n      largerEq = _ref.largerEq,\n      SparseMatrix = _ref.SparseMatrix;\n  var csSpsolve = (0, _csSpsolve.createCsSpsolve)({\n    divideScalar: divideScalar,\n    multiply: multiply,\n    subtract: subtract\n  });\n  /**\n   * Computes the numeric LU factorization of the sparse matrix A. Implements a Left-looking LU factorization\n   * algorithm that computes L and U one column at a tume. At the kth step, it access columns 1 to k-1 of L\n   * and column k of A. Given the fill-reducing column ordering q (see parameter s) computes L, U and pinv so\n   * L * U = A(p, q), where p is the inverse of pinv.\n   *\n   * @param {Matrix}  m               The A Matrix to factorize\n   * @param {Object}  s               The symbolic analysis from csSqr(). Provides the fill-reducing\n   *                                  column ordering q\n   * @param {Number}  tol             Partial pivoting threshold (1 for partial pivoting)\n   *\n   * @return {Number}                 The numeric LU factorization of A or null\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  return function csLu(m, s, tol) {\n    // validate input\n    if (!m) {\n      return null;\n    } // m arrays\n\n\n    var size = m._size; // columns\n\n    var n = size[1]; // symbolic analysis result\n\n    var q;\n    var lnz = 100;\n    var unz = 100; // update symbolic analysis parameters\n\n    if (s) {\n      q = s.q;\n      lnz = s.lnz || lnz;\n      unz = s.unz || unz;\n    } // L arrays\n\n\n    var lvalues = []; // (lnz)\n\n    var lindex = []; // (lnz)\n\n    var lptr = []; // (n + 1)\n    // L\n\n    var L = new SparseMatrix({\n      values: lvalues,\n      index: lindex,\n      ptr: lptr,\n      size: [n, n]\n    }); // U arrays\n\n    var uvalues = []; // (unz)\n\n    var uindex = []; // (unz)\n\n    var uptr = []; // (n + 1)\n    // U\n\n    var U = new SparseMatrix({\n      values: uvalues,\n      index: uindex,\n      ptr: uptr,\n      size: [n, n]\n    }); // inverse of permutation vector\n\n    var pinv = []; // (n)\n    // vars\n\n    var i, p; // allocate arrays\n\n    var x = []; // (n)\n\n    var xi = []; // (2 * n)\n    // initialize variables\n\n    for (i = 0; i < n; i++) {\n      // clear workspace\n      x[i] = 0; // no rows pivotal yet\n\n      pinv[i] = -1; // no cols of L yet\n\n      lptr[i + 1] = 0;\n    } // reset number of nonzero elements in L and U\n\n\n    lnz = 0;\n    unz = 0; // compute L(:,k) and U(:,k)\n\n    for (var k = 0; k < n; k++) {\n      // update ptr\n      lptr[k] = lnz;\n      uptr[k] = unz; // apply column permutations if needed\n\n      var col = q ? q[k] : k; // solve triangular system, x = L\\A(:,col)\n\n      var top = csSpsolve(L, m, col, xi, x, pinv, 1); // find pivot\n\n      var ipiv = -1;\n      var a = -1; // loop xi[] from top -> n\n\n      for (p = top; p < n; p++) {\n        // x[i] is nonzero\n        i = xi[p]; // check row i is not yet pivotal\n\n        if (pinv[i] < 0) {\n          // absolute value of x[i]\n          var xabs = abs(x[i]); // check absoulte value is greater than pivot value\n\n          if (larger(xabs, a)) {\n            // largest pivot candidate so far\n            a = xabs;\n            ipiv = i;\n          }\n        } else {\n          // x(i) is the entry U(pinv[i],k)\n          uindex[unz] = pinv[i];\n          uvalues[unz++] = x[i];\n        }\n      } // validate we found a valid pivot\n\n\n      if (ipiv === -1 || a <= 0) {\n        return null;\n      } // update actual pivot column, give preference to diagonal value\n\n\n      if (pinv[col] < 0 && largerEq(abs(x[col]), multiply(a, tol))) {\n        ipiv = col;\n      } // the chosen pivot\n\n\n      var pivot = x[ipiv]; // last entry in U(:,k) is U(k,k)\n\n      uindex[unz] = k;\n      uvalues[unz++] = pivot; // ipiv is the kth pivot row\n\n      pinv[ipiv] = k; // first entry in L(:,k) is L(k,k) = 1\n\n      lindex[lnz] = ipiv;\n      lvalues[lnz++] = 1; // L(k+1:n,k) = x / pivot\n\n      for (p = top; p < n; p++) {\n        // row\n        i = xi[p]; // check x(i) is an entry in L(:,k)\n\n        if (pinv[i] < 0) {\n          // save unpermuted row in L\n          lindex[lnz] = i; // scale pivot column\n\n          lvalues[lnz++] = divideScalar(x[i], pivot);\n        } // x[0..n-1] = 0 for next k\n\n\n        x[i] = 0;\n      }\n    } // update ptr\n\n\n    lptr[n] = lnz;\n    uptr[n] = unz; // fix row indices of L for final pinv\n\n    for (p = 0; p < lnz; p++) {\n      lindex[p] = pinv[lindex[p]];\n    } // trim arrays\n\n\n    lvalues.splice(lnz, lvalues.length - lnz);\n    lindex.splice(lnz, lindex.length - lnz);\n    uvalues.splice(unz, uvalues.length - unz);\n    uindex.splice(unz, uindex.length - unz); // return LU factor\n\n    return {\n      L: L,\n      U: U,\n      pinv: pinv\n    };\n  };\n});\nexports.createCsLu = createCsLu;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","createCsLu","_factory","_csSpsolve","factory","name","dependencies","_ref","abs","divideScalar","multiply","subtract","larger","largerEq","SparseMatrix","csSpsolve","createCsSpsolve","csLu","m","s","tol","n","_size","unz","q","lvalues","lindex","lptr","L","values","index","ptr","size","uvalues","uindex","uptr","U","pinv","i","p","x","xi","k","lnz","col","top","ipiv","a","xabs","pivot","splice","length"]
}
