{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$function$statistics$quantileSeq.js",
"lineCount":8,
"mappings":"AAAAA,cAAA,CAAA,kEAAA,CAAuF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG/HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,iBAAR,CAA4B,IAAK,EAEjC,KAAIC,IAAMP,OAAA,CAAQ,6CAAR,CAAV,CAEIQ,QAAUR,OAAA,CAAQ,iDAAR,CAFd,CAIIS,OAAST,OAAA,CAAQ,gDAAR,CAETU,OAAAA,CAAWV,OAAA,CAAQ,kDAAR,CAIXM,OAAAA,CAAmC,CAAC,CAAA,CAAGI,MAASC,CAAAA,OAAb,EAF5BC,aAE4B;AADpBC,CAAC,OAADA,CAAU,KAAVA,CAAiB,UAAjBA,CAA6B,iBAA7BA,CAAgD,SAAhDA,CACoB,CAA0C,QAAS,CAACC,IAAD,CAAO,CAuK/FC,QAASA,aAAY,CAACC,KAAD,CAAQC,IAAR,CAAcC,MAAd,CAAsB,CACrCC,KAAAA,CAAO,CAAC,CAAA,CAAGV,MAAOW,CAAAA,OAAX,EAAoBJ,KAApB,CACX,KAAIK,IAAMF,KAAKG,CAAAA,MAEf,IAAY,CAAZ,GAAID,GAAJ,CACE,KAAUE,MAAJ,CAAU,gDAAV,CAAN,CAGF,GAAI,CAAC,CAAA,CAAGhB,GAAIiB,CAAAA,QAAR,EAAkBP,IAAlB,CAAJ,CAA6B,CACvBQ,GAAAA,CAASR,IAATQ,EAAiBJ,GAAjBI,CAAuB,CAAvBA,CAEAC,KAAAA,CAAYD,GAAZC,CAAqB,CAEzB,IAAkB,CAAlB,GAAIA,IAAJ,CAGE,MAFIrB,MAEGA,CAFKa,MAAA,CAASC,KAAA,CAAKM,GAAL,CAAT,CAAwBE,eAAA,CAAgBR,KAAhB,CAAsBM,GAAtB,CAE7BpB,CADPuB,QAAA,CAASvB,KAAT,CACOA,CAAAA,KAGLwB,IAAAA,CAAeC,IAAKC,CAAAA,KAAL,CAAWN,GAAX,CAMnB,IAAIP,MAAJ,CAAY,CACVc,MAAA,CAAQb,KAAA,CAAKU,GAAL,CACR,KAAAI,OAASd,KAAA,CAAKU,GAAL,CAAoB,CAApB,CAFC,CAAZ,IAGO,CACLI,MAAA,CAASN,eAAA,CAAgBR,KAAhB,CAAsBU,GAAtB,CAAqC,CAArC,CAETG,OAAA;AAAQb,KAAA,CAAKU,GAAL,CAER,KAAK,IAAIK,EAAI,CAAb,CAAgBA,CAAhB,CAAoBL,GAApB,CAAkC,EAAEK,CAApC,CACgC,CAA9B,CAAIC,OAAA,CAAQhB,KAAA,CAAKe,CAAL,CAAR,CAAiBF,MAAjB,CAAJ,GACEA,MADF,CACUb,KAAA,CAAKe,CAAL,CADV,CANG,CAYPN,QAAA,CAASI,MAAT,CACAJ,SAAA,CAASK,MAAT,CAEA,OAAOG,IAAA,CAAIC,QAAA,CAASL,MAAT,CAAgB,CAAhB,CAAoBN,IAApB,CAAJ,CAAoCW,QAAA,CAASJ,MAAT,CAAiBP,IAAjB,CAApC,CAnCoB,CAuCzBY,IAAAA,CAAQrB,IAAKsB,CAAAA,KAAL,CAAWlB,GAAX,CAAiB,CAAjB,CAEZ,IAAIiB,IAAME,CAAAA,SAAN,EAAJ,CAME,MALAF,KAKOG,CALCH,IAAMI,CAAAA,QAAN,EAKDD,CAHHA,KAGGA,CAHMvB,MAAA,CAASC,KAAA,CAAKmB,IAAL,CAAT,CAAuBX,eAAA,CAAgBR,KAAhB,CAAsBmB,IAAtB,CAG7BG,CADPb,QAAA,CAASa,KAAT,CACOA,CAAAA,KAGLE,IAAAA,CAAcL,IAAMP,CAAAA,KAAN,EACda,KAAAA,CAAWN,IAAMO,CAAAA,KAAN,CAAYF,GAAZ,CACXG,IAAAA,CAAoBH,GAAYD,CAAAA,QAAZ,EAIxB,IAAIxB,MAAJ,CACE6B,MACA,CADO5B,KAAA,CAAK2B,GAAL,CACP,CAAAE,MAAA,CAAQ7B,KAAA,CAAK2B,GAAL,CAAyB,CAAzB,CAFV,KAQE,KAJAE,MAISC,CAJDtB,eAAA,CAAgBR,KAAhB,CAAsB2B,GAAtB,CAA0C,CAA1C,CAICG,CAFTF,MAESE,CAFF9B,KAAA,CAAK2B,GAAL,CAEEG,CAAAA,CAAAA,CAAM,CAAf,CAAkBA,CAAlB,CAAwBH,GAAxB,CAA2C,EAAEG,CAA7C,CACiC,CAA/B;AAAId,OAAA,CAAQhB,KAAA,CAAK8B,CAAL,CAAR,CAAmBF,MAAnB,CAAJ,GACEA,MADF,CACS5B,KAAA,CAAK8B,CAAL,CADT,CAMJrB,SAAA,CAASmB,MAAT,CACAnB,SAAA,CAASoB,MAAT,CAEIE,MAAAA,CAAM,IAAIN,IAASO,CAAAA,WAAb,CAAyB,CAAzB,CACV,OAAOf,IAAA,CAAIC,QAAA,CAASU,MAAT,CAAeG,KAAIL,CAAAA,KAAJ,CAAUD,IAAV,CAAf,CAAJ,CAAyCP,QAAA,CAASW,MAAT,CAAgBJ,IAAhB,CAAzC,CAnFkC,CAvKoD,IAC3FQ,MAAQtC,IAAKsC,CAAAA,KAD8E,CAE3FhB,IAAMtB,IAAKsB,CAAAA,GAFgF,CAG3FC,SAAWvB,IAAKuB,CAAAA,QAH2E,CAI3FV,gBAAkBb,IAAKa,CAAAA,eAJoE,CAK3FQ,QAAUrB,IAAKqB,CAAAA,OAL4E,CAoQ3FP,SAAWwB,KAAA,CAAM,CACnB,4BAA6BC,QAA4B,CAACC,CAAD,CAAI,CAC3D,MAAOA,EADoD,CAD1C,CAAN,CAKf,OAhOAC,SAAoB,CAACC,IAAD,CAAOC,OAAP,CAAgBvC,MAAhB,CAAwB,CAAA,IACpBgC,GAEtB,IAAuB,CAAvB,CAAIQ,SAAUpC,CAAAA,MAAd,EAA+C,CAA/C,CAA4BoC,SAAUpC,CAAAA,MAAtC,CACE,KAAM,KAAIqC,WAAJ,CAAgB,uDAAhB,CAAN;AAGF,GAAI,CAAC,CAAA,CAAGpD,GAAIqD,CAAAA,YAAR,EAAsBJ,IAAtB,CAAJ,GACEtC,MAEI,CAFKA,MAEL,EAFe,CAAA,CAEf,CAAkB,SAAlB,GAAA,MAAOA,OAHb,EAGmC,CAC/B,IAAA2C,QAAUL,IAAKM,CAAAA,OAAL,EAEV,IAAI,CAAC,CAAA,CAAGvD,GAAIiB,CAAAA,QAAR,EAAkBiC,OAAlB,CAAJ,CAAgC,CAC9B,GAAc,CAAd,CAAIA,OAAJ,CACE,KAAUlC,MAAJ,CAAU,6BAAV,CAAN,CAGF,GAAe,CAAf,EAAIkC,OAAJ,CAEE,MAAO1C,aAAA,CAAa8C,OAAb,CAAsBJ,OAAtB,CAA+BvC,MAA/B,CAGT,IAAc,CAAd,CAAIuC,OAAJ,CAAiB,CAEf,GAAI,CAAC,CAAC,CAAA,CAAGjD,OAAQgC,CAAAA,SAAZ,EAAuBiB,OAAvB,CAAL,CACE,KAAUlC,MAAJ,CAAU,8BAAV,CAAN,CAGF,IAAIwC,SAAWN,OAAXM,CAAqB,CACzB,KAAAC,QAAcC,KAAJ,CAAUR,OAAV,CAEV,KAASvB,GAAT,CAAa,CAAb,CAAgBA,GAAhB,CAAoBuB,OAApB,CAAA,CACEO,OAAA,CAAQ9B,GAAR,CAAA,CAAanB,YAAA,CAAa8C,OAAb,CAAsB,EAAE3B,GAAxB,CAA4B6B,QAA5B,CAAsC7C,MAAtC,CAGf,OAAO8C,QAbQ,CAVa,CA2BhC,GAAI,CAAC,CAAA,CAAGzD,GAAI2D,CAAAA,WAAR,EAAqBT,OAArB,CAAJ,CAAmC,CAC7BU,QAAAA;AAAYV,OAAQN,CAAAA,WAExB,IAAIM,OAAQW,CAAAA,UAAR,EAAJ,CACE,KAAU7C,MAAJ,CAAU,6BAAV,CAAN,CAGF2B,GAAA,CAAM,IAAIiB,QAAJ,CAAc,CAAd,CAEN,IAAIV,OAAQY,CAAAA,GAAR,CAAYnB,GAAZ,CAAJ,CAEE,MAAO,KAAIiB,QAAJ,CAAcpD,YAAA,CAAa8C,OAAb,CAAsBJ,OAAtB,CAA+BvC,MAA/B,CAAd,CAGT,IAAIuC,OAAQa,CAAAA,EAAR,CAAWpB,GAAX,CAAJ,CAAqB,CAEnB,GAAI,CAACO,OAAQjB,CAAAA,SAAR,EAAL,CACE,KAAUjB,MAAJ,CAAU,8BAAV,CAAN,CAKEgD,GAAAA,CAAOd,OAAQf,CAAAA,QAAR,EAEX,IAAW,UAAX,CAAI6B,GAAJ,CACE,KAAUhD,MAAJ,CAAU,mFAAV,CAAN,CAGF,IAAIiD,UAAY,IAAIL,QAAJ,CAAcI,GAAd,CAAqB,CAArB,CAEhBP,QAAA,CAAcC,KAAJ,CAAUM,GAAV,CAEV,KAAK,IAAIE,GAAK,CAAd,CAAiBA,EAAjB,CAAsBF,GAAtB,CAAA,CACEP,OAAA,CAAQS,EAAR,CAAA,CAAc,IAAIN,QAAJ,CAAcpD,YAAA,CAAa8C,OAAb;AAA0Ca,CAApB,IAAIP,QAAJ,CAAc,EAAEM,EAAhB,CAAoBC,EAAAA,GAApB,CAAwBF,SAAxB,CAAtB,CAA0DtD,MAA1D,CAAd,CAGhB,OAAO8C,QAtBY,CAdY,CAwCnC,GAAIC,KAAMU,CAAAA,OAAN,CAAclB,OAAd,CAAJ,CAA4B,CAE1BO,OAAA,CAAcC,KAAJ,CAAUR,OAAQnC,CAAAA,MAAlB,CAEV,KAASsD,QAAT,CAAe,CAAf,CAAkBA,QAAlB,CAAwBZ,OAAQ1C,CAAAA,MAAhC,CAAwC,EAAEsD,QAA1C,CAA+C,CACzCC,SAAAA,CAAWpB,OAAA,CAAQmB,QAAR,CAEf,IAAI,CAAC,CAAA,CAAGrE,GAAIiB,CAAAA,QAAR,EAAkBqD,SAAlB,CAAJ,CACE,IAAe,CAAf,CAAIA,SAAJ,EAA+B,CAA/B,CAAoBA,SAApB,CACE,KAAUtD,MAAJ,CAAU,gDAAV,CAAN,CADF,CADF,IAIO,IAAI,CAAC,CAAA,CAAGhB,GAAI2D,CAAAA,WAAR,EAAqBW,SAArB,CAAJ,CAGL,IAFA3B,GAEI,CAFE,IAAI2B,SAAS1B,CAAAA,WAAb,CAAyB,CAAzB,CAEF,CAAA0B,SAAST,CAAAA,UAAT,EAAA,EAAyBS,SAASP,CAAAA,EAAT,CAAYpB,GAAZ,CAA7B,CACE,KAAU3B,MAAJ,CAAU,gDAAV,CAAN,CADF,CAHK,IAOL,MAAM,KAAIuD,SAAJ,CAAc,qDAAd,CAAN;AAGFd,OAAA,CAAQY,QAAR,CAAA,CAAe7D,YAAA,CAAa8C,OAAb,CAAsBgB,SAAtB,CAAgC3D,MAAhC,CAjB8B,CAoB/C,MAAO8C,QAxBmB,CAtEG,CAuGnC,KAAM,KAAIc,SAAJ,CAAc,qDAAd,CAAN,CAjH0C,CAzCmD,CAA1D,CA2QvC5E,QAAQI,CAAAA,iBAAR,CAA4BA,MA7RmG;",
"sources":["node_modules/mathjs/lib/cjs/function/statistics/quantileSeq.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$statistics$quantileSeq\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createQuantileSeq = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'quantileSeq';\nvar dependencies = ['typed', 'add', 'multiply', 'partitionSelect', 'compare'];\nvar createQuantileSeq = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      add = _ref.add,\n      multiply = _ref.multiply,\n      partitionSelect = _ref.partitionSelect,\n      compare = _ref.compare;\n\n  /**\n   * Compute the prob order quantile of a matrix or a list with values.\n   * The sequence is sorted and the middle value is returned.\n   * Supported types of sequence values are: Number, BigNumber, Unit\n   * Supported types of probability are: Number, BigNumber\n   *\n   * In case of a (multi dimensional) array or matrix, the prob order quantile\n   * of all elements will be calculated.\n   *\n   * Syntax:\n   *\n   *     math.quantileSeq(A, prob[, sorted])\n   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])\n   *     math.quantileSeq(A, N[, sorted])\n   *\n   * Examples:\n   *\n   *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4\n   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]\n   *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]\n   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4\n   *\n   * See also:\n   *\n   *     median, mean, min, max, sum, prod, std, variance\n   *\n   * @param {Array, Matrix} data                A single matrix or Array\n   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is\n   *                                            the amount of evenly distributed steps of\n   *                                            probabilities; only one of these options can\n   *                                            be provided\n   * @param {Boolean} sorted=false              is data sorted in ascending order\n   * @return {Number, BigNumber, Unit, Array}   Quantile(s)\n   */\n  function quantileSeq(data, probOrN, sorted) {\n    var probArr, dataArr, one;\n\n    if (arguments.length < 2 || arguments.length > 3) {\n      throw new SyntaxError('Function quantileSeq requires two or three parameters');\n    }\n\n    if ((0, _is.isCollection)(data)) {\n      sorted = sorted || false;\n\n      if (typeof sorted === 'boolean') {\n        dataArr = data.valueOf();\n\n        if ((0, _is.isNumber)(probOrN)) {\n          if (probOrN < 0) {\n            throw new Error('N/prob must be non-negative');\n          }\n\n          if (probOrN <= 1) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return _quantileSeq(dataArr, probOrN, sorted);\n          }\n\n          if (probOrN > 1) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!(0, _number.isInteger)(probOrN)) {\n              throw new Error('N must be a positive integer');\n            }\n\n            var nPlusOne = probOrN + 1;\n            probArr = new Array(probOrN);\n\n            for (var i = 0; i < probOrN;) {\n              probArr[i] = _quantileSeq(dataArr, ++i / nPlusOne, sorted);\n            }\n\n            return probArr;\n          }\n        }\n\n        if ((0, _is.isBigNumber)(probOrN)) {\n          var BigNumber = probOrN.constructor;\n\n          if (probOrN.isNegative()) {\n            throw new Error('N/prob must be non-negative');\n          }\n\n          one = new BigNumber(1);\n\n          if (probOrN.lte(one)) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return new BigNumber(_quantileSeq(dataArr, probOrN, sorted));\n          }\n\n          if (probOrN.gt(one)) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!probOrN.isInteger()) {\n              throw new Error('N must be a positive integer');\n            } // largest possible Array length is 2^32-1\n            // 2^32 < 10^15, thus safe conversion guaranteed\n\n\n            var intN = probOrN.toNumber();\n\n            if (intN > 4294967295) {\n              throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');\n            }\n\n            var _nPlusOne = new BigNumber(intN + 1);\n\n            probArr = new Array(intN);\n\n            for (var _i = 0; _i < intN;) {\n              probArr[_i] = new BigNumber(_quantileSeq(dataArr, new BigNumber(++_i).div(_nPlusOne), sorted));\n            }\n\n            return probArr;\n          }\n        }\n\n        if (Array.isArray(probOrN)) {\n          // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])\n          probArr = new Array(probOrN.length);\n\n          for (var _i2 = 0; _i2 < probArr.length; ++_i2) {\n            var currProb = probOrN[_i2];\n\n            if ((0, _is.isNumber)(currProb)) {\n              if (currProb < 0 || currProb > 1) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else if ((0, _is.isBigNumber)(currProb)) {\n              one = new currProb.constructor(1);\n\n              if (currProb.isNegative() || currProb.gt(one)) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else {\n              throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n            }\n\n            probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);\n          }\n\n          return probArr;\n        }\n\n        throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n      }\n\n      throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n    }\n\n    throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n  }\n  /**\n   * Calculate the prob order quantile of an n-dimensional array.\n   *\n   * @param {Array} array\n   * @param {Number, BigNumber} prob\n   * @param {Boolean} sorted\n   * @return {Number, BigNumber, Unit} prob order quantile\n   * @private\n   */\n\n\n  function _quantileSeq(array, prob, sorted) {\n    var flat = (0, _array.flatten)(array);\n    var len = flat.length;\n\n    if (len === 0) {\n      throw new Error('Cannot calculate quantile of an empty sequence');\n    }\n\n    if ((0, _is.isNumber)(prob)) {\n      var _index = prob * (len - 1);\n\n      var _fracPart = _index % 1;\n\n      if (_fracPart === 0) {\n        var value = sorted ? flat[_index] : partitionSelect(flat, _index);\n        validate(value);\n        return value;\n      }\n\n      var _integerPart = Math.floor(_index);\n\n      var _left;\n\n      var _right;\n\n      if (sorted) {\n        _left = flat[_integerPart];\n        _right = flat[_integerPart + 1];\n      } else {\n        _right = partitionSelect(flat, _integerPart + 1); // max of partition is kth largest\n\n        _left = flat[_integerPart];\n\n        for (var i = 0; i < _integerPart; ++i) {\n          if (compare(flat[i], _left) > 0) {\n            _left = flat[i];\n          }\n        }\n      }\n\n      validate(_left);\n      validate(_right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n\n      return add(multiply(_left, 1 - _fracPart), multiply(_right, _fracPart));\n    } // If prob is a BigNumber\n\n\n    var index = prob.times(len - 1);\n\n    if (index.isInteger()) {\n      index = index.toNumber();\n\n      var _value = sorted ? flat[index] : partitionSelect(flat, index);\n\n      validate(_value);\n      return _value;\n    }\n\n    var integerPart = index.floor();\n    var fracPart = index.minus(integerPart);\n    var integerPartNumber = integerPart.toNumber();\n    var left;\n    var right;\n\n    if (sorted) {\n      left = flat[integerPartNumber];\n      right = flat[integerPartNumber + 1];\n    } else {\n      right = partitionSelect(flat, integerPartNumber + 1); // max of partition is kth largest\n\n      left = flat[integerPartNumber];\n\n      for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {\n        if (compare(flat[_i3], left) > 0) {\n          left = flat[_i3];\n        }\n      }\n    }\n\n    validate(left);\n    validate(right); // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n\n    var one = new fracPart.constructor(1);\n    return add(multiply(left, one.minus(fracPart)), multiply(right, fracPart));\n  }\n  /**\n   * Check if array value types are valid, throw error otherwise.\n   * @param {number | BigNumber | Unit} x\n   * @param {number | BigNumber | Unit} x\n   * @private\n   */\n\n\n  var validate = typed({\n    'number | BigNumber | Unit': function numberBigNumberUnit(x) {\n      return x;\n    }\n  });\n  return quantileSeq;\n});\nexports.createQuantileSeq = createQuantileSeq;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","createQuantileSeq","_is","_number","_array","_factory","factory","name","dependencies","_ref","_quantileSeq","array","prob","sorted","flat","flatten","len","length","Error","isNumber","_index","_fracPart","partitionSelect","validate","_integerPart","Math","floor","_left","_right","i","compare","add","multiply","index","times","isInteger","_value","toNumber","integerPart","fracPart","minus","integerPartNumber","left","right","_i3","one","constructor","typed","numberBigNumberUnit","x","quantileSeq","data","probOrN","arguments","SyntaxError","isCollection","dataArr","valueOf","nPlusOne","probArr","Array","isBigNumber","BigNumber","isNegative","lte","gt","intN","_nPlusOne","_i","div","isArray","_i2","currProb","TypeError"]
}
