shadow$provide.module$node_modules$mathjs$lib$cjs$type$matrix$Spa=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createSpaClass=void 0;global=require("module$node_modules$mathjs$lib$cjs$utils$factory");global=(0,global.factory)("Spa",["addScalar","equalScalar","FibonacciHeap"],function(_ref){function Spa(){if(!(this instanceof Spa))throw new SyntaxError("Constructor must be called with the new operator");this._values=[];this._heap=new FibonacciHeap}
var addScalar=_ref.addScalar,equalScalar=_ref.equalScalar,FibonacciHeap=_ref.FibonacciHeap;Spa.prototype.type="Spa";Spa.prototype.isSpa=!0;Spa.prototype.set=function(i,v){this._values[i]?this._values[i].value=v:(v=this._heap.insert(i,v),this._values[i]=v)};Spa.prototype.get=function(i){return(i=this._values[i])?i.value:0};Spa.prototype.accumulate=function(i,v){var node=this._values[i];node?node.value=addScalar(node.value,v):(node=this._heap.insert(i,v),this._values[i]=node)};Spa.prototype.forEach=
function(from,to,callback){var heap=this._heap,values=this._values,nodes=[],node=heap.extractMinimum();for(node&&nodes.push(node);node&&node.key<=to;)node.key>=from&&(equalScalar(node.value,0)||callback(node.key,node.value,this)),(node=heap.extractMinimum())&&nodes.push(node);for(from=0;from<nodes.length;from++)node=nodes[from],node=heap.insert(node.key,node.value),values[node.key]=node};Spa.prototype.swap=function(i,j){var nodei=this._values[i],nodej=this._values[j];!nodei&&nodej?(nodei=this._heap.insert(i,
nodej.value),this._heap.remove(nodej),this._values[i]=nodei,this._values[j]=void 0):nodei&&!nodej?(nodej=this._heap.insert(j,nodei.value),this._heap.remove(nodei),this._values[j]=nodej,this._values[i]=void 0):nodei&&nodej&&(i=nodei.value,nodei.value=nodej.value,nodej.value=i)};return Spa},{isClass:!0});exports.createSpaClass=global}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$type$matrix$Spa.js.map
