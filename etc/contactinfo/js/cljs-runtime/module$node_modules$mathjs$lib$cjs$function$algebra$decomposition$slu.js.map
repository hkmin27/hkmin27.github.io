{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$function$algebra$decomposition$slu.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/function/algebra/decomposition/slu.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$decomposition$slu\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSlu = void 0;\n\nvar _number = require(\"../../../utils/number.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _csSqr = require(\"../sparse/csSqr.js\");\n\nvar _csLu = require(\"../sparse/csLu.js\");\n\nvar name = 'slu';\nvar dependencies = ['typed', 'abs', 'add', 'multiply', 'transpose', 'divideScalar', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\nvar createSlu = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      abs = _ref.abs,\n      add = _ref.add,\n      multiply = _ref.multiply,\n      transpose = _ref.transpose,\n      divideScalar = _ref.divideScalar,\n      subtract = _ref.subtract,\n      larger = _ref.larger,\n      largerEq = _ref.largerEq,\n      SparseMatrix = _ref.SparseMatrix;\n  var csSqr = (0, _csSqr.createCsSqr)({\n    add: add,\n    multiply: multiply,\n    transpose: transpose\n  });\n  var csLu = (0, _csLu.createCsLu)({\n    abs: abs,\n    divideScalar: divideScalar,\n    multiply: multiply,\n    subtract: subtract,\n    larger: larger,\n    largerEq: largerEq,\n    SparseMatrix: SparseMatrix\n  });\n  /**\n   * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where\n   *\n   * `P * A * Q = L * U`\n   *\n   * Syntax:\n   *\n   *    math.slu(A, order, threshold)\n   *\n   * Examples:\n   *\n   *    const A = math.sparse([[4,3], [6, 3]])\n   *    math.slu(A, 1, 0.001)\n   *    // returns:\n   *    // {\n   *    //   L: [[1, 0], [1.5, 1]]\n   *    //   U: [[4, 3], [0, -1.5]]\n   *    //   p: [0, 1]\n   *    //   q: [0, 1]\n   *    // }\n   *\n   * See also:\n   *\n   *    lup, lsolve, usolve, lusolve\n   *\n   * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.\n   * @param {Number}       order          The Symbolic Ordering and Analysis order:\n   *                                       0 - Natural ordering, no permutation vector q is returned\n   *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'\n   *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'.\n   *                                           This is appropriatefor LU factorization of unsymmetric matrices.\n   *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.\n   *                                           A dense row is a row with more than 10*sqr(columns) entries.\n   * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)\n   *\n   * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.\n   */\n\n  return typed(name, {\n    'SparseMatrix, number, number': function SparseMatrixNumberNumber(a, order, threshold) {\n      // verify order\n      if (!(0, _number.isInteger)(order) || order < 0 || order > 3) {\n        throw new Error('Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]');\n      } // verify threshold\n\n\n      if (threshold < 0 || threshold > 1) {\n        throw new Error('Partial pivoting threshold must be a number from 0 to 1');\n      } // perform symbolic ordering and analysis\n\n\n      var s = csSqr(order, a, false); // perform lu decomposition\n\n      var f = csLu(a, s, threshold); // return decomposition\n\n      return {\n        L: f.L,\n        U: f.U,\n        p: f.pinv,\n        q: s.q,\n        toString: function toString() {\n          return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\np: ' + this.p.toString() + (this.q ? '\\nq: ' + this.q.toString() : '') + '\\n';\n        }\n      };\n    }\n  });\n});\nexports.createSlu = createSlu;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","createSlu","_number","_factory","_csSqr","_csLu","factory","name","dependencies","_ref","typed","abs","add","multiply","transpose","divideScalar","subtract","larger","largerEq","SparseMatrix","csSqr","createCsSqr","csLu","createCsLu","SparseMatrixNumberNumber","a","order","threshold","isInteger","Error","s","f","L","U","p","pinv","q","toString"]
}
