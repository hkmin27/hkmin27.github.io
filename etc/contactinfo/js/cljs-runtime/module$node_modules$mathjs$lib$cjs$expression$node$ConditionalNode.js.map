{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$expression$node$ConditionalNode.js",
"lineCount":12,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/expression/node/ConditionalNode.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$expression$node$ConditionalNode\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createConditionalNode = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _operators = require(\"../operators.js\");\n\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nvar createConditionalNode = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  /**\n   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n   *\n   * @param {Node} condition   Condition, must result in a boolean\n   * @param {Node} trueExpr    Expression evaluated when condition is true\n   * @param {Node} falseExpr   Expression evaluated when condition is true\n   *\n   * @constructor ConditionalNode\n   * @extends {Node}\n   */\n  function ConditionalNode(condition, trueExpr, falseExpr) {\n    if (!(this instanceof ConditionalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!(0, _is.isNode)(condition)) throw new TypeError('Parameter condition must be a Node');\n    if (!(0, _is.isNode)(trueExpr)) throw new TypeError('Parameter trueExpr must be a Node');\n    if (!(0, _is.isNode)(falseExpr)) throw new TypeError('Parameter falseExpr must be a Node');\n    this.condition = condition;\n    this.trueExpr = trueExpr;\n    this.falseExpr = falseExpr;\n  }\n\n  ConditionalNode.prototype = new Node();\n  ConditionalNode.prototype.type = 'ConditionalNode';\n  ConditionalNode.prototype.isConditionalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ConditionalNode.prototype._compile = function (math, argNames) {\n    var evalCondition = this.condition._compile(math, argNames);\n\n    var evalTrueExpr = this.trueExpr._compile(math, argNames);\n\n    var evalFalseExpr = this.falseExpr._compile(math, argNames);\n\n    return function evalConditionalNode(scope, args, context) {\n      return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ConditionalNode.prototype.forEach = function (callback) {\n    callback(this.condition, 'condition', this);\n    callback(this.trueExpr, 'trueExpr', this);\n    callback(this.falseExpr, 'falseExpr', this);\n  };\n  /**\n   * Create a new ConditionalNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ConditionalNode} Returns a transformed copy of the node\n   */\n\n\n  ConditionalNode.prototype.map = function (callback) {\n    return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ConditionalNode}\n   */\n\n\n  ConditionalNode.prototype.clone = function () {\n    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toString(options);\n    var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '(' + condition + ')';\n    }\n\n    var trueExpr = this.trueExpr.toString(options);\n    var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '(' + trueExpr + ')';\n    }\n\n    var falseExpr = this.falseExpr.toString(options);\n    var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '(' + falseExpr + ')';\n    }\n\n    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ConditionalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ConditionalNode',\n      condition: this.condition,\n      trueExpr: this.trueExpr,\n      falseExpr: this.falseExpr\n    };\n  };\n  /**\n   * Instantiate an ConditionalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ConditionalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ConditionalNode}\n   */\n\n\n  ConditionalNode.fromJSON = function (json) {\n    return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = (0, _operators.getPrecedence)(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toHTML(options);\n    var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var trueExpr = this.trueExpr.toHTML(options);\n    var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var falseExpr = this.falseExpr.toHTML(options);\n    var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toTex = function (options) {\n    return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n  };\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n\n\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n\n    if (condition) {\n      if ((0, _is.isBigNumber)(condition)) {\n        return !condition.isZero();\n      }\n\n      if ((0, _is.isComplex)(condition)) {\n        return !!(condition.re || condition.im);\n      }\n\n      if ((0, _is.isUnit)(condition)) {\n        return !!condition.value;\n      }\n    }\n\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n\n    throw new TypeError('Unsupported type of condition \"' + (0, _is.typeOf)(condition) + '\"');\n  }\n\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});\nexports.createConditionalNode = createConditionalNode;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","createConditionalNode","_is","_factory","_operators","factory","name","dependencies","_ref","ConditionalNode","condition","trueExpr","falseExpr","SyntaxError","isNode","TypeError","testCondition","isBigNumber","isZero","isComplex","re","im","isUnit","undefined","typeOf","prototype","Node","type","isConditionalNode","_compile","ConditionalNode.prototype._compile","math","argNames","evalCondition","evalTrueExpr","evalFalseExpr","evalConditionalNode","scope","args","context","forEach","ConditionalNode.prototype.forEach","callback","map","ConditionalNode.prototype.map","_ifNode","clone","ConditionalNode.prototype.clone","_toString","ConditionalNode.prototype._toString","options","parenthesis","precedence","getPrecedence","toString","conditionPrecedence","truePrecedence","falsePrecedence","toJSON","ConditionalNode.prototype.toJSON","mathjs","fromJSON","ConditionalNode.fromJSON","json","toHTML","ConditionalNode.prototype.toHTML","_toTex","ConditionalNode.prototype._toTex","toTex","isClass"]
}
