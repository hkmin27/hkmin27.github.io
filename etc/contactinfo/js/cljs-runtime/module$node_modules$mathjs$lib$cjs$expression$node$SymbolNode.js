shadow$provide.module$node_modules$mathjs$lib$cjs$expression$node$SymbolNode=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createSymbolNode=void 0;var _string=require("module$node_modules$mathjs$lib$cjs$utils$string"),_customs=require("module$node_modules$mathjs$lib$cjs$utils$customs");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");var _latex=require("module$node_modules$mathjs$lib$cjs$utils$latex");require=(0,global.factory)("SymbolNode",
["math","?Unit","Node"],function(_ref){function SymbolNode(name){if(!(this instanceof SymbolNode))throw new SyntaxError("Constructor must be called with the new operator");if("string"!==typeof name)throw new TypeError('String expected for parameter "name"');this.name=name}var math$jscomp$0=_ref.math,Unit=_ref.Unit;SymbolNode.prototype=new _ref.Node;SymbolNode.prototype.type="SymbolNode";SymbolNode.prototype.isSymbolNode=!0;SymbolNode.prototype._compile=function(math,argNames){var name=this.name;if(!0===
argNames[name])return function(scope,args,context){return args[name]};if(name in math)return function(scope,args,context){return name in scope?(0,_customs.getSafeProperty)(scope,name):(0,_customs.getSafeProperty)(math,name)};var isUnit=Unit?Unit.isValuelessUnit(name):!1;return function(scope,args,context){return name in scope?(0,_customs.getSafeProperty)(scope,name):isUnit?new Unit(null,name):SymbolNode.onUndefinedSymbol(name)}};SymbolNode.prototype.forEach=function(callback){};SymbolNode.prototype.map=
function(callback){return this.clone()};SymbolNode.onUndefinedSymbol=function(name){throw Error("Undefined symbol "+name);};SymbolNode.prototype.clone=function(){return new SymbolNode(this.name)};SymbolNode.prototype._toString=function(options){return this.name};SymbolNode.prototype.toHTML=function(options){options=(0,_string.escape)(this.name);return"true"===options||"false"===options?'\x3cspan class\x3d"math-symbol math-boolean"\x3e'+options+"\x3c/span\x3e":"i"===options?'\x3cspan class\x3d"math-symbol math-imaginary-symbol"\x3e'+
options+"\x3c/span\x3e":"Infinity"===options?'\x3cspan class\x3d"math-symbol math-infinity-symbol"\x3e'+options+"\x3c/span\x3e":"NaN"===options?'\x3cspan class\x3d"math-symbol math-nan-symbol"\x3e'+options+"\x3c/span\x3e":"null"===options?'\x3cspan class\x3d"math-symbol math-null-symbol"\x3e'+options+"\x3c/span\x3e":"undefined"===options?'\x3cspan class\x3d"math-symbol math-undefined-symbol"\x3e'+options+"\x3c/span\x3e":'\x3cspan class\x3d"math-symbol"\x3e'+options+"\x3c/span\x3e"};SymbolNode.prototype.toJSON=
function(){return{mathjs:"SymbolNode",name:this.name}};SymbolNode.fromJSON=function(json){return new SymbolNode(json.name)};SymbolNode.prototype._toTex=function(options){options=!1;"undefined"===typeof math$jscomp$0[this.name]&&Unit&&Unit.isValuelessUnit(this.name)&&(options=!0);options=(0,_latex.toSymbol)(this.name,options);return"\\"===options[0]?options:" "+options};return SymbolNode},{isClass:!0,isNode:!0});exports.createSymbolNode=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$expression$node$SymbolNode.js.map
