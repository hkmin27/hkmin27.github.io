{
"version":3,
"file":"module$node_modules$typed_function$typed_function.js",
"lineCount":37,
"mappings":"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",
"sources":["node_modules/typed-function/typed-function.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$typed_function$typed_function\"] = function(global,require,module,exports) {\n/**\n * typed-function\n *\n * Type checking for JavaScript functions\n *\n * https://github.com/josdejong/typed-function\n */\n'use strict';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // OldNode. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like OldNode.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.typed = factory();\n  }\n}(this, function () {\n\n  function ok () {\n    return true;\n  }\n\n  function notOk () {\n    return false;\n  }\n\n  function undef () {\n    return undefined;\n  }\n\n  /**\n   * @typedef {{\n   *   params: Param[],\n   *   fn: function\n   * }} Signature\n   *\n   * @typedef {{\n   *   types: Type[],\n   *   restParam: boolean\n   * }} Param\n   *\n   * @typedef {{\n   *   name: string,\n   *   typeIndex: number,\n   *   test: function,\n   *   conversion?: ConversionDef,\n   *   conversionIndex: number,\n   * }} Type\n   *\n   * @typedef {{\n   *   from: string,\n   *   to: string,\n   *   convert: function (*) : *\n   * }} ConversionDef\n   *\n   * @typedef {{\n   *   name: string,\n   *   test: function(*) : boolean\n   * }} TypeDef\n   */\n\n  // create a new instance of typed-function\n  function create () {\n    // data type tests\n    var _types = [\n      { name: 'number',    test: function (x) { return typeof x === 'number' } },\n      { name: 'string',    test: function (x) { return typeof x === 'string' } },\n      { name: 'boolean',   test: function (x) { return typeof x === 'boolean' } },\n      { name: 'Function',  test: function (x) { return typeof x === 'function'} },\n      { name: 'Array',     test: Array.isArray },\n      { name: 'Date',      test: function (x) { return x instanceof Date } },\n      { name: 'RegExp',    test: function (x) { return x instanceof RegExp } },\n      { name: 'Object',    test: function (x) {\n        return typeof x === 'object' && x !== null && x.constructor === Object\n      }},\n      { name: 'null',      test: function (x) { return x === null } },\n      { name: 'undefined', test: function (x) { return x === undefined } }\n    ];\n\n    var anyType = {\n      name: 'any',\n      test: ok\n    }\n\n    // types which need to be ignored\n    var _ignore = [];\n\n    // type conversions\n    var _conversions = [];\n\n    // This is a temporary object, will be replaced with a typed function at the end\n    var typed = {\n      types: _types,\n      conversions: _conversions,\n      ignore: _ignore\n    };\n\n    /**\n     * Find the test function for a type\n     * @param {String} typeName\n     * @return {TypeDef} Returns the type definition when found,\n     *                    Throws a TypeError otherwise\n     */\n    function findTypeByName (typeName) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.name === typeName;\n      });\n\n      if (entry) {\n        return entry;\n      }\n\n      if (typeName === 'any') { // special baked-in case 'any'\n        return anyType;\n      }\n\n      var hint = findInArray(typed.types, function (entry) {\n        return entry.name.toLowerCase() === typeName.toLowerCase();\n      });\n\n      throw new TypeError('Unknown type \"' + typeName + '\"' +\n          (hint ? ('. Did you mean \"' + hint.name + '\"?') : ''));\n    }\n\n    /**\n     * Find the index of a type definition. Handles special case 'any'\n     * @param {TypeDef} type\n     * @return {number}\n     */\n    function findTypeIndex(type) {\n      if (type === anyType) {\n        return 999;\n      }\n\n      return typed.types.indexOf(type);\n    }\n\n    /**\n     * Find a type that matches a value.\n     * @param {*} value\n     * @return {string} Returns the name of the first type for which\n     *                  the type test matches the value.\n     */\n    function findTypeName(value) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.test(value);\n      });\n\n      if (entry) {\n        return entry.name;\n      }\n\n      throw new TypeError('Value has unknown type. Value: ' + value);\n    }\n\n    /**\n     * Find a specific signature from a (composed) typed function, for example:\n     *\n     *   typed.find(fn, ['number', 'string'])\n     *   typed.find(fn, 'number, string')\n     *\n     * Function find only only works for exact matches.\n     *\n     * @param {Function} fn                   A typed-function\n     * @param {string | string[]} signature   Signature to be found, can be\n     *                                        an array or a comma separated string.\n     * @return {Function}                     Returns the matching signature, or\n     *                                        throws an error when no signature\n     *                                        is found.\n     */\n    function find (fn, signature) {\n      if (!fn.signatures) {\n        throw new TypeError('Function is no typed-function');\n      }\n\n      // normalize input\n      var arr;\n      if (typeof signature === 'string') {\n        arr = signature.split(',');\n        for (var i = 0; i < arr.length; i++) {\n          arr[i] = arr[i].trim();\n        }\n      }\n      else if (Array.isArray(signature)) {\n        arr = signature;\n      }\n      else {\n        throw new TypeError('String array or a comma separated string expected');\n      }\n\n      var str = arr.join(',');\n\n      // find an exact match\n      var match = fn.signatures[str];\n      if (match) {\n        return match;\n      }\n\n      // TODO: extend find to match non-exact signatures\n\n      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');\n    }\n\n    /**\n     * Convert a given value to another data type.\n     * @param {*} value\n     * @param {string} type\n     */\n    function convert (value, type) {\n      var from = findTypeName(value);\n\n      // check conversion is needed\n      if (type === from) {\n        return value;\n      }\n\n      for (var i = 0; i < typed.conversions.length; i++) {\n        var conversion = typed.conversions[i];\n        if (conversion.from === from && conversion.to === type) {\n          return conversion.convert(value);\n        }\n      }\n\n      throw new Error('Cannot convert from ' + from + ' to ' + type);\n    }\n    \n    /**\n     * Stringify parameters in a normalized way\n     * @param {Param[]} params\n     * @return {string}\n     */\n    function stringifyParams (params) {\n      return params\n          .map(function (param) {\n            var typeNames = param.types.map(getTypeName);\n\n            return (param.restParam ? '...' : '') + typeNames.join('|');\n          })\n          .join(',');\n    }\n\n    /**\n     * Parse a parameter, like \"...number | boolean\"\n     * @param {string} param\n     * @param {ConversionDef[]} conversions\n     * @return {Param} param\n     */\n    function parseParam (param, conversions) {\n      var restParam = param.indexOf('...') === 0;\n      var types = (!restParam)\n          ? param\n          : (param.length > 3)\n              ? param.slice(3)\n              : 'any';\n\n      var typeNames = types.split('|').map(trim)\n          .filter(notEmpty)\n          .filter(notIgnore);\n\n      var matchingConversions = filterConversions(conversions, typeNames);\n\n      var exactTypes = typeNames.map(function (typeName) {\n        var type = findTypeByName(typeName);\n\n        return {\n          name: typeName,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: null,\n          conversionIndex: -1\n        };\n      });\n\n      var convertibleTypes = matchingConversions.map(function (conversion) {\n        var type = findTypeByName(conversion.from);\n\n        return {\n          name: conversion.from,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: conversion,\n          conversionIndex: conversions.indexOf(conversion)\n        };\n      });\n\n      return {\n        types: exactTypes.concat(convertibleTypes),\n        restParam: restParam\n      };\n    }\n\n    /**\n     * Parse a signature with comma separated parameters,\n     * like \"number | boolean, ...string\"\n     * @param {string} signature\n     * @param {function} fn\n     * @param {ConversionDef[]} conversions\n     * @return {Signature | null} signature\n     */\n    function parseSignature (signature, fn, conversions) {\n      var params = [];\n\n      if (signature.trim() !== '') {\n        params = signature\n            .split(',')\n            .map(trim)\n            .map(function (param, index, array) {\n              var parsedParam = parseParam(param, conversions);\n\n              if (parsedParam.restParam && (index !== array.length - 1)) {\n                throw new SyntaxError('Unexpected rest parameter \"' + param + '\": ' +\n                    'only allowed for the last parameter');\n              }\n\n              return parsedParam;\n          });\n      }\n\n      if (params.some(isInvalidParam)) {\n        // invalid signature: at least one parameter has no types\n        // (they may have been filtered)\n        return null;\n      }\n\n      return {\n        params: params,\n        fn: fn\n      };\n    }\n\n    /**\n     * Test whether a set of params contains a restParam\n     * @param {Param[]} params\n     * @return {boolean} Returns true when the last parameter is a restParam\n     */\n    function hasRestParam(params) {\n      var param = last(params)\n      return param ? param.restParam : false;\n    }\n\n    /**\n     * Test whether a parameter contains conversions\n     * @param {Param} param\n     * @return {boolean} Returns true when at least one of the parameters\n     *                   contains a conversion.\n     */\n    function hasConversions(param) {\n      return param.types.some(function (type) {\n        return type.conversion != null;\n      });\n    }\n\n    /**\n     * Create a type test for a single parameter, which can have one or multiple\n     * types.\n     * @param {Param} param\n     * @return {function(x: *) : boolean} Returns a test function\n     */\n    function compileTest(param) {\n      if (!param || param.types.length === 0) {\n        // nothing to do\n        return ok;\n      }\n      else if (param.types.length === 1) {\n        return findTypeByName(param.types[0].name).test;\n      }\n      else if (param.types.length === 2) {\n        var test0 = findTypeByName(param.types[0].name).test;\n        var test1 = findTypeByName(param.types[1].name).test;\n        return function or(x) {\n          return test0(x) || test1(x);\n        }\n      }\n      else { // param.types.length > 2\n        var tests = param.types.map(function (type) {\n          return findTypeByName(type.name).test;\n        })\n        return function or(x) {\n          for (var i = 0; i < tests.length; i++) {\n            if (tests[i](x)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n    }\n\n    /**\n     * Create a test for all parameters of a signature\n     * @param {Param[]} params\n     * @return {function(args: Array<*>) : boolean}\n     */\n    function compileTests(params) {\n      var tests, test0, test1;\n\n      if (hasRestParam(params)) {\n        // variable arguments like '...number'\n        tests = initial(params).map(compileTest);\n        var varIndex = tests.length;\n        var lastTest = compileTest(last(params));\n        var testRestParam = function (args) {\n          for (var i = varIndex; i < args.length; i++) {\n            if (!lastTest(args[i])) {\n              return false;\n            }\n          }\n          return true;\n        }\n\n        return function testArgs(args) {\n          for (var i = 0; i < tests.length; i++) {\n            if (!tests[i](args[i])) {\n              return false;\n            }\n          }\n          return testRestParam(args) && (args.length >= varIndex + 1);\n        };\n      }\n      else {\n        // no variable arguments\n        if (params.length === 0) {\n          return function testArgs(args) {\n            return args.length === 0;\n          };\n        }\n        else if (params.length === 1) {\n          test0 = compileTest(params[0]);\n          return function testArgs(args) {\n            return test0(args[0]) && args.length === 1;\n          };\n        }\n        else if (params.length === 2) {\n          test0 = compileTest(params[0]);\n          test1 = compileTest(params[1]);\n          return function testArgs(args) {\n            return test0(args[0]) && test1(args[1]) && args.length === 2;\n          };\n        }\n        else { // arguments.length > 2\n          tests = params.map(compileTest);\n          return function testArgs(args) {\n            for (var i = 0; i < tests.length; i++) {\n              if (!tests[i](args[i])) {\n                return false;\n              }\n            }\n            return args.length === tests.length;\n          };\n        }\n      }\n    }\n\n    /**\n     * Find the parameter at a specific index of a signature.\n     * Handles rest parameters.\n     * @param {Signature} signature\n     * @param {number} index\n     * @return {Param | null} Returns the matching parameter when found,\n     *                        null otherwise.\n     */\n    function getParamAtIndex(signature, index) {\n      return index < signature.params.length\n          ? signature.params[index]\n          : hasRestParam(signature.params)\n              ? last(signature.params)\n              : null\n    }\n\n    /**\n     * Get all type names of a parameter\n     * @param {Signature} signature\n     * @param {number} index\n     * @param {boolean} excludeConversions\n     * @return {string[]} Returns an array with type names\n     */\n    function getExpectedTypeNames (signature, index, excludeConversions) {\n      var param = getParamAtIndex(signature, index);\n      var types = param\n          ? excludeConversions\n                  ? param.types.filter(isExactType)\n                  : param.types\n          : [];\n\n      return types.map(getTypeName);\n    }\n\n    /**\n     * Returns the name of a type\n     * @param {Type} type\n     * @return {string} Returns the type name\n     */\n    function getTypeName(type) {\n      return type.name;\n    }\n\n    /**\n     * Test whether a type is an exact type or conversion\n     * @param {Type} type\n     * @return {boolean} Returns true when\n     */\n    function isExactType(type) {\n      return type.conversion === null || type.conversion === undefined;\n    }\n\n    /**\n     * Helper function for creating error messages: create an array with\n     * all available types on a specific argument index.\n     * @param {Signature[]} signatures\n     * @param {number} index\n     * @return {string[]} Returns an array with available types\n     */\n    function mergeExpectedParams(signatures, index) {\n      var typeNames = uniq(flatMap(signatures, function (signature) {\n        return getExpectedTypeNames(signature, index, false);\n      }));\n\n      return (typeNames.indexOf('any') !== -1) ? ['any'] : typeNames;\n    }\n\n    /**\n     * Create\n     * @param {string} name             The name of the function\n     * @param {array.<*>} args          The actual arguments passed to the function\n     * @param {Signature[]} signatures  A list with available signatures\n     * @return {TypeError} Returns a type error with additional data\n     *                     attached to it in the property `data`\n     */\n    function createError(name, args, signatures) {\n      var err, expected;\n      var _name = name || 'unnamed';\n\n      // test for wrong type at some index\n      var matchingSignatures = signatures;\n      var index;\n      for (index = 0; index < args.length; index++) {\n        var nextMatchingDefs = matchingSignatures.filter(function (signature) {\n          var test = compileTest(getParamAtIndex(signature, index));\n          return (index < signature.params.length || hasRestParam(signature.params)) &&\n              test(args[index]);\n        });\n\n        if (nextMatchingDefs.length === 0) {\n          // no matching signatures anymore, throw error \"wrong type\"\n          expected = mergeExpectedParams(matchingSignatures, index);\n          if (expected.length > 0) {\n            var actualType = findTypeName(args[index]);\n\n            err = new TypeError('Unexpected type of argument in function ' + _name +\n                ' (expected: ' + expected.join(' or ') +\n                ', actual: ' + actualType + ', index: ' + index + ')');\n            err.data = {\n              category: 'wrongType',\n              fn: _name,\n              index: index,\n              actual: actualType,\n              expected: expected\n            }\n            return err;\n          }\n        }\n        else {\n          matchingSignatures = nextMatchingDefs;\n        }\n      }\n\n      // test for too few arguments\n      var lengths = matchingSignatures.map(function (signature) {\n        return hasRestParam(signature.params) ? Infinity : signature.params.length;\n      });\n      if (args.length < Math.min.apply(null, lengths)) {\n        expected = mergeExpectedParams(matchingSignatures, index);\n        err = new TypeError('Too few arguments in function ' + _name +\n            ' (expected: ' + expected.join(' or ') +\n            ', index: ' + args.length + ')');\n        err.data = {\n          category: 'tooFewArgs',\n          fn: _name,\n          index: args.length,\n          expected: expected\n        }\n        return err;\n      }\n\n      // test for too many arguments\n      var maxLength = Math.max.apply(null, lengths);\n      if (args.length > maxLength) {\n        err = new TypeError('Too many arguments in function ' + _name +\n            ' (expected: ' + maxLength + ', actual: ' + args.length + ')');\n        err.data = {\n          category: 'tooManyArgs',\n          fn: _name,\n          index: args.length,\n          expectedLength: maxLength\n        }\n        return err;\n      }\n\n      err = new TypeError('Arguments of type \"' + args.join(', ') +\n          '\" do not match any of the defined signatures of function ' + _name + '.');\n      err.data = {\n        category: 'mismatch',\n        actual: args.map(findTypeName)\n      }\n      return err;\n    }\n\n    /**\n     * Find the lowest index of all exact types of a parameter (no conversions)\n     * @param {Param} param\n     * @return {number} Returns the index of the lowest type in typed.types\n     */\n    function getLowestTypeIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].typeIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Find the lowest index of the conversion of all types of the parameter\n     * having a conversion\n     * @param {Param} param\n     * @return {number} Returns the lowest index of the conversions of this type\n     */\n    function getLowestConversionIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (!isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].conversionIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Compare two params\n     * @param {Param} param1\n     * @param {Param} param2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareParams (param1, param2) {\n      var c;\n\n      // compare having a rest parameter or not\n      c = param1.restParam - param2.restParam;\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare having conversions or not\n      c = hasConversions(param1) - hasConversions(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of the types\n      c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of any conversion\n      return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);\n    }\n\n    /**\n     * Compare two signatures\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareSignatures (signature1, signature2) {\n      var len = Math.min(signature1.params.length, signature2.params.length);\n      var i;\n      var c;\n\n      // compare whether the params have conversions at all or not\n      c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions)\n      if (c !== 0) {\n        return c;\n      }\n\n      // next compare whether the params have conversions one by one\n      for (i = 0; i < len; i++) {\n        c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the types of the params one by one\n      for (i = 0; i < len; i++) {\n        c = compareParams(signature1.params[i], signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the number of params\n      return signature1.params.length - signature2.params.length;\n    }\n\n    /**\n     * Get params containing all types that can be converted to the defined types.\n     *\n     * @param {ConversionDef[]} conversions\n     * @param {string[]} typeNames\n     * @return {ConversionDef[]} Returns the conversions that are available\n     *                        for every type (if any)\n     */\n    function filterConversions(conversions, typeNames) {\n      var matches = {};\n\n      conversions.forEach(function (conversion) {\n        if (typeNames.indexOf(conversion.from) === -1 &&\n            typeNames.indexOf(conversion.to) !== -1 &&\n            !matches[conversion.from]) {\n          matches[conversion.from] = conversion;\n        }\n      });\n\n      return Object.keys(matches).map(function (from) {\n        return matches[from];\n      });\n    }\n\n    /**\n     * Preprocess arguments before calling the original function:\n     * - if needed convert the parameters\n     * - in case of rest parameters, move the rest parameters into an Array\n     * @param {Param[]} params\n     * @param {function} fn\n     * @return {function} Returns a wrapped function\n     */\n    function compileArgsPreprocessing(params, fn) {\n      var fnConvert = fn;\n\n      // TODO: can we make this wrapper function smarter/simpler?\n\n      if (params.some(hasConversions)) {\n        var restParam = hasRestParam(params);\n        var compiledConversions = params.map(compileArgConversion)\n\n        fnConvert = function convertArgs() {\n          var args = [];\n          var last = restParam ? arguments.length - 1 : arguments.length;\n          for (var i = 0; i < last; i++) {\n            args[i] = compiledConversions[i](arguments[i]);\n          }\n          if (restParam) {\n            args[last] = arguments[last].map(compiledConversions[last]);\n          }\n\n          return fn.apply(this, args);\n        }\n      }\n\n      var fnPreprocess = fnConvert;\n      if (hasRestParam(params)) {\n        var offset = params.length - 1;\n\n        fnPreprocess = function preprocessRestParams () {\n          return fnConvert.apply(this,\n              slice(arguments, 0, offset).concat([slice(arguments, offset)]));\n        }\n      }\n\n      return fnPreprocess;\n    }\n\n    /**\n     * Compile conversion for a parameter to the right type\n     * @param {Param} param\n     * @return {function} Returns the wrapped function that will convert arguments\n     *\n     */\n    function compileArgConversion(param) {\n      var test0, test1, conversion0, conversion1;\n      var tests = [];\n      var conversions = [];\n\n      param.types.forEach(function (type) {\n        if (type.conversion) {\n          tests.push(findTypeByName(type.conversion.from).test);\n          conversions.push(type.conversion.convert);\n        }\n      });\n\n      // create optimized conversion functions depending on the number of conversions\n      switch (conversions.length) {\n        case 0:\n          return function convertArg(arg) {\n            return arg;\n          }\n\n        case 1:\n          test0 = tests[0]\n          conversion0 = conversions[0];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            return arg;\n          }\n\n        case 2:\n          test0 = tests[0]\n          test1 = tests[1]\n          conversion0 = conversions[0];\n          conversion1 = conversions[1];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            if (test1(arg)) {\n              return conversion1(arg)\n            }\n            return arg;\n          }\n\n        default:\n          return function convertArg(arg) {\n            for (var i = 0; i < conversions.length; i++) {\n              if (tests[i](arg)) {\n                return conversions[i](arg);\n              }\n            }\n            return arg;\n          }\n      }\n    }\n\n    /**\n     * Convert an array with signatures into a map with signatures,\n     * where signatures with union types are split into separate signatures\n     *\n     * Throws an error when there are conflicting types\n     *\n     * @param {Signature[]} signatures\n     * @return {Object.<string, function>}  Returns a map with signatures\n     *                                      as key and the original function\n     *                                      of this signature as value.\n     */\n    function createSignaturesMap(signatures) {\n      var signaturesMap = {};\n      signatures.forEach(function (signature) {\n        if (!signature.params.some(hasConversions)) {\n          splitParams(signature.params, true).forEach(function (params) {\n            signaturesMap[stringifyParams(params)] = signature.fn;\n          });\n        }\n      });\n\n      return signaturesMap;\n    }\n\n    /**\n     * Split params with union types in to separate params.\n     *\n     * For example:\n     *\n     *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\n     *     // returns:\n     *     // [\n     *     //   ['Array', 'string'],\n     *     //   ['Array', 'RegExp'],\n     *     //   ['Object', 'string'],\n     *     //   ['Object', 'RegExp']\n     *     // ]\n     *\n     * @param {Param[]} params\n     * @param {boolean} ignoreConversionTypes\n     * @return {Param[]}\n     */\n    function splitParams(params, ignoreConversionTypes) {\n      function _splitParams(params, index, types) {\n        if (index < params.length) {\n          var param = params[index]\n          var filteredTypes = ignoreConversionTypes\n              ? param.types.filter(isExactType)\n              : param.types;\n          var typeGroups\n\n          if (param.restParam) {\n            // split the types of a rest parameter in two:\n            // one with only exact types, and one with exact types and conversions\n            var exactTypes = filteredTypes.filter(isExactType)\n            typeGroups = exactTypes.length < filteredTypes.length\n                ? [exactTypes, filteredTypes]\n                : [filteredTypes]\n\n          }\n          else {\n            // split all the types of a regular parameter into one type per group\n            typeGroups = filteredTypes.map(function (type) {\n              return [type]\n            })\n          }\n\n          // recurse over the groups with types\n          return flatMap(typeGroups, function (typeGroup) {\n            return _splitParams(params, index + 1, types.concat([typeGroup]));\n          });\n\n        }\n        else {\n          // we've reached the end of the parameters. Now build a new Param\n          var splittedParams = types.map(function (type, typeIndex) {\n            return {\n              types: type,\n              restParam: (typeIndex === params.length - 1) && hasRestParam(params)\n            }\n          });\n\n          return [splittedParams];\n        }\n      }\n\n      return _splitParams(params, 0, []);\n    }\n\n    /**\n     * Test whether two signatures have a conflicting signature\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {boolean} Returns true when the signatures conflict, false otherwise.\n     */\n    function hasConflictingParams(signature1, signature2) {\n      var ii = Math.max(signature1.params.length, signature2.params.length);\n\n      for (var i = 0; i < ii; i++) {\n        var typesNames1 = getExpectedTypeNames(signature1, i, true);\n        var typesNames2 = getExpectedTypeNames(signature2, i, true);\n\n        if (!hasOverlap(typesNames1, typesNames2)) {\n          return false;\n        }\n      }\n\n      var len1 = signature1.params.length;\n      var len2 = signature2.params.length;\n      var restParam1 = hasRestParam(signature1.params);\n      var restParam2 = hasRestParam(signature2.params);\n\n      return restParam1\n          ? restParam2 ? (len1 === len2) : (len2 >= len1)\n          : restParam2 ? (len1 >= len2)  : (len1 === len2)\n    }\n\n    /**\n     * Create a typed function\n     * @param {String} name               The name for the typed function\n     * @param {Object.<string, function>} signaturesMap\n     *                                    An object with one or\n     *                                    multiple signatures as key, and the\n     *                                    function corresponding to the\n     *                                    signature as value.\n     * @return {function}  Returns the created typed function.\n     */\n    function createTypedFunction(name, signaturesMap) {\n      if (Object.keys(signaturesMap).length === 0) {\n        throw new SyntaxError('No signatures provided');\n      }\n\n      // parse the signatures, and check for conflicts\n      var parsedSignatures = [];\n      Object.keys(signaturesMap)\n          .map(function (signature) {\n            return parseSignature(signature, signaturesMap[signature], typed.conversions);\n          })\n          .filter(notNull)\n          .forEach(function (parsedSignature) {\n            // check whether this parameter conflicts with already parsed signatures\n            var conflictingSignature = findInArray(parsedSignatures, function (s) {\n              return hasConflictingParams(s, parsedSignature)\n            });\n            if (conflictingSignature) {\n              throw new TypeError('Conflicting signatures \"' +\n                  stringifyParams(conflictingSignature.params) + '\" and \"' +\n                  stringifyParams(parsedSignature.params) + '\".');\n            }\n\n            parsedSignatures.push(parsedSignature);\n          });\n\n      // split and filter the types of the signatures, and then order them\n      var signatures = flatMap(parsedSignatures, function (parsedSignature) {\n        var params = parsedSignature ? splitParams(parsedSignature.params, false) : []\n\n        return params.map(function (params) {\n          return {\n            params: params,\n            fn: parsedSignature.fn\n          };\n        });\n      }).filter(notNull);\n\n      signatures.sort(compareSignatures);\n\n      // we create a highly optimized checks for the first couple of signatures with max 2 arguments\n      var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);\n      var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);\n      var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);\n      var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);\n      var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);\n      var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);\n      var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;\n\n      // compile the tests\n      var tests = signatures.map(function (signature) {\n        return compileTests(signature.params);\n      });\n\n      var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;\n      var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;\n      var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;\n      var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;\n      var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;\n      var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;\n\n      var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;\n      var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;\n      var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;\n      var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;\n      var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;\n      var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;\n\n      // compile the functions\n      var fns = signatures.map(function(signature) {\n        return compileArgsPreprocessing(signature.params, signature.fn);\n      });\n\n      var fn0 = ok0 ? fns[0] : undef;\n      var fn1 = ok1 ? fns[1] : undef;\n      var fn2 = ok2 ? fns[2] : undef;\n      var fn3 = ok3 ? fns[3] : undef;\n      var fn4 = ok4 ? fns[4] : undef;\n      var fn5 = ok5 ? fns[5] : undef;\n\n      var len0 = ok0 ? signatures[0].params.length : -1;\n      var len1 = ok1 ? signatures[1].params.length : -1;\n      var len2 = ok2 ? signatures[2].params.length : -1;\n      var len3 = ok3 ? signatures[3].params.length : -1;\n      var len4 = ok4 ? signatures[4].params.length : -1;\n      var len5 = ok5 ? signatures[5].params.length : -1;\n\n      // simple and generic, but also slow\n      var iStart = allOk ? 6 : 0;\n      var iEnd = signatures.length;\n      var generic = function generic() {\n        'use strict';\n\n        for (var i = iStart; i < iEnd; i++) {\n          if (tests[i](arguments)) {\n            return fns[i].apply(this, arguments);\n          }\n        }\n\n        throw createError(name, arguments, signatures);\n      }\n\n      // create the typed function\n      // fast, specialized version. Falls back to the slower, generic one if needed\n      var fn = function fn(arg0, arg1) {\n        'use strict';\n\n        if (arguments.length === len0 && test00(arg0) && test01(arg1)) { return fn0.apply(fn, arguments); }\n        if (arguments.length === len1 && test10(arg0) && test11(arg1)) { return fn1.apply(fn, arguments); }\n        if (arguments.length === len2 && test20(arg0) && test21(arg1)) { return fn2.apply(fn, arguments); }\n        if (arguments.length === len3 && test30(arg0) && test31(arg1)) { return fn3.apply(fn, arguments); }\n        if (arguments.length === len4 && test40(arg0) && test41(arg1)) { return fn4.apply(fn, arguments); }\n        if (arguments.length === len5 && test50(arg0) && test51(arg1)) { return fn5.apply(fn, arguments); }\n\n        return generic.apply(fn, arguments);\n      }\n\n      // attach name the typed function\n      try {\n        Object.defineProperty(fn, 'name', {value: name});\n      }\n      catch (err) {\n        // old browsers do not support Object.defineProperty and some don't support setting the name property\n        // the function name is not essential for the functioning, it's mostly useful for debugging,\n        // so it's fine to have unnamed functions.\n      }\n\n      // attach signatures to the function\n      fn.signatures = createSignaturesMap(signatures);\n\n      return fn;\n    }\n\n    /**\n     * Test whether a type should be NOT be ignored\n     * @param {string} typeName\n     * @return {boolean}\n     */\n    function notIgnore(typeName) {\n      return typed.ignore.indexOf(typeName) === -1;\n    }\n\n    /**\n     * trim a string\n     * @param {string} str\n     * @return {string}\n     */\n    function trim(str) {\n      return str.trim();\n    }\n\n    /**\n     * Test whether a string is not empty\n     * @param {string} str\n     * @return {boolean}\n     */\n    function notEmpty(str) {\n      return !!str;\n    }\n\n    /**\n     * test whether a value is not strict equal to null\n     * @param {*} value\n     * @return {boolean}\n     */\n    function notNull(value) {\n      return value !== null;\n    }\n\n    /**\n     * Test whether a parameter has no types defined\n     * @param {Param} param\n     * @return {boolean}\n     */\n    function isInvalidParam (param) {\n      return param.types.length === 0;\n    }\n\n    /**\n     * Return all but the last items of an array\n     * @param {Array} arr\n     * @return {Array}\n     */\n    function initial(arr) {\n      return arr.slice(0, arr.length - 1);\n    }\n\n    /**\n     * return the last item of an array\n     * @param {Array} arr\n     * @return {*}\n     */\n    function last(arr) {\n      return arr[arr.length - 1];\n    }\n\n    /**\n     * Slice an array or function Arguments\n     * @param {Array | Arguments | IArguments} arr\n     * @param {number} start\n     * @param {number} [end]\n     * @return {Array}\n     */\n    function slice(arr, start, end) {\n      return Array.prototype.slice.call(arr, start, end);\n    }\n\n    /**\n     * Test whether an array contains some item\n     * @param {Array} array\n     * @param {*} item\n     * @return {boolean} Returns true if array contains item, false if not.\n     */\n    function contains(array, item) {\n      return array.indexOf(item) !== -1;\n    }\n\n    /**\n     * Test whether two arrays have overlapping items\n     * @param {Array} array1\n     * @param {Array} array2\n     * @return {boolean} Returns true when at least one item exists in both arrays\n     */\n    function hasOverlap(array1, array2) {\n      for (var i = 0; i < array1.length; i++) {\n        if (contains(array2, array1[i])) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Return the first item from an array for which test(arr[i]) returns true\n     * @param {Array} arr\n     * @param {function} test\n     * @return {* | undefined} Returns the first matching item\n     *                         or undefined when there is no match\n     */\n    function findInArray(arr, test) {\n      for (var i = 0; i < arr.length; i++) {\n        if (test(arr[i])) {\n          return arr[i];\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * Filter unique items of an array with strings\n     * @param {string[]} arr\n     * @return {string[]}\n     */\n    function uniq(arr) {\n      var entries = {}\n      for (var i = 0; i < arr.length; i++) {\n        entries[arr[i]] = true;\n      }\n      return Object.keys(entries);\n    }\n\n    /**\n     * Flat map the result invoking a callback for every item in an array.\n     * https://gist.github.com/samgiles/762ee337dff48623e729\n     * @param {Array} arr\n     * @param {function} callback\n     * @return {Array}\n     */\n    function flatMap(arr, callback) {\n      return Array.prototype.concat.apply([], arr.map(callback));\n    }\n\n    /**\n     * Retrieve the function name from a set of typed functions,\n     * and check whether the name of all functions match (if given)\n     * @param {function[]} fns\n     */\n    function getName (fns) {\n      var name = '';\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // check whether the names are the same when defined\n        if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {\n          if (name === '') {\n            name = fn.name;\n          }\n          else if (name !== fn.name) {\n            var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');\n            err.data = {\n              actual: fn.name,\n              expected: name\n            };\n            throw err;\n          }\n        }\n      }\n\n      return name;\n    }\n\n    // extract and merge all signatures of a list with typed functions\n    function extractSignatures(fns) {\n      var err;\n      var signaturesMap = {};\n\n      function validateUnique(_signature, _fn) {\n        if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {\n          err = new Error('Signature \"' + _signature + '\" is defined twice');\n          err.data = {signature: _signature};\n          throw err;\n          // else: both signatures point to the same function, that's fine\n        }\n      }\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // test whether this is a typed-function\n        if (typeof fn.signatures === 'object') {\n          // merge the signatures\n          for (var signature in fn.signatures) {\n            if (fn.signatures.hasOwnProperty(signature)) {\n              validateUnique(signature, fn.signatures[signature]);\n              signaturesMap[signature] = fn.signatures[signature];\n            }\n          }\n        }\n        else if (typeof fn.signature === 'string') {\n          validateUnique(fn.signature, fn);\n          signaturesMap[fn.signature] = fn;\n        }\n        else {\n          err = new TypeError('Function is no typed-function (index: ' + i + ')');\n          err.data = {index: i};\n          throw err;\n        }\n      }\n\n      return signaturesMap;\n    }\n\n    typed = createTypedFunction('typed', {\n      'string, Object': createTypedFunction,\n      'Object': function (signaturesMap) {\n        // find existing name\n        var fns = [];\n        for (var signature in signaturesMap) {\n          if (signaturesMap.hasOwnProperty(signature)) {\n            fns.push(signaturesMap[signature]);\n          }\n        }\n        var name = getName(fns);\n        return createTypedFunction(name, signaturesMap);\n      },\n      '...Function': function (fns) {\n        return createTypedFunction(getName(fns), extractSignatures(fns));\n      },\n      'string, ...Function': function (name, fns) {\n        return createTypedFunction(name, extractSignatures(fns));\n      }\n    });\n\n    typed.create = create;\n    typed.types = _types;\n    typed.conversions = _conversions;\n    typed.ignore = _ignore;\n    typed.convert = convert;\n    typed.find = find;\n\n    /**\n     * add a type\n     * @param {{name: string, test: function}} type\n     * @param {boolean} [beforeObjectTest=true]\n     *                          If true, the new test will be inserted before\n     *                          the test with name 'Object' (if any), since\n     *                          tests for Object match Array and classes too.\n     */\n    typed.addType = function (type, beforeObjectTest) {\n      if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {\n        throw new TypeError('Object with properties {name: string, test: function} expected');\n      }\n\n      if (beforeObjectTest !== false) {\n        for (var i = 0; i < typed.types.length; i++) {\n          if (typed.types[i].name === 'Object') {\n            typed.types.splice(i, 0, type);\n            return\n          }\n        }\n      }\n\n      typed.types.push(type);\n    };\n\n    // add a conversion\n    typed.addConversion = function (conversion) {\n      if (!conversion\n          || typeof conversion.from !== 'string'\n          || typeof conversion.to !== 'string'\n          || typeof conversion.convert !== 'function') {\n        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');\n      }\n\n      typed.conversions.push(conversion);\n    };\n\n    return typed;\n  }\n\n  return create();\n}));\n\n};"],
"names":["shadow$provide","global","require","module","exports","root","factory","define","amd","typed","ok","notOk","undef","create","findTypeByName","typeName","entry","findInArray","types","name","anyType","hint","toLowerCase","TypeError","findTypeName","value","test","stringifyParams","params","map","param","typeNames","getTypeName","restParam","join","parseParam","conversions","indexOf","split","length","slice","trim","filter","notEmpty","notIgnore","matchingConversions","filterConversions","exactTypes","type","typeIndex","conversion","conversionIndex","convertibleTypes","from","concat","parseSignature","signature","fn","index","array","parsedParam","SyntaxError","some","isInvalidParam","hasRestParam","hasConversions","compileTest","test0","test1","or","x","tests","i","compileTests","varIndex","lastTest","testArgs","args","getParamAtIndex","arr","getExpectedTypeNames","excludeConversions","isExactType","undefined","mergeExpectedParams","signatures","uniq","flatMap","createError","_name","nextMatchingDefs","matchingSignatures","expected","actualType","err","data","category","actual","lengths","Infinity","Math","min","apply","maxLength","max","expectedLength","getLowestTypeIndex","getLowestConversionIndex","compareSignatures","signature1","signature2","len","c","param1","param2","matches","forEach","to","Object","keys","compileArgsPreprocessing","fnConvert","compiledConversions","compileArgConversion","last","arguments","fnPreprocess","offset","Array","prototype","call","start","end","push","convert","convertArg","arg","conversion0","conversion1","createSignaturesMap","signaturesMap","splitParams","ignoreConversionTypes","_splitParams","filteredTypes","typeGroups","typeGroup","splittedParams","createTypedFunction","parsedSignatures","notNull","parsedSignature","conflictingSignature","s","ii","typesNames1","typesNames2","array1","array2","item","len1","len2","restParam1","restParam2","sort","ok0","ok1","ok2","ok3","ok4","ok5","allOk","test00","test10","test20","test30","test40","test50","test01","test11","test21","test31","test41","test51","fns","fn0","fn1","fn2","fn3","fn4","fn5","len0","len3","len4","len5","iStart","iEnd","generic","arg0","arg1","defineProperty","ignore","str","entries","callback","getName","Error","extractSignatures","validateUnique","_signature","_fn","hasOwnProperty","_types","isArray","Date","RegExp","constructor","_ignore","_conversions","...Function","string, ...Function","find","match","addType","typed.addType","beforeObjectTest","splice","addConversion","typed.addConversion"]
}
