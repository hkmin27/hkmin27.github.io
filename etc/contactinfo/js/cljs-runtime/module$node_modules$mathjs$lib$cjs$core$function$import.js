shadow$provide.module$node_modules$mathjs$lib$cjs$core$function$import=function(global,require,module,exports){function _defineProperty(obj,key,value){key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value;return obj}function _typeof(obj$jscomp$0){"@babel/helpers - typeof";_typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===
Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};return _typeof(obj$jscomp$0)}Object.defineProperty(exports,"__esModule",{value:!0});exports.importFactory=function(typed,load,math,importedFactories){function _import(name,value,options){options.wrap&&"function"===typeof value&&(value=_wrap(value));"function"===typeof value&&"string"===typeof value.signature&&(value=typed(name,_defineProperty({},value.signature,value)));if(isTypedFunction(math[name])&&isTypedFunction(value))value=options.override?
typed(name,value.signatures):typed(math[name],value),math[name]=value,delete importedFactories[name],_importTransform(name,value),math.emit("import",name,function(){return value});else if(void 0===math[name]||options.override)math[name]=value,delete importedFactories[name],_importTransform(name,value),math.emit("import",name,function(){return value});else if(!options.silent)throw Error('Cannot import "'+name+'": already exists');}function _importTransform(name,value){value&&"function"===typeof value.transform?
(math.expression.transform[name]=value.transform,allowedInExpressions(name)&&(math.expression.mathWithTransform[name]=value.transform)):(delete math.expression.transform[name],allowedInExpressions(name)&&(math.expression.mathWithTransform[name]=value))}function _deleteTransform(name){delete math.expression.transform[name];allowedInExpressions(name)?math.expression.mathWithTransform[name]=math[name]:delete math.expression.mathWithTransform[name]}function _wrap(fn){var wrapper=function(){for(var args=
[],i=0,len=arguments.length;i<len;i++){var arg=arguments[i];args[i]=arg&&arg.valueOf()}return fn.apply(math,args)};fn.transform&&(wrapper.transform=fn.transform);return wrapper}function _importFactory(factory,options){var name=2<arguments.length&&void 0!==arguments[2]?arguments[2]:factory.fn;if((0,_array.contains)(name,"."))throw Error("Factory name should not contain a nested path. Name: "+JSON.stringify(name));var namespace=isTransformFunctionFactory(factory)?math.expression.transform:math,existingTransform=
name in math.expression.transform,existing=(0,_object.hasOwnProperty)(namespace,name)?namespace[name]:void 0,resolver=function(){var dependencies={};factory.dependencies.map(_factory.stripOptionalNotation).forEach(function(dependency){if((0,_array.contains)(dependency,"."))throw Error("Factory dependency should not contain a nested path. Name: "+JSON.stringify(dependency));"math"===dependency?dependencies.math=math:"mathWithTransform"===dependency?dependencies.mathWithTransform=math.expression.mathWithTransform:
"classes"===dependency?dependencies.classes=math:dependencies[dependency]=math[dependency]});var instance=factory(dependencies);if(instance&&"function"===typeof instance.transform)throw Error('Transforms cannot be attached to factory functions. Please create a separate function for it with exports.path\x3d"expression.transform"');if(void 0===existing||options.override)return instance;if(isTypedFunction(existing)&&isTypedFunction(instance))return typed(existing,instance);if(options.silent)return existing;
throw Error('Cannot import "'+name+'": already exists');};factory.meta&&!1===factory.meta.lazy?namespace[name]=resolver():(0,_object.lazy)(namespace,name,resolver);existing&&existingTransform?_deleteTransform(name):(isTransformFunctionFactory(factory)||factoryAllowedInExpressions(factory))&&(0,_object.lazy)(math.expression.mathWithTransform,name,function(){return namespace[name]});importedFactories[name]=factory;math.emit("import",name,resolver)}function isSupportedType(object){return"function"===
typeof object||"number"===typeof object||"string"===typeof object||"boolean"===typeof object||null===object||(0,_is.isUnit)(object)||(0,_is.isComplex)(object)||(0,_is.isBigNumber)(object)||(0,_is.isFraction)(object)||(0,_is.isMatrix)(object)||Array.isArray(object)}function isTypedFunction(fn){return"function"===typeof fn&&"object"===_typeof(fn.signatures)}function allowedInExpressions(name){return!(0,_object.hasOwnProperty)(unsafe,name)}function factoryAllowedInExpressions(factory){return-1===factory.fn.indexOf(".")&&
!(0,_object.hasOwnProperty)(unsafe,factory.fn)&&(!factory.meta||!factory.meta.isClass)}function isTransformFunctionFactory(factory){return void 0!==factory&&void 0!==factory.meta&&!0===factory.meta.isTransformFunction||!1}var unsafe={expression:!0,type:!0,docs:!0,error:!0,json:!0,chain:!0};return function(functions,options){function flattenImports(flatValues,value,name){if(Array.isArray(value))value.forEach(function(item){return flattenImports(flatValues,item)});else if("object"===_typeof(value))for(var _name in value)(0,
_object.hasOwnProperty)(value,_name)&&flattenImports(flatValues,value[_name],_name);else if((0,_factory.isFactory)(value)||void 0!==name){name=(0,_factory.isFactory)(value)?isTransformFunctionFactory(value)?value.fn+".transform":value.fn:name;if((0,_object.hasOwnProperty)(flatValues,name)&&flatValues[name]!==value&&!options.silent)throw Error('Cannot import "'+name+'" twice');flatValues[name]=value}else if(!options.silent)throw new TypeError("Factory, Object, or Array expected");}var num=arguments.length;
if(1!==num&&2!==num)throw new _ArgumentsError.ArgumentsError("import",num,1,2);options||(options={});num={};flattenImports(num,functions);for(var name$jscomp$0 in num)if((0,_object.hasOwnProperty)(num,name$jscomp$0)){var value$jscomp$0=num[name$jscomp$0];if((0,_factory.isFactory)(value$jscomp$0))_importFactory(value$jscomp$0,options);else if(isSupportedType(value$jscomp$0))_import(name$jscomp$0,value$jscomp$0,options);else if(!options.silent)throw new TypeError("Factory, Object, or Array expected");
}}};var _is=require("module$node_modules$mathjs$lib$cjs$utils$is"),_factory=require("module$node_modules$mathjs$lib$cjs$utils$factory"),_object=require("module$node_modules$mathjs$lib$cjs$utils$object"),_array=require("module$node_modules$mathjs$lib$cjs$utils$array"),_ArgumentsError=require("module$node_modules$mathjs$lib$cjs$error$ArgumentsError")}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$core$function$import.js.map
