shadow$provide.module$node_modules$mathjs$lib$cjs$function$algebra$simplify$util=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createUtil=void 0;var _is=require("module$node_modules$mathjs$lib$cjs$utils$is");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");var _object=require("module$node_modules$mathjs$lib$cjs$utils$object");require=(0,global.factory)("simplifyUtil",["FunctionNode","OperatorNode","SymbolNode"],function(_ref){function isAssociative(node,
context){if(!(0,_is.isOperatorNode)(node))return!1;node=node.fn.toString();return context&&(0,_object.hasOwnProperty)(context,node)&&(0,_object.hasOwnProperty)(context[node],"associative")?context[node].associative:associative[node]||!1}function flatten(node){if(!node.args||0===node.args.length)return node;node.args=allChildren(node);for(var i=0;i<node.args.length;i++)flatten(node.args[i])}function allChildren(node$jscomp$0){var children=[],findChildren=function findChildren(node){for(var i=0;i<node.args.length;i++){var child=
node.args[i];(0,_is.isOperatorNode)(child)&&op===child.op?findChildren(child):children.push(child)}};if(isAssociative(node$jscomp$0)){var op=node$jscomp$0.op;findChildren(node$jscomp$0);return children}return node$jscomp$0.args}function unflattenr(node){if(node.args&&0!==node.args.length){for(var makeNode=createMakeNodeFunction(node),l=node.args.length,i=0;i<l;i++)unflattenr(node.args[i]);if(2<l&&isAssociative(node)){for(l=node.args.pop();0<node.args.length;)l=makeNode([node.args.pop(),l]);node.args=
l.args}}}function unflattenl(node){if(node.args&&0!==node.args.length){for(var makeNode=createMakeNodeFunction(node),l=node.args.length,i=0;i<l;i++)unflattenl(node.args[i]);if(2<l&&isAssociative(node)){for(l=node.args.shift();0<node.args.length;)l=makeNode([l,node.args.shift()]);node.args=l.args}}}function createMakeNodeFunction(node){return(0,_is.isOperatorNode)(node)?function(args){try{return new OperatorNode(node.op,node.fn,args,node.implicit)}catch(err){return console.error(err),[]}}:function(args){return new FunctionNode(new SymbolNode(node.name),
args)}}var FunctionNode=_ref.FunctionNode,OperatorNode=_ref.OperatorNode,SymbolNode=_ref.SymbolNode,commutative={add:!0,multiply:!0},associative={add:!0,multiply:!0};return{createMakeNodeFunction:createMakeNodeFunction,isCommutative:function(node,context){if(!(0,_is.isOperatorNode)(node))return!0;node=node.fn.toString();return context&&(0,_object.hasOwnProperty)(context,node)&&(0,_object.hasOwnProperty)(context[node],"commutative")?context[node].commutative:commutative[node]||!1},isAssociative:isAssociative,
flatten:flatten,allChildren:allChildren,unflattenr:unflattenr,unflattenl:unflattenl}});exports.createUtil=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$function$algebra$simplify$util.js.map
