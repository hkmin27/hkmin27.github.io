{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$type$matrix$Range.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/type/matrix/Range.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$type$matrix$Range\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRangeClass = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _number = require(\"../../utils/number.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar name = 'Range';\nvar dependencies = [];\nvar createRangeClass = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function () {\n  /**\n   * Create a range. A range has a start, step, and end, and contains functions\n   * to iterate over the range.\n   *\n   * A range can be constructed as:\n   *\n   *     const range = new Range(start, end)\n   *     const range = new Range(start, end, step)\n   *\n   * To get the result of the range:\n   *     range.forEach(function (x) {\n   *         console.log(x)\n   *     })\n   *     range.map(function (x) {\n   *         return math.sin(x)\n   *     })\n   *     range.toArray()\n   *\n   * Example usage:\n   *\n   *     const c = new Range(2, 6)       // 2:1:5\n   *     c.toArray()                     // [2, 3, 4, 5]\n   *     const d = new Range(2, -3, -1)  // 2:-1:-2\n   *     d.toArray()                     // [2, 1, 0, -1, -2]\n   *\n   * @class Range\n   * @constructor Range\n   * @param {number} start  included lower bound\n   * @param {number} end    excluded upper bound\n   * @param {number} [step] step size, default value is 1\n   */\n  function Range(start, end, step) {\n    if (!(this instanceof Range)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    var hasStart = start !== null && start !== undefined;\n    var hasEnd = end !== null && end !== undefined;\n    var hasStep = step !== null && step !== undefined;\n\n    if (hasStart) {\n      if ((0, _is.isBigNumber)(start)) {\n        start = start.toNumber();\n      } else if (typeof start !== 'number') {\n        throw new TypeError('Parameter start must be a number');\n      }\n    }\n\n    if (hasEnd) {\n      if ((0, _is.isBigNumber)(end)) {\n        end = end.toNumber();\n      } else if (typeof end !== 'number') {\n        throw new TypeError('Parameter end must be a number');\n      }\n    }\n\n    if (hasStep) {\n      if ((0, _is.isBigNumber)(step)) {\n        step = step.toNumber();\n      } else if (typeof step !== 'number') {\n        throw new TypeError('Parameter step must be a number');\n      }\n    }\n\n    this.start = hasStart ? parseFloat(start) : 0;\n    this.end = hasEnd ? parseFloat(end) : 0;\n    this.step = hasStep ? parseFloat(step) : 1;\n  }\n  /**\n   * Attach type information\n   */\n\n\n  Range.prototype.type = 'Range';\n  Range.prototype.isRange = true;\n  /**\n   * Parse a string into a range,\n   * The string contains the start, optional step, and end, separated by a colon.\n   * If the string does not contain a valid range, null is returned.\n   * For example str='0:2:11'.\n   * @memberof Range\n   * @param {string} str\n   * @return {Range | null} range\n   */\n\n  Range.parse = function (str) {\n    if (typeof str !== 'string') {\n      return null;\n    }\n\n    var args = str.split(':');\n    var nums = args.map(function (arg) {\n      return parseFloat(arg);\n    });\n    var invalid = nums.some(function (num) {\n      return isNaN(num);\n    });\n\n    if (invalid) {\n      return null;\n    }\n\n    switch (nums.length) {\n      case 2:\n        return new Range(nums[0], nums[1]);\n\n      case 3:\n        return new Range(nums[0], nums[2], nums[1]);\n\n      default:\n        return null;\n    }\n  };\n  /**\n   * Create a clone of the range\n   * @return {Range} clone\n   */\n\n\n  Range.prototype.clone = function () {\n    return new Range(this.start, this.end, this.step);\n  };\n  /**\n   * Retrieve the size of the range.\n   * Returns an array containing one number, the number of elements in the range.\n   * @memberof Range\n   * @returns {number[]} size\n   */\n\n\n  Range.prototype.size = function () {\n    var len = 0;\n    var start = this.start;\n    var step = this.step;\n    var end = this.end;\n    var diff = end - start;\n\n    if ((0, _number.sign)(step) === (0, _number.sign)(diff)) {\n      len = Math.ceil(diff / step);\n    } else if (diff === 0) {\n      len = 0;\n    }\n\n    if (isNaN(len)) {\n      len = 0;\n    }\n\n    return [len];\n  };\n  /**\n   * Calculate the minimum value in the range\n   * @memberof Range\n   * @return {number | undefined} min\n   */\n\n\n  Range.prototype.min = function () {\n    var size = this.size()[0];\n\n    if (size > 0) {\n      if (this.step > 0) {\n        // positive step\n        return this.start;\n      } else {\n        // negative step\n        return this.start + (size - 1) * this.step;\n      }\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * Calculate the maximum value in the range\n   * @memberof Range\n   * @return {number | undefined} max\n   */\n\n\n  Range.prototype.max = function () {\n    var size = this.size()[0];\n\n    if (size > 0) {\n      if (this.step > 0) {\n        // positive step\n        return this.start + (size - 1) * this.step;\n      } else {\n        // negative step\n        return this.start;\n      }\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * Execute a callback function for each value in the range.\n   * @memberof Range\n   * @param {function} callback   The callback method is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Range being traversed.\n   */\n\n\n  Range.prototype.forEach = function (callback) {\n    var x = this.start;\n    var step = this.step;\n    var end = this.end;\n    var i = 0;\n\n    if (step > 0) {\n      while (x < end) {\n        callback(x, [i], this);\n        x += step;\n        i++;\n      }\n    } else if (step < 0) {\n      while (x > end) {\n        callback(x, [i], this);\n        x += step;\n        i++;\n      }\n    }\n  };\n  /**\n   * Execute a callback function for each value in the Range, and return the\n   * results as an array\n   * @memberof Range\n   * @param {function} callback   The callback method is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   * @returns {Array} array\n   */\n\n\n  Range.prototype.map = function (callback) {\n    var array = [];\n    this.forEach(function (value, index, obj) {\n      array[index[0]] = callback(value, index, obj);\n    });\n    return array;\n  };\n  /**\n   * Create an Array with a copy of the Ranges data\n   * @memberof Range\n   * @returns {Array} array\n   */\n\n\n  Range.prototype.toArray = function () {\n    var array = [];\n    this.forEach(function (value, index) {\n      array[index[0]] = value;\n    });\n    return array;\n  };\n  /**\n   * Get the primitive value of the Range, a one dimensional array\n   * @memberof Range\n   * @returns {Array} array\n   */\n\n\n  Range.prototype.valueOf = function () {\n    // TODO: implement a caching mechanism for range.valueOf()\n    return this.toArray();\n  };\n  /**\n   * Get a string representation of the range, with optional formatting options.\n   * Output is formatted as 'start:step:end', for example '2:6' or '0:0.2:11'\n   * @memberof Range\n   * @param {Object | number | function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n\n  Range.prototype.format = function (options) {\n    var str = (0, _number.format)(this.start, options);\n\n    if (this.step !== 1) {\n      str += ':' + (0, _number.format)(this.step, options);\n    }\n\n    str += ':' + (0, _number.format)(this.end, options);\n    return str;\n  };\n  /**\n   * Get a string representation of the range.\n   * @memberof Range\n   * @returns {string}\n   */\n\n\n  Range.prototype.toString = function () {\n    return this.format();\n  };\n  /**\n   * Get a JSON representation of the range\n   * @memberof Range\n   * @returns {Object} Returns a JSON object structured as:\n   *                   `{\"mathjs\": \"Range\", \"start\": 2, \"end\": 4, \"step\": 1}`\n   */\n\n\n  Range.prototype.toJSON = function () {\n    return {\n      mathjs: 'Range',\n      start: this.start,\n      end: this.end,\n      step: this.step\n    };\n  };\n  /**\n   * Instantiate a Range from a JSON object\n   * @memberof Range\n   * @param {Object} json A JSON object structured as:\n   *                      `{\"mathjs\": \"Range\", \"start\": 2, \"end\": 4, \"step\": 1}`\n   * @return {Range}\n   */\n\n\n  Range.fromJSON = function (json) {\n    return new Range(json.start, json.end, json.step);\n  };\n\n  return Range;\n}, {\n  isClass: true\n});\nexports.createRangeClass = createRangeClass;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","createRangeClass","_is","_number","_factory","factory","name","dependencies","Range","start","end","step","SyntaxError","hasStart","undefined","hasEnd","hasStep","isBigNumber","toNumber","TypeError","parseFloat","prototype","type","isRange","parse","Range.parse","str","nums","split","args","map","arg","some","invalid","num","isNaN","length","clone","Range.prototype.clone","size","Range.prototype.size","len","diff","sign","Math","ceil","min","Range.prototype.min","max","Range.prototype.max","forEach","Range.prototype.forEach","callback","x","i","Range.prototype.map","array","index","obj","toArray","Range.prototype.toArray","valueOf","Range.prototype.valueOf","format","Range.prototype.format","options","toString","Range.prototype.toString","toJSON","Range.prototype.toJSON","mathjs","fromJSON","Range.fromJSON","json","isClass"]
}
