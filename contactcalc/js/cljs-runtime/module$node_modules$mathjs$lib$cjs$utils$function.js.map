{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$utils$function.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/utils/function.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$utils$function\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.memoize = memoize;\nexports.memoizeCompare = memoizeCompare;\nexports.maxArgumentCount = maxArgumentCount;\n\nvar _lruQueue = require(\"./lruQueue.js\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Memoize a given function by caching the computed result.\n * The cache of a memoized function can be cleared by deleting the `cache`\n * property of the function.\n *\n * @param {function} fn                     The function to be memoized.\n *                                          Must be a pure function.\n * @param {Object} [options]\n * @param {function(args: Array): string} [options.hasher]\n *    A custom hash builder. Is JSON.stringify by default.\n * @param {number | undefined} [options.limit]\n *    Maximum number of values that may be cached. Undefined indicates\n *    unlimited (default)\n * @return {function}                       Returns the memoized function\n */\nfunction memoize(fn) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      hasher = _ref.hasher,\n      limit = _ref.limit;\n\n  limit = limit == null ? Number.POSITIVE_INFINITY : limit;\n  hasher = hasher == null ? JSON.stringify : hasher;\n  return function memoize() {\n    if (_typeof(memoize.cache) !== 'object') {\n      memoize.cache = {\n        values: new Map(),\n        lru: (0, _lruQueue.lruQueue)(limit || Number.POSITIVE_INFINITY)\n      };\n    }\n\n    var args = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    var hash = hasher(args);\n\n    if (memoize.cache.values.has(hash)) {\n      memoize.cache.lru.hit(hash);\n      return memoize.cache.values.get(hash);\n    }\n\n    var newVal = fn.apply(fn, args);\n    memoize.cache.values.set(hash, newVal);\n    memoize.cache.values[\"delete\"](memoize.cache.lru.hit(hash));\n    return newVal;\n  };\n}\n/**\n * Memoize a given function by caching all results and the arguments,\n * and comparing against the arguments of previous results before\n * executing again.\n * This is less performant than `memoize` which calculates a hash,\n * which is very fast to compare. Use `memoizeCompare` only when it is\n * not possible to create a unique serializable hash from the function\n * arguments.\n * The isEqual function must compare two sets of arguments\n * and return true when equal (can be a deep equality check for example).\n * @param {function} fn\n * @param {function(a: *, b: *) : boolean} isEqual\n * @returns {function}\n */\n\n\nfunction memoizeCompare(fn, isEqual) {\n  var memoize = function memoize() {\n    var args = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    for (var c = 0; c < memoize.cache.length; c++) {\n      var cached = memoize.cache[c];\n\n      if (isEqual(args, cached.args)) {\n        // TODO: move this cache entry to the top so recently used entries move up?\n        return cached.res;\n      }\n    }\n\n    var res = fn.apply(fn, args);\n    memoize.cache.unshift({\n      args: args,\n      res: res\n    });\n    return res;\n  };\n\n  memoize.cache = [];\n  return memoize;\n}\n/**\n * Find the maximum number of arguments expected by a typed function.\n * @param {function} fn   A typed function\n * @return {number} Returns the maximum number of expected arguments.\n *                  Returns -1 when no signatures where found on the function.\n */\n\n\nfunction maxArgumentCount(fn) {\n  return Object.keys(fn.signatures || {}).reduce(function (args, signature) {\n    var count = (signature.match(/,/g) || []).length + 1;\n    return Math.max(args, count);\n  }, -1);\n}\n};"],
"names":["shadow$provide","global","require","module","exports","_typeof","obj","Symbol","iterator","constructor","prototype","Object","defineProperty","value","memoize","fn","_ref","arguments","length","undefined","hasher","limit","Number","POSITIVE_INFINITY","JSON","stringify","cache","values","Map","lru","_lruQueue","lruQueue","args","i","hash","has","hit","get","newVal","apply","set","memoizeCompare","isEqual","c","cached","res","unshift","maxArgumentCount","keys","signatures","reduce","signature","count","match","Math","max"]
}
