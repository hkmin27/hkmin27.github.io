shadow$provide.module$node_modules$mathjs$lib$cjs$expression$node$IndexNode=function(global,require,module,exports){function _toConsumableArray(arr){var JSCompiler_temp=Array.isArray(arr)?_arrayLikeToArray(arr):void 0;JSCompiler_temp||(JSCompiler_temp="undefined"!==typeof Symbol&&Symbol.iterator in Object(arr)?Array.from(arr):void 0);if(!JSCompiler_temp)a:{if(arr){if("string"===typeof arr){JSCompiler_temp=_arrayLikeToArray(arr,void 0);break a}JSCompiler_temp=Object.prototype.toString.call(arr).slice(8,
-1);"Object"===JSCompiler_temp&&arr.constructor&&(JSCompiler_temp=arr.constructor.name);if("Map"===JSCompiler_temp||"Set"===JSCompiler_temp){JSCompiler_temp=Array.from(arr);break a}if("Arguments"===JSCompiler_temp||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(JSCompiler_temp)){JSCompiler_temp=_arrayLikeToArray(arr,void 0);break a}}JSCompiler_temp=void 0}if(!(arr=JSCompiler_temp))throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
return arr}function _arrayLikeToArray(arr,len){if(null==len||len>arr.length)len=arr.length;for(var i=0,arr2=Array(len);i<len;i++)arr2[i]=arr[i];return arr2}Object.defineProperty(exports,"__esModule",{value:!0});exports.createIndexNode=void 0;var _is=require("module$node_modules$mathjs$lib$cjs$utils$is"),_array=require("module$node_modules$mathjs$lib$cjs$utils$array"),_string=require("module$node_modules$mathjs$lib$cjs$utils$string");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");
var _customs=require("module$node_modules$mathjs$lib$cjs$utils$customs");require=(0,global.factory)("IndexNode",["Range","Node","size"],function(_ref){function IndexNode(dimensions,dotNotation){if(!(this instanceof IndexNode))throw new SyntaxError("Constructor must be called with the new operator");this.dimensions=dimensions;this.dotNotation=dotNotation||!1;if(!Array.isArray(dimensions)||!dimensions.every(_is.isNode))throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
if(this.dotNotation&&!this.isObjectProperty())throw Error("dotNotation only applicable for object properties");}function createRange(start,end,step){return new Range((0,_is.isBigNumber)(start)?start.toNumber():start,(0,_is.isBigNumber)(end)?end.toNumber():end,(0,_is.isBigNumber)(step)?step.toNumber():step)}var Range=_ref.Range,size=_ref.size;IndexNode.prototype=new _ref.Node;IndexNode.prototype.type="IndexNode";IndexNode.prototype.isIndexNode=!0;IndexNode.prototype._compile=function(math,argNames){var evalDimensions=
(0,_array.map)(this.dimensions,function(range,i){if((0,_is.isRangeNode)(range)){if(range.needsEnd()){var childArgNames=Object.create(argNames);childArgNames.end=!0;var evalStart=range.start._compile(math,childArgNames),evalEnd=range.end._compile(math,childArgNames),evalStep=range.step?range.step._compile(math,childArgNames):function(){return 1};return function(scope,args,context){var s=size(context).valueOf();args=Object.create(args);args.end=s[i];return createRange(evalStart(scope,args,context),
evalEnd(scope,args,context),evalStep(scope,args,context))}}var _evalStart=range.start._compile(math,argNames),_evalEnd=range.end._compile(math,argNames),_evalStep=range.step?range.step._compile(math,argNames):function(){return 1};return function(scope,args,context){return createRange(_evalStart(scope,args,context),_evalEnd(scope,args,context),_evalStep(scope,args,context))}}if((0,_is.isSymbolNode)(range)&&"end"===range.name){childArgNames=Object.create(argNames);childArgNames.end=!0;var evalRange=
range._compile(math,childArgNames);return function(scope,args,context){var s=size(context).valueOf();args=Object.create(args);args.end=s[i];return evalRange(scope,args,context)}}var _evalRange=range._compile(math,argNames);return function(scope,args,context){return _evalRange(scope,args,context)}}),index=(0,_customs.getSafeProperty)(math,"index");return function(scope,args,context){var dimensions=(0,_array.map)(evalDimensions,function(evalDimension){return evalDimension(scope,args,context)});return index.apply(void 0,
_toConsumableArray(dimensions))}};IndexNode.prototype.forEach=function(callback){for(var i=0;i<this.dimensions.length;i++)callback(this.dimensions[i],"dimensions["+i+"]",this)};IndexNode.prototype.map=function(callback){for(var dimensions=[],i=0;i<this.dimensions.length;i++)dimensions[i]=this._ifNode(callback(this.dimensions[i],"dimensions["+i+"]",this));return new IndexNode(dimensions,this.dotNotation)};IndexNode.prototype.clone=function(){return new IndexNode(this.dimensions.slice(0),this.dotNotation)};
IndexNode.prototype.isObjectProperty=function(){return 1===this.dimensions.length&&(0,_is.isConstantNode)(this.dimensions[0])&&"string"===typeof this.dimensions[0].value};IndexNode.prototype.getObjectProperty=function(){return this.isObjectProperty()?this.dimensions[0].value:null};IndexNode.prototype._toString=function(options){return this.dotNotation?"."+this.getObjectProperty():"["+this.dimensions.join(", ")+"]"};IndexNode.prototype.toJSON=function(){return{mathjs:"IndexNode",dimensions:this.dimensions,
dotNotation:this.dotNotation}};IndexNode.fromJSON=function(json){return new IndexNode(json.dimensions,json.dotNotation)};IndexNode.prototype.toHTML=function(options){options=[];for(var i=0;i<this.dimensions.length;i++)options[i]=this.dimensions[i].toHTML();return this.dotNotation?'\x3cspan class\x3d"math-operator math-accessor-operator"\x3e.\x3c/span\x3e\x3cspan class\x3d"math-symbol math-property"\x3e'+(0,_string.escape)(this.getObjectProperty())+"\x3c/span\x3e":'\x3cspan class\x3d"math-parenthesis math-square-parenthesis"\x3e[\x3c/span\x3e'+
options.join('\x3cspan class\x3d"math-separator"\x3e,\x3c/span\x3e')+'\x3cspan class\x3d"math-parenthesis math-square-parenthesis"\x3e]\x3c/span\x3e'};IndexNode.prototype._toTex=function(options){var dimensions=this.dimensions.map(function(range){return range.toTex(options)});return this.dotNotation?"."+this.getObjectProperty():"_{"+dimensions.join(",")+"}"};return IndexNode},{isClass:!0,isNode:!0});exports.createIndexNode=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$expression$node$IndexNode.js.map
