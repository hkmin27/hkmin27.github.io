shadow$provide.module$node_modules$mathjs$lib$cjs$function$algebra$simplify$simplifyCore=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createSimplifyCore=void 0;var _is=require("module$node_modules$mathjs$lib$cjs$utils$is");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");global=(0,global.factory)("simplifyCore","equal isZero add subtract multiply divide pow ConstantNode OperatorNode FunctionNode ParenthesisNode".split(" "),
function(_ref){function simplifyCore(node){if((0,_is.isOperatorNode)(node)&&node.isUnary()){var a0=simplifyCore(node.args[0]);if("+"===node.op)return a0;if("-"===node.op){if((0,_is.isOperatorNode)(a0)){if(a0.isUnary()&&"-"===a0.op)return a0.args[0];if(a0.isBinary()&&"subtract"===a0.fn)return new OperatorNode("-","subtract",[a0.args[1],a0.args[0]])}return new OperatorNode(node.op,node.fn,[a0])}}else if((0,_is.isOperatorNode)(node)&&node.isBinary()){a0=simplifyCore(node.args[0]);var a1=simplifyCore(node.args[1]);
if("+"===node.op){if((0,_is.isConstantNode)(a0)){if(isZero(a0.value))return a1;if((0,_is.isConstantNode)(a1))return new ConstantNode(add(a0.value,a1.value))}return(0,_is.isConstantNode)(a1)&&isZero(a1.value)?a0:(0,_is.isOperatorNode)(a1)&&a1.isUnary()&&"-"===a1.op?new OperatorNode("-","subtract",[a0,a1.args[0]]):new OperatorNode(node.op,node.fn,a1?[a0,a1]:[a0])}if("-"===node.op){if((0,_is.isConstantNode)(a0)&&a1){if((0,_is.isConstantNode)(a1))return new ConstantNode(subtract(a0.value,a1.value));if(isZero(a0.value))return new OperatorNode("-",
"unaryMinus",[a1])}if("subtract"===node.fn)return(0,_is.isConstantNode)(a1)&&isZero(a1.value)?a0:(0,_is.isOperatorNode)(a1)&&a1.isUnary()&&"-"===a1.op?simplifyCore(new OperatorNode("+","add",[a0,a1.args[0]])):new OperatorNode(node.op,node.fn,[a0,a1])}else{if("*"===node.op){if((0,_is.isConstantNode)(a0)){if(isZero(a0.value))return node0;if(equal(a0.value,1))return a1;if((0,_is.isConstantNode)(a1))return new ConstantNode(multiply(a0.value,a1.value))}if((0,_is.isConstantNode)(a1)){if(isZero(a1.value))return node0;
if(equal(a1.value,1))return a0;if((0,_is.isOperatorNode)(a0)&&a0.isBinary()&&a0.op===node.op){var a00=a0.args[0];if((0,_is.isConstantNode)(a00))return a1=new ConstantNode(multiply(a00.value,a1.value)),new OperatorNode(node.op,node.fn,[a1,a0.args[1]],node.implicit)}return new OperatorNode(node.op,node.fn,[a1,a0],node.implicit)}return new OperatorNode(node.op,node.fn,[a0,a1],node.implicit)}if("/"===node.op){if((0,_is.isConstantNode)(a0)){if(isZero(a0.value))return node0;if((0,_is.isConstantNode)(a1)&&
(equal(a1.value,1)||equal(a1.value,2)||equal(a1.value,4)))return new ConstantNode(divide(a0.value,a1.value))}return new OperatorNode(node.op,node.fn,[a0,a1])}if("^"===node.op){if((0,_is.isConstantNode)(a1)){if(isZero(a1.value))return node1;if(equal(a1.value,1))return a0;if((0,_is.isConstantNode)(a0))return new ConstantNode(pow(a0.value,a1.value));if((0,_is.isOperatorNode)(a0)&&a0.isBinary()&&"^"===a0.op&&(a00=a0.args[1],(0,_is.isConstantNode)(a00)))return new OperatorNode(node.op,node.fn,[a0.args[0],
new ConstantNode(multiply(a00.value,a1.value))])}return new OperatorNode(node.op,node.fn,[a0,a1])}}}else{if((0,_is.isParenthesisNode)(node))return node=simplifyCore(node.content),(0,_is.isParenthesisNode)(node)||(0,_is.isSymbolNode)(node)||(0,_is.isConstantNode)(node)?node:new ParenthesisNode(node);if((0,_is.isFunctionNode)(node))return a0=node.args.map(simplifyCore).map(function(arg){return(0,_is.isParenthesisNode)(arg)?arg.content:arg}),new FunctionNode(simplifyCore(node.fn),a0)}return node}var equal=
_ref.equal,isZero=_ref.isZero,add=_ref.add,subtract=_ref.subtract,multiply=_ref.multiply,divide=_ref.divide,pow=_ref.pow,ConstantNode=_ref.ConstantNode,OperatorNode=_ref.OperatorNode,FunctionNode=_ref.FunctionNode,ParenthesisNode=_ref.ParenthesisNode,node0=new ConstantNode(0),node1=new ConstantNode(1);return simplifyCore});exports.createSimplifyCore=global}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$function$algebra$simplify$simplifyCore.js.map
