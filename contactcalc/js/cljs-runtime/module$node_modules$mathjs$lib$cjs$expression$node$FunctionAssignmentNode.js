shadow$provide.module$node_modules$mathjs$lib$cjs$expression$node$FunctionAssignmentNode=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createFunctionAssignmentNode=void 0;var _is=require("module$node_modules$mathjs$lib$cjs$utils$is"),_keywords=require("module$node_modules$mathjs$lib$cjs$expression$keywords"),_string=require("module$node_modules$mathjs$lib$cjs$utils$string"),_array=require("module$node_modules$mathjs$lib$cjs$utils$array"),_latex=
require("module$node_modules$mathjs$lib$cjs$utils$latex"),_operators=require("module$node_modules$mathjs$lib$cjs$expression$operators"),_customs=require("module$node_modules$mathjs$lib$cjs$utils$customs");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");global=(0,global.factory)("FunctionAssignmentNode",["typed","Node"],function(_ref){function FunctionAssignmentNode(name,params,expr){if(!(this instanceof FunctionAssignmentNode))throw new SyntaxError("Constructor must be called with the new operator");
if("string"!==typeof name)throw new TypeError('String expected for parameter "name"');if(!Array.isArray(params))throw new TypeError('Array containing strings or objects expected for parameter "params"');if(!(0,_is.isNode)(expr))throw new TypeError('Node expected for parameter "expr"');if(name in _keywords.keywords)throw Error('Illegal function name, "'+name+'" is a reserved keyword');this.name=name;this.params=params.map(function(param){return param&&param.name||param});this.types=params.map(function(param){return param&&
param.type||"any"});this.expr=expr}function needParenthesis(node,parenthesis){var precedence=(0,_operators.getPrecedence)(node,parenthesis);node=(0,_operators.getPrecedence)(node.expr,parenthesis);return"all"===parenthesis||null!==node&&node<=precedence}var typed=_ref.typed;FunctionAssignmentNode.prototype=new _ref.Node;FunctionAssignmentNode.prototype.type="FunctionAssignmentNode";FunctionAssignmentNode.prototype.isFunctionAssignmentNode=!0;FunctionAssignmentNode.prototype._compile=function(math,
argNames){var childArgNames=Object.create(argNames);(0,_array.forEach)(this.params,function(param){childArgNames[param]=!0});var evalExpr=this.expr._compile(math,childArgNames),name=this.name,params=this.params,signature=(0,_array.join)(this.types,","),syntax=name+"("+(0,_array.join)(this.params,", ")+")";return function(scope,args,context){var signatures={};signatures[signature]=function(){for(var childArgs=Object.create(args),i=0;i<params.length;i++)childArgs[params[i]]=arguments[i];return evalExpr(scope,
childArgs,context)};signatures=typed(name,signatures);signatures.syntax=syntax;(0,_customs.setSafeProperty)(scope,name,signatures);return signatures}};FunctionAssignmentNode.prototype.forEach=function(callback){callback(this.expr,"expr",this)};FunctionAssignmentNode.prototype.map=function(callback){callback=this._ifNode(callback(this.expr,"expr",this));return new FunctionAssignmentNode(this.name,this.params.slice(0),callback)};FunctionAssignmentNode.prototype.clone=function(){return new FunctionAssignmentNode(this.name,
this.params.slice(0),this.expr)};FunctionAssignmentNode.prototype._toString=function(options){var parenthesis=options&&options.parenthesis?options.parenthesis:"keep";options=this.expr.toString(options);needParenthesis(this,parenthesis)&&(options="("+options+")");return this.name+"("+this.params.join(", ")+") \x3d "+options};FunctionAssignmentNode.prototype.toJSON=function(){var types=this.types;return{mathjs:"FunctionAssignmentNode",name:this.name,params:this.params.map(function(param,index){return{name:param,
type:types[index]}}),expr:this.expr}};FunctionAssignmentNode.fromJSON=function(json){return new FunctionAssignmentNode(json.name,json.params,json.expr)};FunctionAssignmentNode.prototype.toHTML=function(options){for(var parenthesis=options&&options.parenthesis?options.parenthesis:"keep",params=[],i=0;i<this.params.length;i++)params.push('\x3cspan class\x3d"math-symbol math-parameter"\x3e'+(0,_string.escape)(this.params[i])+"\x3c/span\x3e");options=this.expr.toHTML(options);needParenthesis(this,parenthesis)&&
(options='\x3cspan class\x3d"math-parenthesis math-round-parenthesis"\x3e(\x3c/span\x3e'+options+'\x3cspan class\x3d"math-parenthesis math-round-parenthesis"\x3e)\x3c/span\x3e');return'\x3cspan class\x3d"math-function"\x3e'+(0,_string.escape)(this.name)+'\x3c/span\x3e\x3cspan class\x3d"math-parenthesis math-round-parenthesis"\x3e(\x3c/span\x3e'+params.join('\x3cspan class\x3d"math-separator"\x3e,\x3c/span\x3e')+'\x3cspan class\x3d"math-parenthesis math-round-parenthesis"\x3e)\x3c/span\x3e\x3cspan class\x3d"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator"\x3e\x3d\x3c/span\x3e'+
options};FunctionAssignmentNode.prototype._toTex=function(options){var parenthesis=options&&options.parenthesis?options.parenthesis:"keep";options=this.expr.toTex(options);needParenthesis(this,parenthesis)&&(options="\\left(".concat(options,"\\right)"));return"\\mathrm{"+this.name+"}\\left("+this.params.map(_latex.toSymbol).join(",")+"\\right):\x3d"+options};return FunctionAssignmentNode},{isClass:!0,isNode:!0});exports.createFunctionAssignmentNode=global}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$expression$node$FunctionAssignmentNode.js.map
