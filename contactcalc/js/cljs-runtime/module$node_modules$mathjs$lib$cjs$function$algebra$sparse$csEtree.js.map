{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csEtree.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,kEAAA,CAAuF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG/HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,OAAR,CAWAA,QAAgB,CAACC,CAAD,CAAIC,GAAJ,CAAS,CAEvB,GAAI,CAACD,CAAL,CACE,MAAO,KAIT,KAAIE,OAASF,CAAEG,CAAAA,MAAf,CACIC,KAAOJ,CAAEK,CAAAA,IACTC,EAAAA,CAAQN,CAAEO,CAAAA,KAEd,KAAIC,EAAIF,CAAA,CAAM,CAAN,CACJG,EAAAA,CAAIH,CAAA,CAAM,CAAN,CAER,KAAII,OAAS,EAAb,CAGIC,EAAI,EAHR,CASIC,CAEJ,IAAIX,GAAJ,CAEE,IAAKW,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBJ,CAAhB,CAAmBI,CAAA,EAAnB,CACED,CAAA,CAPOF,CAOP,CAASG,CAAT,CAAA,CAAc,EAKlB,KAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBJ,CAApB,CAAuBI,CAAA,EAAvB,CAA4B,CAE1BH,MAAA,CAAOG,CAAP,CAAA,CAAY,EAEZF,EAAA,CAlBaG,CAkBb,CAAaD,CAAb,CAAA,CAAkB,EAElB,KAN0B,IAMHE,GAAKX,IAAA,CAAKS,CAAL,CAAS,CAAT,CANF,CAMeG,EAA3BZ,IAAAa,CAAKJ,CAALI,CAAd,CAAiDD,CAAjD,CAAqDD,EAArD,CAAyDC,CAAA,EAAzD,CAA8D,CAE5D,IAAIE,EAAIhB,MAAA,CAAOc,CAAP,CAIR,KAFAJ,CAEA,CAFIX,GAAA,CAAMU,CAAA,CAtBHF,CAsBG,CAASS,CAAT,CAAN,CAAoBA,CAExB,CAAa,EAAb,GAAON,CAAP,EAAmBA,CAAnB,CAAuBC,CAAvB,CAA0BD,CAA1B,CAA8BO,CAA9B,CAEEA,CAIA,CAJQR,CAAA,CA5BCG,CA4BD,CAAaF,CAAb,CAIR,CAFAD,CAAA,CA9BSG,CA8BT,CAAaF,CAAb,CAEA,CAFkBC,CAElB,CAAc,EAAd,GAAIM,CAAJ;CACET,MAAA,CAAOE,CAAP,CADF,CACcC,CADd,CAKEZ,IAAJ,GACEU,CAAA,CApCKF,CAoCL,CAASS,CAAT,CADF,CACgBL,CADhB,CAjB4D,CANpC,CA6B5B,MAAOH,OA9DgB,CAjBsG;",
"sources":["node_modules/mathjs/lib/cjs/function/algebra/sparse/csEtree.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csEtree\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.csEtree = csEtree;\n\n/**\n * Computes the elimination tree of Matrix A (using triu(A)) or the\n * elimination tree of A'A without forming A'A.\n *\n * @param {Matrix}  a               The A Matrix\n * @param {boolean} ata             A value of true the function computes the etree of A'A\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nfunction csEtree(a, ata) {\n  // check inputs\n  if (!a) {\n    return null;\n  } // a arrays\n\n\n  var aindex = a._index;\n  var aptr = a._ptr;\n  var asize = a._size; // rows & columns\n\n  var m = asize[0];\n  var n = asize[1]; // allocate result\n\n  var parent = []; // (n)\n  // allocate workspace\n\n  var w = []; // (n + (ata ? m : 0))\n\n  var ancestor = 0; // first n entries in w\n\n  var prev = n; // last m entries (ata = true)\n\n  var i, inext; // check we are calculating A'A\n\n  if (ata) {\n    // initialize workspace\n    for (i = 0; i < m; i++) {\n      w[prev + i] = -1;\n    }\n  } // loop columns\n\n\n  for (var k = 0; k < n; k++) {\n    // node k has no parent yet\n    parent[k] = -1; // nor does k have an ancestor\n\n    w[ancestor + k] = -1; // values in column k\n\n    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n      // row\n      var r = aindex[p]; // node\n\n      i = ata ? w[prev + r] : r; // traverse from i to k\n\n      for (; i !== -1 && i < k; i = inext) {\n        // inext = ancestor of i\n        inext = w[ancestor + i]; // path compression\n\n        w[ancestor + i] = k; // check no anc., parent is k\n\n        if (inext === -1) {\n          parent[i] = k;\n        }\n      }\n\n      if (ata) {\n        w[prev + r] = k;\n      }\n    }\n  }\n\n  return parent;\n}\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","csEtree","a","ata","aindex","_index","aptr","_ptr","asize","_size","m","n","parent","w","i","k","ancestor","p1","p","p0","r","inext"]
}
