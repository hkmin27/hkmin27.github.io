shadow$provide.module$node_modules$mathjs$lib$cjs$type$matrix$FibonacciHeap=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createFibonacciHeapClass=void 0;global=require("module$node_modules$mathjs$lib$cjs$utils$factory");global=(0,global.factory)("FibonacciHeap",["smaller","larger"],function(_ref){function FibonacciHeap(){if(!(this instanceof FibonacciHeap))throw new SyntaxError("Constructor must be called with the new operator");this._minimum=
null;this._size=0}function _cut(minimum,node,parent){node.left.right=node.right;node.right.left=node.left;parent.degree--;parent.child===node&&(parent.child=node.right);0===parent.degree&&(parent.child=null);node.left=minimum;node.right=minimum.right;minimum.right=node;node.right.left=node;node.parent=null;node.mark=!1}function _cascadingCut(minimum,node){var parent=node.parent;parent&&(node.mark?(_cut(minimum,node,parent),_cascadingCut(parent)):node.mark=!0)}var smaller=_ref.smaller,larger=_ref.larger,
oneOverLogPhi=1/Math.log((1+Math.sqrt(5))/2);FibonacciHeap.prototype.type="FibonacciHeap";FibonacciHeap.prototype.isFibonacciHeap=!0;FibonacciHeap.prototype.insert=function(key,value){value={key:key,value:value,degree:0};if(this._minimum){var minimum=this._minimum;value.left=minimum;value.right=minimum.right;minimum.right=value;value.right.left=value;smaller(key,minimum.key)&&(this._minimum=value)}else value.left=value,this._minimum=value.right=value;this._size++;return value};FibonacciHeap.prototype.size=
function(){return this._size};FibonacciHeap.prototype.clear=function(){this._minimum=null;this._size=0};FibonacciHeap.prototype.isEmpty=function(){return 0===this._size};FibonacciHeap.prototype.extractMinimum=function(){var node=this._minimum;if(null===node)return node;for(var minimum=this._minimum,numberOfChildren=node.degree,x=node.child;0<numberOfChildren;){var tempRight=x.right;x.left.right=x.right;x.right.left=x.left;x.left=minimum;x.right=minimum.right;minimum.right=x;x.right.left=x;x.parent=
null;x=tempRight;numberOfChildren--}node.left.right=node.right;node.right.left=node.left;if(node===node.right)minimum=null;else{var minimum$jscomp$0=minimum=node.right;minimum=Math.floor(Math.log(this._size)*oneOverLogPhi)+1;numberOfChildren=Array(minimum);x=0;if(tempRight=minimum$jscomp$0)for(x++,tempRight=tempRight.right;tempRight!==minimum$jscomp$0;)x++,tempRight=tempRight.right;for(var y;0<x;){minimum$jscomp$0=tempRight.degree;for(var next=tempRight.right;;){y=numberOfChildren[minimum$jscomp$0];
if(!y)break;if(larger(tempRight.key,y.key)){var temp=y;y=tempRight;tempRight=temp}temp=tempRight;y.left.right=y.right;y.right.left=y.left;y.parent=temp;temp.child?(y.left=temp.child,y.right=temp.child.right,temp.child.right=y,y.right.left=y):(temp.child=y,y.right=y,y.left=y);temp.degree++;y.mark=!1;numberOfChildren[minimum$jscomp$0]=null;minimum$jscomp$0++}numberOfChildren[minimum$jscomp$0]=tempRight;tempRight=next;x--}minimum$jscomp$0=null;for(x=0;x<minimum;x++)if(y=numberOfChildren[x])minimum$jscomp$0?
(y.left.right=y.right,y.right.left=y.left,y.left=minimum$jscomp$0,y.right=minimum$jscomp$0.right,minimum$jscomp$0.right=y,y.right.left=y,smaller(y.key,minimum$jscomp$0.key)&&(minimum$jscomp$0=y)):minimum$jscomp$0=y;minimum=minimum$jscomp$0}this._size--;this._minimum=minimum;return node};FibonacciHeap.prototype.remove=function(node){var minimum=this._minimum;node.key=-1;var parent=node.parent;parent&&smaller(node.key,parent.key)&&(_cut(minimum,node,parent),_cascadingCut(minimum,parent));smaller(node.key,
minimum.key)&&(minimum=node);this._minimum=minimum;this.extractMinimum()};return FibonacciHeap},{isClass:!0});exports.createFibonacciHeapClass=global}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$type$matrix$FibonacciHeap.js.map
