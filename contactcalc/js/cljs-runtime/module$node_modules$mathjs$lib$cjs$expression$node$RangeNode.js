shadow$provide.module$node_modules$mathjs$lib$cjs$expression$node$RangeNode=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createRangeNode=void 0;var _is=require("module$node_modules$mathjs$lib$cjs$utils$is");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");var _operators=require("module$node_modules$mathjs$lib$cjs$expression$operators");require=(0,global.factory)("RangeNode",["Node"],function(_ref){function RangeNode(start,
end,step){if(!(this instanceof RangeNode))throw new SyntaxError("Constructor must be called with the new operator");if(!(0,_is.isNode)(start))throw new TypeError("Node expected");if(!(0,_is.isNode)(end))throw new TypeError("Node expected");if(step&&!(0,_is.isNode)(step))throw new TypeError("Node expected");if(3<arguments.length)throw Error("Too many arguments");this.start=start;this.end=end;this.step=step||null}function calculateNecessaryParentheses(node,parenthesis){var precedence=(0,_operators.getPrecedence)(node,
parenthesis),parens={},startPrecedence=(0,_operators.getPrecedence)(node.start,parenthesis);parens.start=null!==startPrecedence&&startPrecedence<=precedence||"all"===parenthesis;node.step&&(startPrecedence=(0,_operators.getPrecedence)(node.step,parenthesis),parens.step=null!==startPrecedence&&startPrecedence<=precedence||"all"===parenthesis);node=(0,_operators.getPrecedence)(node.end,parenthesis);parens.end=null!==node&&node<=precedence||"all"===parenthesis;return parens}RangeNode.prototype=new _ref.Node;
RangeNode.prototype.type="RangeNode";RangeNode.prototype.isRangeNode=!0;RangeNode.prototype.needsEnd=function(){return 0<this.filter(function(node){return(0,_is.isSymbolNode)(node)&&"end"===node.name}).length};RangeNode.prototype._compile=function(math,argNames){var range=math.range,evalStart=this.start._compile(math,argNames),evalEnd=this.end._compile(math,argNames);if(this.step){var evalStep=this.step._compile(math,argNames);return function(scope,args,context){return range(evalStart(scope,args,
context),evalEnd(scope,args,context),evalStep(scope,args,context))}}return function(scope,args,context){return range(evalStart(scope,args,context),evalEnd(scope,args,context))}};RangeNode.prototype.forEach=function(callback){callback(this.start,"start",this);callback(this.end,"end",this);this.step&&callback(this.step,"step",this)};RangeNode.prototype.map=function(callback){return new RangeNode(this._ifNode(callback(this.start,"start",this)),this._ifNode(callback(this.end,"end",this)),this.step&&this._ifNode(callback(this.step,
"step",this)))};RangeNode.prototype.clone=function(){return new RangeNode(this.start,this.end,this.step&&this.step)};RangeNode.prototype._toString=function(options){var parens=calculateNecessaryParentheses(this,options&&options.parenthesis?options.parenthesis:"keep");var str=this.start.toString(options);parens.start&&(str="("+str+")");if(this.step){var step=this.step.toString(options);parens.step&&(step="("+step+")");str+=":"+step}options=this.end.toString(options);parens.end&&(options="("+options+
")");return str+(":"+options)};RangeNode.prototype.toJSON=function(){return{mathjs:"RangeNode",start:this.start,end:this.end,step:this.step}};RangeNode.fromJSON=function(json){return new RangeNode(json.start,json.end,json.step)};RangeNode.prototype.toHTML=function(options){var parens=calculateNecessaryParentheses(this,options&&options.parenthesis?options.parenthesis:"keep");var str=this.start.toHTML(options);parens.start&&(str='\x3cspan class\x3d"math-parenthesis math-round-parenthesis"\x3e(\x3c/span\x3e'+
str+'\x3cspan class\x3d"math-parenthesis math-round-parenthesis"\x3e)\x3c/span\x3e');if(this.step){var step=this.step.toHTML(options);parens.step&&(step='\x3cspan class\x3d"math-parenthesis math-round-parenthesis"\x3e(\x3c/span\x3e'+step+'\x3cspan class\x3d"math-parenthesis math-round-parenthesis"\x3e)\x3c/span\x3e');str+='\x3cspan class\x3d"math-operator math-range-operator"\x3e:\x3c/span\x3e'+step}options=this.end.toHTML(options);parens.end&&(options='\x3cspan class\x3d"math-parenthesis math-round-parenthesis"\x3e(\x3c/span\x3e'+
options+'\x3cspan class\x3d"math-parenthesis math-round-parenthesis"\x3e)\x3c/span\x3e');return str+('\x3cspan class\x3d"math-operator math-range-operator"\x3e:\x3c/span\x3e'+options)};RangeNode.prototype._toTex=function(options){var parens=calculateNecessaryParentheses(this,options&&options.parenthesis?options.parenthesis:"keep"),str=this.start.toTex(options);parens.start&&(str="\\left(".concat(str,"\\right)"));if(this.step){var step=this.step.toTex(options);parens.step&&(step="\\left(".concat(step,
"\\right)"));str+=":"+step}options=this.end.toTex(options);parens.end&&(options="\\left(".concat(options,"\\right)"));return str+(":"+options)};return RangeNode},{isClass:!0,isNode:!0});exports.createRangeNode=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$expression$node$RangeNode.js.map
