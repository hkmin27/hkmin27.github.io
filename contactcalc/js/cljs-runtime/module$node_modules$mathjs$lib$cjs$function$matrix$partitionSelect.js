shadow$provide.module$node_modules$mathjs$lib$cjs$function$matrix$partitionSelect=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createPartitionSelect=void 0;var _is=require("module$node_modules$mathjs$lib$cjs$utils$is"),_number=require("module$node_modules$mathjs$lib$cjs$utils$number");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");global=(0,global.factory)("partitionSelect",["typed","isNumeric","isNaN","compare"],function(_ref){function _partitionSelect(x,
k,compare){if(!(0,_number.isInteger)(k)||0>k)throw Error("k must be a non-negative integer");if((0,_is.isMatrix)(x)){if(1<x.size().length)throw Error("Only one dimensional matrices supported");return quickSelect(x.valueOf(),k,compare)}if(Array.isArray(x))return quickSelect(x,k,compare)}function quickSelect(arr,k,compare){if(k>=arr.length)throw Error("k out of bounds");for(var i=0;i<arr.length;i++)if(isNumeric(arr[i])&&isNaN(arr[i]))return arr[i];i=0;for(var to=arr.length-1;i<to;){for(var r=i,w=to,
pivot=arr[Math.floor(Math.random()*(to-i+1))+i];r<w;)if(0<=compare(arr[r],pivot)){var tmp=arr[w];arr[w]=arr[r];arr[r]=tmp;--w}else++r;0<compare(arr[r],pivot)&&--r;k<=r?to=r:i=r+1}return arr[k]}var typed=_ref.typed,isNumeric=_ref.isNumeric,isNaN=_ref.isNaN,compare$jscomp$0=_ref.compare,desc=function(a,b){return-compare$jscomp$0(a,b)};return typed("partitionSelect",{"Array | Matrix, number":function(x,k){return _partitionSelect(x,k,compare$jscomp$0)},"Array | Matrix, number, string":function(x,k,compare){if("asc"===
compare)return _partitionSelect(x,k,compare$jscomp$0);if("desc"===compare)return _partitionSelect(x,k,desc);throw Error('Compare string must be "asc" or "desc"');},"Array | Matrix, number, function":_partitionSelect})});exports.createPartitionSelect=global}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$function$matrix$partitionSelect.js.map
