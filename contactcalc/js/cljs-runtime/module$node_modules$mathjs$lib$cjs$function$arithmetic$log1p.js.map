{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$function$arithmetic$log1p.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,4DAAA,CAAiF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGzHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,WAAR,CAAsB,IAAK,EAEvBC,OAAAA,CAAWP,OAAA,CAAQ,kDAAR,CAEf,KAAIQ,YAAcR,OAAA,CAAQ,qDAAR,CAAlB,CAEIS,QAAUT,OAAA,CAAQ,iDAAR,CAIVM,QAAAA,CAA6B,CAAC,CAAA,CAAGC,MAASG,CAAAA,OAAb,EAFtBC,OAEsB,CADdC,CAAC,OAADA,CAAU,QAAVA,CAAoB,cAApBA,CAAoC,KAApCA,CAA2C,SAA3CA,CACc,CAA0C,QAAS,CAACC,IAAD,CAAO,CAyEzFC,QAASA,cAAa,CAACC,CAAD,CAAI,CACxB,IAAIC;AAAQD,CAAEE,CAAAA,EAAVD,CAAe,CACnB,OAAO,KAAIE,OAAJ,CAAYC,IAAKC,CAAAA,GAAL,CAASD,IAAKE,CAAAA,IAAL,CAAUL,KAAV,CAAkBA,KAAlB,CAA0BD,CAAEO,CAAAA,EAA5B,CAAiCP,CAAEO,CAAAA,EAAnC,CAAT,CAAZ,CAA8DH,IAAKI,CAAAA,KAAL,CAAWR,CAAEO,CAAAA,EAAb,CAAiBN,KAAjB,CAA9D,CAFiB,CAzE+D,IACrFQ,MAAQX,IAAKW,CAAAA,KADwE,CAErFC,OAASZ,IAAKY,CAAAA,MAFuE,CAGrFC,aAAeb,IAAKa,CAAAA,YAHiE,CAIrFN,IAAMP,IAAKO,CAAAA,GAJ0E,CAKrFF,QAAUL,IAAKK,CAAAA,OAiCnB,OAAOM,MAAA,CAxCEb,OAwCF,CAAY,CACjBgB,OAAQA,QAAe,CAACZ,CAAD,CAAI,CACzB,MAAS,EAAT,EAAIA,CAAJ,EAAeU,MAAOG,CAAAA,WAAtB,CACS,CAAC,CAAA,CAAGnB,OAAQoB,CAAAA,KAAZ,EAAmBd,CAAnB,CADT,CAISD,aAAA,CAAc,IAAII,OAAJ,CAAYH,CAAZ,CAAe,CAAf,CAAd,CALgB,CADV,CASjBG,QAASJ,aATQ,CAUjBgB,UAAWA,QAAkB,CAACf,CAAD,CAAI,CAC/B,IAAIgB,EAAIhB,CAAEiB,CAAAA,IAAF,CAAO,CAAP,CAER,OAAI,CAACD,CAAEE,CAAAA,UAAF,EAAL,EAAuBR,MAAOG,CAAAA,WAA9B,CACSG,CAAEG,CAAAA,EAAF,EADT,CAISpB,aAAA,CAAc,IAAII,OAAJ,CAAYH,CAAEoB,CAAAA,QAAF,EAAZ,CAA0B,CAA1B,CAAd,CAPsB,CAVhB,CAoBjB,iBAAkBC,QAAoB,CAACrB,CAAD,CAAI,CACxC,MAAO,CAAC,CAAA;AAAGP,WAAY6B,CAAAA,OAAhB,EAAyBtB,CAAzB,CAA4B,IAA5B,CADiC,CApBzB,CAuBjB,WAAYuB,QAAe,CAACvB,CAAD,CAAIwB,IAAJ,CAAU,CAEnC,MAAOb,aAAA,CAAa,IAAA,CAAKX,CAAL,CAAb,CAAsBK,GAAA,CAAImB,IAAJ,CAAtB,CAF4B,CAvBpB,CAAZ,CAtCkF,CAA1D,CA8EjCrC,QAAQI,CAAAA,WAAR,CAAsBA,OA9FmG;",
"sources":["node_modules/mathjs/lib/cjs/function/arithmetic/log1p.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$arithmetic$log1p\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLog1p = void 0;\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _collection = require(\"../../utils/collection.js\");\n\nvar _number = require(\"../../utils/number.js\");\n\nvar name = 'log1p';\nvar dependencies = ['typed', 'config', 'divideScalar', 'log', 'Complex'];\nvar createLog1p = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      divideScalar = _ref.divideScalar,\n      log = _ref.log,\n      Complex = _ref.Complex;\n\n  /**\n   * Calculate the logarithm of a `value+1`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.log1p(x)\n   *    math.log1p(x, base)\n   *\n   * Examples:\n   *\n   *    math.log1p(2.5)                 // returns 1.252762968495368\n   *    math.exp(math.log1p(1.4))       // returns 2.4\n   *\n   *    math.pow(10, 4)                 // returns 10000\n   *    math.log1p(9999, 10)            // returns 4\n   *    math.log1p(9999) / math.log(10) // returns 4\n   *\n   * See also:\n   *\n   *    exp, log, log2, log10\n   *\n   * @param {number | BigNumber | Complex | Array | Matrix} x\n   *            Value for which to calculate the logarithm of `x+1`.\n   * @param {number | BigNumber | Complex} [base=e]\n   *            Optional base for the logarithm. If not provided, the natural\n   *            logarithm of `x+1` is calculated.\n   * @return {number | BigNumber | Complex | Array | Matrix}\n   *            Returns the logarithm of `x+1`\n   */\n  return typed(name, {\n    number: function number(x) {\n      if (x >= -1 || config.predictable) {\n        return (0, _number.log1p)(x);\n      } else {\n        // negative value -> complex value computation\n        return _log1pComplex(new Complex(x, 0));\n      }\n    },\n    Complex: _log1pComplex,\n    BigNumber: function BigNumber(x) {\n      var y = x.plus(1);\n\n      if (!y.isNegative() || config.predictable) {\n        return y.ln();\n      } else {\n        // downgrade to number, return Complex valued result\n        return _log1pComplex(new Complex(x.toNumber(), 0));\n      }\n    },\n    'Array | Matrix': function ArrayMatrix(x) {\n      return (0, _collection.deepMap)(x, this);\n    },\n    'any, any': function anyAny(x, base) {\n      // calculate logarithm for a specified base, log1p(x, base)\n      return divideScalar(this(x), log(base));\n    }\n  });\n  /**\n   * Calculate the natural logarithm of a complex number + 1\n   * @param {Complex} x\n   * @returns {Complex}\n   * @private\n   */\n\n  function _log1pComplex(x) {\n    var xRe1p = x.re + 1;\n    return new Complex(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));\n  }\n});\nexports.createLog1p = createLog1p;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","createLog1p","_factory","_collection","_number","factory","name","dependencies","_ref","_log1pComplex","x","xRe1p","re","Complex","Math","log","sqrt","im","atan2","typed","config","divideScalar","number","predictable","log1p","BigNumber","y","plus","isNegative","ln","toNumber","ArrayMatrix","deepMap","anyAny","base"]
}
