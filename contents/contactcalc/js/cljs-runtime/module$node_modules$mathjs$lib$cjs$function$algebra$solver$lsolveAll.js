shadow$provide.module$node_modules$mathjs$lib$cjs$function$algebra$solver$lsolveAll=function(global,require,module,exports){function _toConsumableArray(arr){var JSCompiler_temp=Array.isArray(arr)?_arrayLikeToArray(arr):void 0;JSCompiler_temp||(JSCompiler_temp="undefined"!==typeof Symbol&&Symbol.iterator in Object(arr)?Array.from(arr):void 0);if(!JSCompiler_temp)a:{if(arr){if("string"===typeof arr){JSCompiler_temp=_arrayLikeToArray(arr,void 0);break a}JSCompiler_temp=Object.prototype.toString.call(arr).slice(8,
-1);"Object"===JSCompiler_temp&&arr.constructor&&(JSCompiler_temp=arr.constructor.name);if("Map"===JSCompiler_temp||"Set"===JSCompiler_temp){JSCompiler_temp=Array.from(arr);break a}if("Arguments"===JSCompiler_temp||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(JSCompiler_temp)){JSCompiler_temp=_arrayLikeToArray(arr,void 0);break a}}JSCompiler_temp=void 0}if(!(arr=JSCompiler_temp))throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
return arr}function _arrayLikeToArray(arr,len){if(null==len||len>arr.length)len=arr.length;for(var i=0,arr2=Array(len);i<len;i++)arr2[i]=arr[i];return arr2}Object.defineProperty(exports,"__esModule",{value:!0});exports.createLsolveAll=void 0;global=require("module$node_modules$mathjs$lib$cjs$utils$factory");var _solveValidation=require("module$node_modules$mathjs$lib$cjs$function$algebra$solver$utils$solveValidation");require=(0,global.factory)("lsolveAll","typed matrix divideScalar multiplyScalar subtract equalScalar DenseMatrix".split(" "),
function(_ref){function _denseForwardSubstitution(m,b_){b_=[solveValidation(m,b_,!0)._data.map(function(e){return e[0]})];var M=m._data,rows=m._size[0];m=m._size[1];for(var i=0;i<m;i++)for(var L=b_.length,k=0;k<L;k++){var b=b_[k];if(!equalScalar(M[i][i],0)){b[i]=divideScalar(b[i],M[i][i]);for(var j=i+1;j<m;j++)b[j]=subtract(b[j],multiplyScalar(b[i],M[j][i]))}else if(!equalScalar(b[i],0)){if(0===k)return[];b_.splice(k,1);--k;--L}else if(0===k){b=_toConsumableArray(b);b[i]=1;for(j=i+1;j<m;j++)b[j]=
subtract(b[j],M[j][i]);b_.push(b)}}return b_.map(function(x){return new DenseMatrix({data:x.map(function(e){return[e]}),size:[rows,1]})})}function _sparseForwardSubstitution(m,b_){b_=[solveValidation(m,b_,!0)._data.map(function(e){return e[0]})];var rows=m._size[0],columns=m._size[1],values=m._values,index=m._index;m=m._ptr;for(var i=0;i<columns;i++)for(var L=b_.length,k=0;k<L;k++){for(var b=b_[k],iValues=[],iIndices=[],lastIndex=m[i+1],Mii=0,j=m[i];j<lastIndex;j++){var J=index[j];J===i?Mii=values[j]:
J>i&&(iValues.push(values[j]),iIndices.push(J))}if(!equalScalar(Mii,0))for(b[i]=divideScalar(b[i],Mii),lastIndex=0,Mii=iIndices.length;lastIndex<Mii;lastIndex++)j=iIndices[lastIndex],b[j]=subtract(b[j],multiplyScalar(b[i],iValues[lastIndex]));else if(!equalScalar(b[i],0)){if(0===k)return[];b_.splice(k,1);--k;--L}else if(0===k){b=_toConsumableArray(b);b[i]=1;lastIndex=0;for(Mii=iIndices.length;lastIndex<Mii;lastIndex++)j=iIndices[lastIndex],b[j]=subtract(b[j],iValues[lastIndex]);b_.push(b)}}return b_.map(function(x){return new DenseMatrix({data:x.map(function(e){return[e]}),
size:[rows,1]})})}var typed=_ref.typed,matrix=_ref.matrix,divideScalar=_ref.divideScalar,multiplyScalar=_ref.multiplyScalar,subtract=_ref.subtract,equalScalar=_ref.equalScalar,DenseMatrix=_ref.DenseMatrix,solveValidation=(0,_solveValidation.createSolveValidation)({DenseMatrix:DenseMatrix});return typed("lsolveAll",{"SparseMatrix, Array | Matrix":function(m,b){return _sparseForwardSubstitution(m,b)},"DenseMatrix, Array | Matrix":function(m,b){return _denseForwardSubstitution(m,b)},"Array, Array | Matrix":function(a,
b){a=matrix(a);return _denseForwardSubstitution(a,b).map(function(r){return r.valueOf()})}})});exports.createLsolveAll=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$function$algebra$solver$lsolveAll.js.map
