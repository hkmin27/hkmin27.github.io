{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$function$algebra$simplify$simplifyConstant.js",
"lineCount":10,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/function/algebra/simplify/simplifyConstant.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$simplify$simplifyConstant\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSimplifyConstant = void 0;\n\nvar _is = require(\"../../../utils/is.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _util = require(\"./util.js\");\n\nvar _noop = require(\"../../../utils/noop.js\");\n\n// TODO this could be improved by simplifying seperated constants under associative and commutative operators\nvar name = 'simplifyConstant';\nvar dependencies = ['typed', 'config', 'mathWithTransform', '?fraction', '?bignumber', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'SymbolNode'];\nvar createSimplifyConstant = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      config = _ref.config,\n      mathWithTransform = _ref.mathWithTransform,\n      fraction = _ref.fraction,\n      bignumber = _ref.bignumber,\n      ConstantNode = _ref.ConstantNode,\n      OperatorNode = _ref.OperatorNode,\n      FunctionNode = _ref.FunctionNode,\n      SymbolNode = _ref.SymbolNode;\n\n  var _createUtil = (0, _util.createUtil)({\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    SymbolNode: SymbolNode\n  }),\n      isCommutative = _createUtil.isCommutative,\n      isAssociative = _createUtil.isAssociative,\n      allChildren = _createUtil.allChildren,\n      createMakeNodeFunction = _createUtil.createMakeNodeFunction;\n\n  function simplifyConstant(expr, options) {\n    var res = foldFraction(expr, options);\n    return (0, _is.isNode)(res) ? res : _toNode(res);\n  }\n\n  function _eval(fnname, args, options) {\n    try {\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(function (x) {\n        if ((0, _is.isFraction)(x)) {\n          return x.valueOf();\n        }\n\n        return x;\n      });\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    }\n  }\n\n  var _toNode = typed({\n    Fraction: _fractionToNode,\n    number: function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n    Complex: function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    }\n  }); // convert a number to a fraction only if it can be expressed exactly,\n  // and when both numerator and denominator are small enough\n\n\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n\n    if (exactFractions && isFinite(n) && fraction) {\n      var f = fraction(n);\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\n\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\n        return f;\n      }\n    }\n\n    return n;\n  } // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n\n\n  var _toNumber = typed({\n    'string, Object': function stringObject(s, options) {\n      if (config.number === 'BigNumber') {\n        if (bignumber === undefined) {\n          (0, _noop.noBignumber)();\n        }\n\n        return bignumber(s);\n      } else if (config.number === 'Fraction') {\n        if (fraction === undefined) {\n          (0, _noop.noFraction)();\n        }\n\n        return fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function FractionObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'BigNumber, Object': function BigNumberObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'number, Object': function numberObject(s, options) {\n      return _exactFraction(s, options);\n    },\n    'Complex, Object': function ComplexObject(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n\n      return _exactFraction(s.re, options);\n    }\n  });\n\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s * f.n;\n\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\n    } else {\n      n = new ConstantNode(vn);\n    }\n\n    if (f.d === 1) {\n      return n;\n    }\n\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n  /*\n   * Create a binary tree from a list of Fractions and Nodes.\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\n   * @param args - list of Fractions and Nodes\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\n   * if args.length is 1, returns args[0]\n   * @return - Either a Node representing a binary expression or Fraction\n   */\n\n\n  function foldOp(fn, args, makeNode, options) {\n    return args.reduce(function (a, b) {\n      if (!(0, _is.isNode)(a) && !(0, _is.isNode)(b)) {\n        try {\n          return _eval(fn, [a, b], options);\n        } catch (ignoreandcontinue) {}\n\n        a = _toNode(a);\n        b = _toNode(b);\n      } else if (!(0, _is.isNode)(a)) {\n        a = _toNode(a);\n      } else if (!(0, _is.isNode)(b)) {\n        b = _toNode(b);\n      }\n\n      return makeNode([a, b]);\n    });\n  } // destroys the original node and returns a folded one\n\n\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n\n      case 'ConstantNode':\n        if (typeof node.value === 'number' || !isNaN(node.value)) {\n          return _toNumber(node.value, options);\n        }\n\n        return node;\n\n      case 'FunctionNode':\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\n          return node;\n        }\n\n        {\n          // Process operators as OperatorNode\n          var operatorFunctions = ['add', 'multiply'];\n\n          if (operatorFunctions.indexOf(node.name) === -1) {\n            var args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            }); // If all args are numbers\n\n            if (!args.some(_is.isNode)) {\n              try {\n                return _eval(node.name, args, options);\n              } catch (ignoreandcontine) {}\n            } // Convert all args to nodes and construct a symbolic function call\n\n\n            args = args.map(function (arg) {\n              return (0, _is.isNode)(arg) ? arg : _toNode(arg);\n            });\n            return new FunctionNode(node.name, args);\n          } else {// treat as operator\n          }\n        }\n\n      /* falls through */\n\n      case 'OperatorNode':\n        {\n          var fn = node.fn.toString();\n\n          var _args;\n\n          var res;\n          var makeNode = createMakeNodeFunction(node);\n\n          if ((0, _is.isOperatorNode)(node) && node.isUnary()) {\n            _args = [foldFraction(node.args[0], options)];\n\n            if (!(0, _is.isNode)(_args[0])) {\n              res = _eval(fn, _args, options);\n            } else {\n              res = makeNode(_args);\n            }\n          } else if (isAssociative(node)) {\n            _args = allChildren(node);\n            _args = _args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n\n            if (isCommutative(fn)) {\n              // commutative binary operator\n              var consts = [];\n              var vars = [];\n\n              for (var i = 0; i < _args.length; i++) {\n                if (!(0, _is.isNode)(_args[i])) {\n                  consts.push(_args[i]);\n                } else {\n                  vars.push(_args[i]);\n                }\n              }\n\n              if (consts.length > 1) {\n                res = foldOp(fn, consts, makeNode, options);\n                vars.unshift(res);\n                res = foldOp(fn, vars, makeNode, options);\n              } else {\n                // we won't change the children order since it's not neccessary\n                res = foldOp(fn, _args, makeNode, options);\n              }\n            } else {\n              // non-commutative binary operator\n              res = foldOp(fn, _args, makeNode, options);\n            }\n          } else {\n            // non-associative binary operator\n            _args = node.args.map(function (arg) {\n              return foldFraction(arg, options);\n            });\n            res = foldOp(fn, _args, makeNode, options);\n          }\n\n          return res;\n        }\n\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n\n      case 'AccessorNode':\n      /* falls through */\n\n      case 'ArrayNode':\n      /* falls through */\n\n      case 'AssignmentNode':\n      /* falls through */\n\n      case 'BlockNode':\n      /* falls through */\n\n      case 'FunctionAssignmentNode':\n      /* falls through */\n\n      case 'IndexNode':\n      /* falls through */\n\n      case 'ObjectNode':\n      /* falls through */\n\n      case 'RangeNode':\n      /* falls through */\n\n      case 'ConditionalNode':\n      /* falls through */\n\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n\n  return simplifyConstant;\n});\nexports.createSimplifyConstant = createSimplifyConstant;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","createSimplifyConstant","_is","_factory","_util","_noop","factory","name","dependencies","_ref","_eval","fnname","args","options","_toNumber","mathWithTransform","apply","ignore","map","x","isFraction","valueOf","_exactFraction","n","exactFractions","isFinite","fraction","f","fractionsLimit","Infinity","d","foldOp","fn","makeNode","reduce","a","b","isNode","_toNode","ignoreandcontinue","foldFraction","node","type","isNaN","rawArgs","operatorFunctions","indexOf","arg","some","ignoreandcontine","FunctionNode","toString","createMakeNodeFunction","isOperatorNode","isUnary","_args","res","isAssociative","allChildren","isCommutative","consts","vars","i","length","push","unshift","content","Error","concat","typed","config","bignumber","ConstantNode","OperatorNode","SymbolNode","_createUtil","createUtil","Fraction","_fractionToNode","vn","s","number","BigNumber","Complex","stringObject","undefined","noBignumber","noFraction","parseFloat","FractionObject","BigNumberObject","numberObject","ComplexObject","im","re","simplifyConstant","expr"]
}
