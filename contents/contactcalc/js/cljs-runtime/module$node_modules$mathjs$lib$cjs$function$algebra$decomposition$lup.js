shadow$provide.module$node_modules$mathjs$lib$cjs$function$algebra$decomposition$lup=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createLup=void 0;var _object=require("module$node_modules$mathjs$lib$cjs$utils$object");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");global=(0,global.factory)("lup","typed matrix abs addScalar divideScalar multiplyScalar subtract larger equalScalar unaryMinus DenseMatrix SparseMatrix Spa".split(" "),
function(_ref){function _denseLUP(m){var rows=m._size[0],columns=m._size[1],n=Math.min(rows,columns),data=(0,_object.clone)(m._data),ldata=[],lsize=[rows,n],udata=[];n=[n,columns];var j,k,p=[];for(m=0;m<rows;m++)p[m]=m;for(j=0;j<columns;j++){if(0<j)for(m=0;m<rows;m++){var min=Math.min(m,j),s=0;for(k=0;k<min;k++)s=addScalar(s,multiplyScalar(data[m][k],data[k][j]));data[m][j]=subtract(data[m][j],s)}k=j;s=min=0;for(m=j;m<rows;m++){var v=data[m][j],absv=abs(v);larger(absv,min)&&(k=m,min=absv,s=v)}j!==
k&&(p[j]=[p[k],p[k]=p[j]][0],DenseMatrix._swapRows(j,k,data));if(j<rows)for(m=j+1;m<rows;m++)equalScalar(data[m][j],0)||(data[m][j]=divideScalar(data[m][j],s))}for(j=0;j<columns;j++)for(m=0;m<rows;m++)0===j&&(m<columns&&(udata[m]=[]),ldata[m]=[]),m<j?(m<columns&&(udata[m][j]=data[m][j]),j<rows&&(ldata[m][j]=0)):m===j?(m<columns&&(udata[m][j]=data[m][j]),j<rows&&(ldata[m][j]=1)):(m<columns&&(udata[m][j]=0),j<rows&&(ldata[m][j]=data[m][j]));rows=new DenseMatrix({data:ldata,size:lsize});columns=new DenseMatrix({data:udata,
size:n});udata=[];m=0;for(n=p.length;m<n;m++)udata[p[m]]=m;return{L:rows,U:columns,p:udata,toString:function(){return"L: "+this.L.toString()+"\nU: "+this.U.toString()+"\nP: "+this.p}}}function _sparseLUP(m){var rows=m._size[0],columns=m._size[1],n=Math.min(rows,columns),values=m._values,index=m._index,ptr=m._ptr,lvalues=[],lindex=[],lptr=[],lsize=[rows,n],uvalues=[],uindex=[],uptr=[],usize=[n,columns],i$jscomp$0,j,k$jscomp$0,pvCo=[],pvOc=[];for(i$jscomp$0=0;i$jscomp$0<rows;i$jscomp$0++)pvCo[i$jscomp$0]=
i$jscomp$0,pvOc[i$jscomp$0]=i$jscomp$0;var swapIndeces=function(x,y){var kx=pvOc[x],ky=pvOc[y];pvCo[kx]=y;pvCo[ky]=x;pvOc[x]=ky;pvOc[y]=kx};m=function(){var spa=new Spa;j<rows&&(lptr.push(lvalues.length),lvalues.push(1),lindex.push(j));uptr.push(uvalues.length);var k1=ptr[j+1];for(k$jscomp$0=ptr[j];k$jscomp$0<k1;k$jscomp$0++)i$jscomp$0=index[k$jscomp$0],spa.set(pvCo[i$jscomp$0],values[k$jscomp$0]);0<j&&spa.forEach(0,j-1,function(k,vkj){SparseMatrix._forEachRow(k,lvalues,lindex,lptr,function(i,vik){i>
k&&spa.accumulate(i,unaryMinus(multiplyScalar(vik,vkj)))})});var pi=j,vjj=spa.get(j),pabsv=abs(vjj);spa.forEach(j+1,rows-1,function(x,v){var absv=abs(v);larger(absv,pabsv)&&(pi=x,pabsv=absv,vjj=v)});j!==pi&&(SparseMatrix._swapRows(j,pi,lsize[1],lvalues,lindex,lptr),SparseMatrix._swapRows(j,pi,usize[1],uvalues,uindex,uptr),spa.swap(j,pi),swapIndeces(j,pi));spa.forEach(0,rows-1,function(x,v){x<=j?(uvalues.push(v),uindex.push(x)):(v=divideScalar(v,vjj),equalScalar(v,0)||(lvalues.push(v),lindex.push(x)))})};
for(j=0;j<columns;j++)m();uptr.push(uvalues.length);lptr.push(lvalues.length);return{L:new SparseMatrix({values:lvalues,index:lindex,ptr:lptr,size:lsize}),U:new SparseMatrix({values:uvalues,index:uindex,ptr:uptr,size:usize}),p:pvCo,toString:function(){return"L: "+this.L.toString()+"\nU: "+this.U.toString()+"\nP: "+this.p}}}var typed=_ref.typed,matrix=_ref.matrix,abs=_ref.abs,addScalar=_ref.addScalar,divideScalar=_ref.divideScalar,multiplyScalar=_ref.multiplyScalar,subtract=_ref.subtract,larger=_ref.larger,
equalScalar=_ref.equalScalar,unaryMinus=_ref.unaryMinus,DenseMatrix=_ref.DenseMatrix,SparseMatrix=_ref.SparseMatrix,Spa=_ref.Spa;return typed("lup",{DenseMatrix:function(m){return _denseLUP(m)},SparseMatrix:function(m){return _sparseLUP(m)},Array:function(a){a=matrix(a);a=_denseLUP(a);return{L:a.L.valueOf(),U:a.U.valueOf(),p:a.p}}})});exports.createLup=global}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$function$algebra$decomposition$lup.js.map
