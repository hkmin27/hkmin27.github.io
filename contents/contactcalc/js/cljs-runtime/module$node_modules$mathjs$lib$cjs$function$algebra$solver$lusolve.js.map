{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$function$algebra$solver$lusolve.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/function/algebra/solver/lusolve.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$solver$lusolve\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLusolve = void 0;\n\nvar _is = require(\"../../../utils/is.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _solveValidation = require(\"./utils/solveValidation.js\");\n\nvar _csIpvec = require(\"../sparse/csIpvec.js\");\n\nvar name = 'lusolve';\nvar dependencies = ['typed', 'matrix', 'lup', 'slu', 'usolve', 'lsolve', 'DenseMatrix'];\nvar createLusolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      lup = _ref.lup,\n      slu = _ref.slu,\n      usolve = _ref.usolve,\n      lsolve = _ref.lsolve,\n      DenseMatrix = _ref.DenseMatrix;\n  var solveValidation = (0, _solveValidation.createSolveValidation)({\n    DenseMatrix: DenseMatrix\n  });\n  /**\n   * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.\n   *\n   * Syntax:\n   *\n   *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b\n   *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)\n   *\n   * Examples:\n   *\n   *    const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]\n   *\n   *    const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]\n   *\n   *    const f = math.lup(m)\n   *    const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]\n   *    const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = math.lusolve(a, b)  // [[2], [5]]\n   *\n   * See also:\n   *\n   *    lup, slu, lsolve, usolve\n   *\n   * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition\n   * @param {Matrix | Array} b               Column Vector\n   * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix\n   * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.\n   *\n   * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b\n   */\n\n  return typed(name, {\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      a = matrix(a);\n      var d = lup(a);\n\n      var x = _lusolve(d.L, d.U, d.p, null, b);\n\n      return x.valueOf();\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(a, b) {\n      var d = lup(a);\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(a, b) {\n      var d = lup(a);\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix, number, number': function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {\n      var d = slu(a, order, threshold);\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    },\n    'Object, Array | Matrix': function ObjectArrayMatrix(d, b) {\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    }\n  });\n\n  function _toMatrix(a) {\n    if ((0, _is.isMatrix)(a)) {\n      return a;\n    }\n\n    if ((0, _is.isArray)(a)) {\n      return matrix(a);\n    }\n\n    throw new TypeError('Invalid Matrix LU decomposition');\n  }\n\n  function _lusolve(l, u, p, q, b) {\n    // verify decomposition\n    l = _toMatrix(l);\n    u = _toMatrix(u); // apply row permutations if needed (b is a DenseMatrix)\n\n    if (p) {\n      b = solveValidation(l, b, true);\n      b._data = (0, _csIpvec.csIpvec)(p, b._data);\n    } // use forward substitution to resolve L * y = b\n\n\n    var y = lsolve(l, b); // use backward substitution to resolve U * x = y\n\n    var x = usolve(u, y); // apply column permutations if needed (x is a DenseMatrix)\n\n    if (q) {\n      x._data = (0, _csIpvec.csIpvec)(q, x._data);\n    }\n\n    return x;\n  }\n});\nexports.createLusolve = createLusolve;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","createLusolve","_is","_factory","_solveValidation","_csIpvec","factory","name","dependencies","_ref","_toMatrix","a","isMatrix","isArray","matrix","TypeError","_lusolve","l","u","p","q","b","solveValidation","_data","csIpvec","y","lsolve","x","usolve","typed","lup","slu","DenseMatrix","createSolveValidation","ArrayArrayMatrix","d","L","U","valueOf","DenseMatrixArrayMatrix","SparseMatrixArrayMatrix","SparseMatrixArrayMatrixNumberNumber","order","threshold","ObjectArrayMatrix"]
}
