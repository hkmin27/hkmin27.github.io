{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csTdfs.js",
"lineCount":1,
"mappings":"AAAAA,cAAA,CAAA,iEAAA,CAAsF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG9HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,MAAR,CAeAA,QAAe,CAACC,CAAD,CAAIC,CAAJ,CAAOC,CAAP,CAAUC,IAAV,CAAgBC,IAAhB,CAAsBC,IAAtB,CAA4BC,KAA5B,CAAmC,CAEhD,IAAIC,IAAM,CAIV,KAFAL,CAAA,CAAEI,KAAF,CAEA,CAFWN,CAEX,CAAc,CAAd,EAAOO,GAAP,CAAA,CAAiB,CAEXC,CAAAA,CAAIN,CAAA,CAAEI,KAAF,CAAUC,GAAV,CAER,KAAIE,EAAIP,CAAA,CAAEC,IAAF,CAASK,CAAT,CAEE,GAAV,GAAIC,CAAJ,EAEEF,GAAA,EAEA,CAAAF,IAAA,CAAKJ,CAAA,EAAL,CAAA,CAAYO,CAJd,GAOEN,CAAA,CAAEC,IAAF,CAASK,CAAT,CAIA,CAJcN,CAAA,CAAEE,IAAF,CAASK,CAAT,CAId,CAFA,EAAEF,GAEF,CAAAL,CAAA,CAAEI,KAAF,CAAUC,GAAV,CAAA,CAAiBE,CAXnB,CANe,CAqBjB,MAAOR,EA3ByC,CArB4E;",
"sources":["node_modules/mathjs/lib/cjs/function/algebra/sparse/csTdfs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csTdfs\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.csTdfs = csTdfs;\n\n/**\n * Depth-first search and postorder of a tree rooted at node j\n *\n * @param {Number}  j               The tree node\n * @param {Number}  k\n * @param {Array}   w               The workspace array\n * @param {Number}  head            The index offset within the workspace for the head array\n * @param {Number}  next            The index offset within the workspace for the next array\n * @param {Array}   post            The post ordering array\n * @param {Number}  stack           The index offset within the workspace for the stack array\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nfunction csTdfs(j, k, w, head, next, post, stack) {\n  // variables\n  var top = 0; // place j on the stack\n\n  w[stack] = j; // while (stack is not empty)\n\n  while (top >= 0) {\n    // p = top of stack\n    var p = w[stack + top]; // i = youngest child of p\n\n    var i = w[head + p];\n\n    if (i === -1) {\n      // p has no unordered children left\n      top--; // node p is the kth postordered node\n\n      post[k++] = p;\n    } else {\n      // remove i from children of p\n      w[head + p] = w[next + i]; // increment top\n\n      ++top; // start dfs on child node i\n\n      w[stack + top] = i;\n    }\n  }\n\n  return k;\n}\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","csTdfs","j","k","w","head","next","post","stack","top","p","i"]
}
