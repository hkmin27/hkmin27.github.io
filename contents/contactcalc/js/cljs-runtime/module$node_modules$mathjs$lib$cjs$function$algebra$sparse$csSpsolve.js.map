{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csSpsolve.js",
"lineCount":3,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/function/algebra/sparse/csSpsolve.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csSpsolve\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCsSpsolve = void 0;\n\nvar _csReach = require(\"./csReach.js\");\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar name = 'csSpsolve';\nvar dependencies = ['divideScalar', 'multiply', 'subtract'];\nvar createCsSpsolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var divideScalar = _ref.divideScalar,\n      multiply = _ref.multiply,\n      subtract = _ref.subtract;\n\n  /**\n   * The function csSpsolve() computes the solution to G * x = bk, where bk is the\n   * kth column of B. When lo is true, the function assumes G = L is lower triangular with the\n   * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U\n   * is upper triangular with the diagonal entry as the last entry in each column.\n   *\n   * @param {Matrix}  g               The G matrix\n   * @param {Matrix}  b               The B matrix\n   * @param {Number}  k               The kth column in B\n   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n   *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n   * @param {Array}   x               The soluton to the linear system G * x = b\n   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\n   * @param {boolean} lo              The lower (true) upper triangular (false) flag\n   *\n   * @return {Number}                 The index for the nonzero pattern\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n  return function csSpsolve(g, b, k, xi, x, pinv, lo) {\n    // g arrays\n    var gvalues = g._values;\n    var gindex = g._index;\n    var gptr = g._ptr;\n    var gsize = g._size; // columns\n\n    var n = gsize[1]; // b arrays\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr; // vars\n\n    var p, p0, p1, q; // xi[top..n-1] = csReach(B(:,k))\n\n    var top = (0, _csReach.csReach)(g, b, k, xi, pinv); // clear x\n\n    for (p = top; p < n; p++) {\n      x[xi[p]] = 0;\n    } // scatter b\n\n\n    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n      x[bindex[p]] = bvalues[p];\n    } // loop columns\n\n\n    for (var px = top; px < n; px++) {\n      // x array index for px\n      var j = xi[px]; // apply permutation vector (U x = b), j maps to column J of G\n\n      var J = pinv ? pinv[j] : j; // check column J is empty\n\n      if (J < 0) {\n        continue;\n      } // column value indeces in G, p0 <= p < p1\n\n\n      p0 = gptr[J];\n      p1 = gptr[J + 1]; // x(j) /= G(j,j)\n\n      x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]); // first entry L(j,j)\n\n      p = lo ? p0 + 1 : p0;\n      q = lo ? p1 : p1 - 1; // loop\n\n      for (; p < q; p++) {\n        // row\n        var i = gindex[p]; // x(i) -= G(i,j) * x(j)\n\n        x[i] = subtract(x[i], multiply(gvalues[p], x[j]));\n      }\n    } // return top of stack\n\n\n    return top;\n  };\n});\nexports.createCsSpsolve = createCsSpsolve;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","createCsSpsolve","_csReach","_factory","factory","name","dependencies","_ref","divideScalar","multiply","subtract","csSpsolve","g","b","k","xi","x","pinv","lo","gvalues","_values","gindex","_index","gptr","_ptr","n","_size","bvalues","bindex","bptr","p","top","csReach","p0","p1","px","j","J","q","i"]
}
