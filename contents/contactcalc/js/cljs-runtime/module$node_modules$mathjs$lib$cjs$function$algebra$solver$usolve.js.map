{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$function$algebra$solver$usolve.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/function/algebra/solver/usolve.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$solver$usolve\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createUsolve = void 0;\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _solveValidation = require(\"./utils/solveValidation.js\");\n\nvar name = 'usolve';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\nvar createUsolve = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divideScalar = _ref.divideScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      subtract = _ref.subtract,\n      equalScalar = _ref.equalScalar,\n      DenseMatrix = _ref.DenseMatrix;\n  var solveValidation = (0, _solveValidation.createSolveValidation)({\n    DenseMatrix: DenseMatrix\n  });\n  /**\n   * Finds one solution of a linear equation system by backward substitution. Matrix must be an upper triangular matrix. Throws an error if there's no solution.\n   *\n   * `U * x = b`\n   *\n   * Syntax:\n   *\n   *    math.usolve(U, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = usolve(a, b)  // [[8], [9]]\n   *\n   * See also:\n   *\n   *    usolveAll, lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} U       A N x N matrix or array (U)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\n   */\n\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      return _sparseBackwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      return _denseBackwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      var m = matrix(a);\n\n      var r = _denseBackwardSubstitution(m, b);\n\n      return r.valueOf();\n    }\n  });\n\n  function _denseBackwardSubstitution(m, b) {\n    // make b into a column vector\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1]; // result\n\n    var x = [];\n    var mdata = m._data; // loop columns backwards\n\n    for (var j = columns - 1; j >= 0; j--) {\n      // b[j]\n      var bj = bdata[j][0] || 0; // x[j]\n\n      var xj = void 0;\n\n      if (!equalScalar(bj, 0)) {\n        // value at [j, j]\n        var vjj = mdata[j][j];\n\n        if (equalScalar(vjj, 0)) {\n          // system cannot be solved\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n\n        xj = divideScalar(bj, vjj); // loop rows\n\n        for (var i = j - 1; i >= 0; i--) {\n          // update copy of b\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];\n        }\n      } else {\n        // zero value at j\n        xj = 0;\n      } // update x\n\n\n      x[j] = [xj];\n    }\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n\n  function _sparseBackwardSubstitution(m, b) {\n    // make b into a column vector\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // result\n\n    var x = []; // loop columns backwards\n\n    for (var j = columns - 1; j >= 0; j--) {\n      var bj = bdata[j][0] || 0;\n\n      if (!equalScalar(bj, 0)) {\n        // non-degenerate row, find solution\n        var vjj = 0; // upper triangular matrix values & index (column j)\n\n        var jValues = [];\n        var jIndices = []; // first & last indeces in column\n\n        var firstIndex = ptr[j];\n        var lastIndex = ptr[j + 1]; // values in column, find value at [j, j], loop backwards\n\n        for (var k = lastIndex - 1; k >= firstIndex; k--) {\n          var i = index[k]; // check row (rows are not sorted!)\n\n          if (i === j) {\n            vjj = values[k];\n          } else if (i < j) {\n            // store upper triangular\n            jValues.push(values[k]);\n            jIndices.push(i);\n          }\n        } // at this point we must have a value in vjj\n\n\n        if (equalScalar(vjj, 0)) {\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n\n        var xj = divideScalar(bj, vjj);\n\n        for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {\n          var _i = jIndices[_k];\n          bdata[_i] = [subtract(bdata[_i][0], multiplyScalar(xj, jValues[_k]))];\n        }\n\n        x[j] = [xj];\n      } else {\n        // degenerate row, we can choose any value\n        x[j] = [0];\n      }\n    }\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n});\nexports.createUsolve = createUsolve;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","createUsolve","_factory","_solveValidation","factory","name","dependencies","_ref","_denseBackwardSubstitution","m","b","solveValidation","bdata","_data","rows","_size","x","mdata","j","columns","bj","equalScalar","xj","vjj","Error","divideScalar","i","subtract","multiplyScalar","DenseMatrix","data","size","typed","matrix","createSolveValidation","SparseMatrixArrayMatrix","values","_values","index","_index","ptr","_ptr","jValues","jIndices","firstIndex","k","lastIndex","push","_k","_lastIndex","length","_i","DenseMatrixArrayMatrix","ArrayArrayMatrix","a","r","valueOf"]
}
