shadow$provide.module$node_modules$mathjs$lib$cjs$function$probability$kldivergence=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createKldivergence=void 0;global=require("module$node_modules$mathjs$lib$cjs$utils$factory");global=(0,global.factory)("kldivergence","typed matrix divide sum multiply dotDivide log isNumeric".split(" "),function(_ref){function _kldiv(q,p){var plength=p.size().length,qlength=q.size().length;if(1<plength)throw Error("first object must be one dimensional");
if(1<qlength)throw Error("second object must be one dimensional");if(plength!==qlength)throw Error("Length of two vectors must be equal");if(0===sum(q))throw Error("Sum of elements in first object must be non zero");if(0===sum(p))throw Error("Sum of elements in second object must be non zero");q=divide(q,sum(q));p=divide(p,sum(p));p=sum(multiply(q,log(dotDivide(q,p))));return isNumeric(p)?p:Number.NaN}var typed=_ref.typed,matrix=_ref.matrix,divide=_ref.divide,sum=_ref.sum,multiply=_ref.multiply,dotDivide=
_ref.dotDivide,log=_ref.log,isNumeric=_ref.isNumeric;return typed("kldivergence",{"Array, Array":function(q,p){return _kldiv(matrix(q),matrix(p))},"Matrix, Array":function(q,p){return _kldiv(q,matrix(p))},"Array, Matrix":function(q,p){return _kldiv(matrix(q),p)},"Matrix, Matrix":function(q,p){return _kldiv(q,p)}})});exports.createKldivergence=global}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$function$probability$kldivergence.js.map
