shadow$provide.module$node_modules$mathjs$lib$cjs$function$algebra$solver$usolveAll=function(global,require,module,exports){function _toConsumableArray(arr){var JSCompiler_temp=Array.isArray(arr)?_arrayLikeToArray(arr):void 0;JSCompiler_temp||(JSCompiler_temp="undefined"!==typeof Symbol&&Symbol.iterator in Object(arr)?Array.from(arr):void 0);if(!JSCompiler_temp)a:{if(arr){if("string"===typeof arr){JSCompiler_temp=_arrayLikeToArray(arr,void 0);break a}JSCompiler_temp=Object.prototype.toString.call(arr).slice(8,
-1);"Object"===JSCompiler_temp&&arr.constructor&&(JSCompiler_temp=arr.constructor.name);if("Map"===JSCompiler_temp||"Set"===JSCompiler_temp){JSCompiler_temp=Array.from(arr);break a}if("Arguments"===JSCompiler_temp||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(JSCompiler_temp)){JSCompiler_temp=_arrayLikeToArray(arr,void 0);break a}}JSCompiler_temp=void 0}if(!(arr=JSCompiler_temp))throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
return arr}function _arrayLikeToArray(arr,len){if(null==len||len>arr.length)len=arr.length;for(var i=0,arr2=Array(len);i<len;i++)arr2[i]=arr[i];return arr2}Object.defineProperty(exports,"__esModule",{value:!0});exports.createUsolveAll=void 0;global=require("module$node_modules$mathjs$lib$cjs$utils$factory");var _solveValidation=require("module$node_modules$mathjs$lib$cjs$function$algebra$solver$utils$solveValidation");require=(0,global.factory)("usolveAll","typed matrix divideScalar multiplyScalar subtract equalScalar DenseMatrix".split(" "),
function(_ref){function _denseBackwardSubstitution(m,b_){b_=[solveValidation(m,b_,!0)._data.map(function(e){return e[0]})];var M=m._data,rows=m._size[0];for(m=m._size[1]-1;0<=m;m--)for(var L=b_.length,k=0;k<L;k++){var b=b_[k];if(!equalScalar(M[m][m],0)){b[m]=divideScalar(b[m],M[m][m]);for(var j=m-1;0<=j;j--)b[j]=subtract(b[j],multiplyScalar(b[m],M[j][m]))}else if(!equalScalar(b[m],0)){if(0===k)return[];b_.splice(k,1);--k;--L}else if(0===k){b=_toConsumableArray(b);b[m]=1;for(j=m-1;0<=j;j--)b[j]=subtract(b[j],
M[j][m]);b_.push(b)}}return b_.map(function(x){return new DenseMatrix({data:x.map(function(e){return[e]}),size:[rows,1]})})}function _sparseBackwardSubstitution(m,b_){b_=[solveValidation(m,b_,!0)._data.map(function(e){return e[0]})];var rows=m._size[0],values=m._values,index=m._index,ptr=m._ptr;for(m=m._size[1]-1;0<=m;m--)for(var L=b_.length,k=0;k<L;k++){for(var b=b_[k],iValues=[],iIndices=[],firstIndex=ptr[m],Mii=0,j=ptr[m+1]-1;j>=firstIndex;j--){var J=index[j];J===m?Mii=values[j]:J<m&&(iValues.push(values[j]),
iIndices.push(J))}if(!equalScalar(Mii,0))for(b[m]=divideScalar(b[m],Mii),firstIndex=0,Mii=iIndices.length;firstIndex<Mii;firstIndex++)j=iIndices[firstIndex],b[j]=subtract(b[j],multiplyScalar(b[m],iValues[firstIndex]));else if(!equalScalar(b[m],0)){if(0===k)return[];b_.splice(k,1);--k;--L}else if(0===k){b=_toConsumableArray(b);b[m]=1;firstIndex=0;for(Mii=iIndices.length;firstIndex<Mii;firstIndex++)j=iIndices[firstIndex],b[j]=subtract(b[j],iValues[firstIndex]);b_.push(b)}}return b_.map(function(x){return new DenseMatrix({data:x.map(function(e){return[e]}),
size:[rows,1]})})}var typed=_ref.typed,matrix=_ref.matrix,divideScalar=_ref.divideScalar,multiplyScalar=_ref.multiplyScalar,subtract=_ref.subtract,equalScalar=_ref.equalScalar,DenseMatrix=_ref.DenseMatrix,solveValidation=(0,_solveValidation.createSolveValidation)({DenseMatrix:DenseMatrix});return typed("usolveAll",{"SparseMatrix, Array | Matrix":function(m,b){return _sparseBackwardSubstitution(m,b)},"DenseMatrix, Array | Matrix":function(m,b){return _denseBackwardSubstitution(m,b)},"Array, Array | Matrix":function(a,
b){a=matrix(a);return _denseBackwardSubstitution(a,b).map(function(r){return r.valueOf()})}})});exports.createUsolveAll=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$function$algebra$solver$usolveAll.js.map
