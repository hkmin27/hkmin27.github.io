{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csCounts.js",
"lineCount":3,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/function/algebra/sparse/csCounts.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csCounts\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCsCounts = void 0;\n\nvar _factory = require(\"../../../utils/factory.js\");\n\nvar _csLeaf = require(\"./csLeaf.js\");\n\nvar name = 'csCounts';\nvar dependencies = ['transpose'];\nvar createCsCounts = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var transpose = _ref.transpose;\n\n  /**\n   * Computes the column counts using the upper triangular part of A.\n   * It transposes A internally, none of the input parameters are modified.\n   *\n   * @param {Matrix} a           The sparse matrix A\n   *\n   * @param {Matrix} ata         Count the columns of A'A instead\n   *\n   * @return                     An array of size n of the column counts or null on error\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n  return function (a, parent, post, ata) {\n    // check inputs\n    if (!a || !parent || !post) {\n      return null;\n    } // a matrix arrays\n\n\n    var asize = a._size; // rows and columns\n\n    var m = asize[0];\n    var n = asize[1]; // variables\n\n    var i, j, k, J, p, p0, p1; // workspace size\n\n    var s = 4 * n + (ata ? n + m + 1 : 0); // allocate workspace\n\n    var w = []; // (s)\n\n    var ancestor = 0; // first n entries\n\n    var maxfirst = n; // next n entries\n\n    var prevleaf = 2 * n; // next n entries\n\n    var first = 3 * n; // next n entries\n\n    var head = 4 * n; // next n + 1 entries (used when ata is true)\n\n    var next = 5 * n + 1; // last entries in workspace\n    // clear workspace w[0..s-1]\n\n    for (k = 0; k < s; k++) {\n      w[k] = -1;\n    } // allocate result\n\n\n    var colcount = []; // (n)\n    // AT = A'\n\n    var at = transpose(a); // at arrays\n\n    var tindex = at._index;\n    var tptr = at._ptr; // find w[first + j]\n\n    for (k = 0; k < n; k++) {\n      j = post[k]; // colcount[j]=1 if j is a leaf\n\n      colcount[j] = w[first + j] === -1 ? 1 : 0;\n\n      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {\n        w[first + j] = k;\n      }\n    } // initialize ata if needed\n\n\n    if (ata) {\n      // invert post\n      for (k = 0; k < n; k++) {\n        w[post[k]] = k;\n      } // loop rows (columns in AT)\n\n\n      for (i = 0; i < m; i++) {\n        // values in column i of AT\n        for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {\n          k = Math.min(k, w[tindex[p]]);\n        } // place row i in linked list k\n\n\n        w[next + i] = w[head + k];\n        w[head + k] = i;\n      }\n    } // each node in its own set\n\n\n    for (i = 0; i < n; i++) {\n      w[ancestor + i] = i;\n    }\n\n    for (k = 0; k < n; k++) {\n      // j is the kth node in postordered etree\n      j = post[k]; // check j is not a root\n\n      if (parent[j] !== -1) {\n        colcount[parent[j]]--;\n      } // J=j for LL'=A case\n\n\n      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {\n        for (p = tptr[J]; p < tptr[J + 1]; p++) {\n          i = tindex[p];\n          var r = (0, _csLeaf.csLeaf)(i, j, w, first, maxfirst, prevleaf, ancestor); // check A(i,j) is in skeleton\n\n          if (r.jleaf >= 1) {\n            colcount[j]++;\n          } // check account for overlap in q\n\n\n          if (r.jleaf === 2) {\n            colcount[r.q]--;\n          }\n        }\n      }\n\n      if (parent[j] !== -1) {\n        w[ancestor + j] = parent[j];\n      }\n    } // sum up colcount's of each child\n\n\n    for (j = 0; j < n; j++) {\n      if (parent[j] !== -1) {\n        colcount[parent[j]] += colcount[j];\n      }\n    }\n\n    return colcount;\n  };\n});\nexports.createCsCounts = createCsCounts;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","createCsCounts","_factory","_csLeaf","factory","name","dependencies","_ref","transpose","a","parent","post","ata","asize","_size","m","n","i","k","s","w","prevleaf","first","head","next","colcount","at","tindex","_index","tptr","_ptr","j","p0","p1","p","Math","min","ancestor","J","r","csLeaf","jleaf","q"]
}
