{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$expression$operators.js",
"lineCount":9,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/expression/operators.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$expression$operators\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPrecedence = getPrecedence;\nexports.getAssociativity = getAssociativity;\nexports.isAssociativeWith = isAssociativeWith;\nexports.properties = void 0;\n\nvar _object = require(\"../utils/object.js\");\n\n// list of identifiers of nodes in order of their precedence\n// also contains information about left/right associativity\n// and which other operator the operator is associative with\n// Example:\n// addition is associative with addition and subtraction, because:\n// (a+b)+c=a+(b+c)\n// (a+b)-c=a+(b-c)\n//\n// postfix operators are left associative, prefix operators\n// are right associative\n//\n// It's also possible to set the following properties:\n// latexParens: if set to false, this node doesn't need to be enclosed\n//              in parentheses when using LaTeX\n// latexLeftParens: if set to false, this !OperatorNode's!\n//                  left argument doesn't need to be enclosed\n//                  in parentheses\n// latexRightParens: the same for the right argument\nvar properties = [{\n  // assignment\n  AssignmentNode: {},\n  FunctionAssignmentNode: {}\n}, {\n  // conditional expression\n  ConditionalNode: {\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // conditionals don't need parentheses in LaTeX because\n    // they are 2 dimensional\n\n  }\n}, {\n  // logical or\n  'OperatorNode:or': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical xor\n  'OperatorNode:xor': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical and\n  'OperatorNode:and': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise or\n  'OperatorNode:bitOr': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise xor\n  'OperatorNode:bitXor': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise and\n  'OperatorNode:bitAnd': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // relational operators\n  'OperatorNode:equal': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:unequal': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smaller': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:larger': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smallerEq': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:largerEq': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  RelationalNode: {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitshift operators\n  'OperatorNode:leftShift': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightArithShift': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightLogShift': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unit conversion\n  'OperatorNode:to': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // range\n  RangeNode: {}\n}, {\n  // addition, subtraction\n  'OperatorNode:add': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']\n  },\n  'OperatorNode:subtract': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // multiply, divide, modulus\n  'OperatorNode:multiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\n  },\n  'OperatorNode:divide': {\n    associativity: 'left',\n    associativeWith: [],\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // fractions don't require parentheses because\n    // they're 2 dimensional, so parens aren't needed\n    // in LaTeX\n\n  },\n  'OperatorNode:dotMultiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'OperatorNode:dotMultiply', 'OperatorNode:doDivide']\n  },\n  'OperatorNode:dotDivide': {\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:mod': {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unary prefix operators\n  'OperatorNode:unaryPlus': {\n    associativity: 'right'\n  },\n  'OperatorNode:unaryMinus': {\n    associativity: 'right'\n  },\n  'OperatorNode:bitNot': {\n    associativity: 'right'\n  },\n  'OperatorNode:not': {\n    associativity: 'right'\n  }\n}, {\n  // exponentiation\n  'OperatorNode:pow': {\n    associativity: 'right',\n    associativeWith: [],\n    latexRightParens: false // the exponent doesn't need parentheses in\n    // LaTeX because it's 2 dimensional\n    // (it's on top)\n\n  },\n  'OperatorNode:dotPow': {\n    associativity: 'right',\n    associativeWith: []\n  }\n}, {\n  // factorial\n  'OperatorNode:factorial': {\n    associativity: 'left'\n  }\n}, {\n  // matrix transpose\n  'OperatorNode:transpose': {\n    associativity: 'left'\n  }\n}];\n/**\n * Get the precedence of a Node.\n * Higher number for higher precedence, starting with 0.\n * Returns null if the precedence is undefined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {number | null}\n */\n\nexports.properties = properties;\n\nfunction getPrecedence(_node, parenthesis) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n\n  for (var i = 0; i < properties.length; i++) {\n    if (identifier in properties[i]) {\n      return i;\n    }\n  }\n\n  return null;\n}\n/**\n * Get the associativity of an operator (left or right).\n * Returns a string containing 'left' or 'right' or null if\n * the associativity is not defined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {string|null}\n * @throws {Error}\n */\n\n\nfunction getAssociativity(_node, parenthesis) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n  var index = getPrecedence(node, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifier];\n\n  if ((0, _object.hasOwnProperty)(property, 'associativity')) {\n    if (property.associativity === 'left') {\n      return 'left';\n    }\n\n    if (property.associativity === 'right') {\n      return 'right';\n    } // associativity is invalid\n\n\n    throw Error('\\'' + identifier + '\\' has the invalid associativity \\'' + property.associativity + '\\'.');\n  } // associativity is undefined\n\n\n  return null;\n}\n/**\n * Check if an operator is associative with another operator.\n * Returns either true or false or null if not defined.\n *\n * @param {Node} nodeA\n * @param {Node} nodeB\n * @param {string} parenthesis\n * @return {boolean | null}\n */\n\n\nfunction isAssociativeWith(nodeA, nodeB, parenthesis) {\n  // ParenthesisNodes are only ignored when not in 'keep' mode\n  var a = parenthesis !== 'keep' ? nodeA.getContent() : nodeA;\n  var b = parenthesis !== 'keep' ? nodeA.getContent() : nodeB;\n  var identifierA = a.getIdentifier();\n  var identifierB = b.getIdentifier();\n  var index = getPrecedence(a, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifierA];\n\n  if ((0, _object.hasOwnProperty)(property, 'associativeWith') && property.associativeWith instanceof Array) {\n    for (var i = 0; i < property.associativeWith.length; i++) {\n      if (property.associativeWith[i] === identifierB) {\n        return true;\n      }\n    }\n\n    return false;\n  } // associativeWith is not defined\n\n\n  return null;\n}\n};"],
"names":["shadow$provide","global","require","module","exports","getPrecedence","_node","parenthesis","node","getContent","identifier","getIdentifier","i","properties","length","Object","defineProperty","value","getAssociativity","index","property","_object","hasOwnProperty","associativity","Error","isAssociativeWith","nodeA","nodeB","a","b","identifierA","identifierB","associativeWith","Array","AssignmentNode","FunctionAssignmentNode","ConditionalNode","latexLeftParens","latexRightParens","latexParens","RelationalNode","RangeNode"]
}
