shadow$provide.module$node_modules$mathjs$lib$cjs$function$matrix$sqrtm=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createSqrtm=void 0;var _is=require("module$node_modules$mathjs$lib$cjs$utils$is"),_string=require("module$node_modules$mathjs$lib$cjs$utils$string"),_array=require("module$node_modules$mathjs$lib$cjs$utils$array");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");global=(0,global.factory)("sqrtm","typed abs add multiply sqrt subtract inv size max identity".split(" "),
function(_ref){var typed=_ref.typed,abs=_ref.abs,add=_ref.add,multiply=_ref.multiply,sqrt=_ref.sqrt,subtract=_ref.subtract,inv=_ref.inv,size$jscomp$0=_ref.size,max=_ref.max,identity=_ref.identity;return typed("sqrtm",{"Array | Matrix":function(A){var size=(0,_is.isMatrix)(A)?A.size():(0,_array.arraySize)(A);switch(size.length){case 1:if(1===size[0])return sqrt(A);throw new RangeError("Matrix must be square (size: "+(0,_string.format)(size)+")");case 2:if(size[0]===size[1]){size=0;var Y=A;A=identity(size$jscomp$0(A));
do{var error=Y;Y=multiply(.5,add(error,inv(A)));A=multiply(.5,add(A,inv(error)));error=max(abs(subtract(Y,error)));if(1E-6<error&&1E3<++size)throw Error("computing square root of matrix: iterative method could not converge");}while(1E-6<error);return Y}throw new RangeError("Matrix must be square (size: "+(0,_string.format)(size)+")");default:throw new RangeError("Matrix must be at most two dimensional (size: "+(0,_string.format)(size)+")");}}})});exports.createSqrtm=global}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$function$matrix$sqrtm.js.map
