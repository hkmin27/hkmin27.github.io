shadow$provide.module$node_modules$mathjs$lib$cjs$function$statistics$min=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createMin=void 0;var _collection=require("module$node_modules$mathjs$lib$cjs$utils$collection");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");var _improveErrorMessage=require("module$node_modules$mathjs$lib$cjs$function$statistics$utils$improveErrorMessage");require=(0,global.factory)("min",["typed","config",
"numeric","smaller"],function(_ref){function _smallest(x,y){try{return smaller(x,y)?x:y}catch(err){throw(0,_improveErrorMessage.improveErrorMessage)(err,"min",y);}}function _min(array){var min;(0,_collection.deepForEach)(array,function(value){try{if(isNaN(value)&&"number"===typeof value)min=NaN;else if(void 0===min||smaller(value,min))min=value}catch(err){throw(0,_improveErrorMessage.improveErrorMessage)(err,"min",value);}});if(void 0===min)throw Error("Cannot calculate min of an empty array");"string"===
typeof min&&(min=numeric(min,config.number));return min}var typed=_ref.typed,config=_ref.config,numeric=_ref.numeric,smaller=_ref.smaller;return typed("min",{"Array | Matrix":_min,"Array | Matrix, number | BigNumber":function(array,dim){return(0,_collection.reduce)(array,dim.valueOf(),_smallest)},"...":function(args){if((0,_collection.containsCollections)(args))throw new TypeError("Scalar values expected in function min");return _min(args)}})});exports.createMin=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$function$statistics$min.js.map
