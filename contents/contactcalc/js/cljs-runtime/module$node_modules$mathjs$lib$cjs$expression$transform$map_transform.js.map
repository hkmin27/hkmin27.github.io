{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$expression$transform$map_transform.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/expression/transform/map.transform.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$expression$transform$map_transform\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createMapTransform = void 0;\n\nvar _is = require(\"../../utils/is.js\");\n\nvar _function = require(\"../../utils/function.js\");\n\nvar _array = require(\"../../utils/array.js\");\n\nvar _factory = require(\"../../utils/factory.js\");\n\nvar _compileInlineExpression = require(\"./utils/compileInlineExpression.js\");\n\nvar name = 'map';\nvar dependencies = ['typed'];\nvar createMapTransform = /* #__PURE__ */(0, _factory.factory)(name, dependencies, function (_ref) {\n  var typed = _ref.typed;\n\n  /**\n   * Attach a transform function to math.map\n   * Adds a property transform containing the transform function.\n   *\n   * This transform creates a one-based index instead of a zero-based index\n   */\n  function mapTransform(args, math, scope) {\n    var x, callback;\n\n    if (args[0]) {\n      x = args[0].compile().evaluate(scope);\n    }\n\n    if (args[1]) {\n      if ((0, _is.isSymbolNode)(args[1]) || (0, _is.isFunctionAssignmentNode)(args[1])) {\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\n        callback = args[1].compile().evaluate(scope);\n      } else {\n        // an expression like filter([3, -2, 5], x > 0)\n        callback = (0, _compileInlineExpression.compileInlineExpression)(args[1], math, scope);\n      }\n    }\n\n    return map(x, callback);\n  }\n\n  mapTransform.rawArgs = true; // one-based version of map function\n\n  var map = typed('map', {\n    'Array, function': function ArrayFunction(x, callback) {\n      return _map(x, callback, x);\n    },\n    'Matrix, function': function MatrixFunction(x, callback) {\n      return x.create(_map(x.valueOf(), callback, x));\n    }\n  });\n  return mapTransform;\n}, {\n  isTransformFunction: true\n});\n/**\n * Map for a multi dimensional array. One-based indexes\n * @param {Array} array\n * @param {function} callback\n * @param {Array} orig\n * @return {Array}\n * @private\n */\n\nexports.createMapTransform = createMapTransform;\n\nfunction _map(array, callback, orig) {\n  // figure out what number of arguments the callback function expects\n  var argsCount = (0, _function.maxArgumentCount)(callback);\n\n  function recurse(value, index) {\n    if (Array.isArray(value)) {\n      return (0, _array.map)(value, function (child, i) {\n        // we create a copy of the index array and append the new index value\n        return recurse(child, index.concat(i + 1)); // one based index, hence i + 1\n      });\n    } else {\n      // invoke the (typed) callback function with the right number of arguments\n      if (argsCount === 1) {\n        return callback(value);\n      } else if (argsCount === 2) {\n        return callback(value, index);\n      } else {\n        // 3 or -1\n        return callback(value, index, orig);\n      }\n    }\n  }\n\n  return recurse(array, []);\n}\n};"],
"names":["shadow$provide","global","require","module","exports","_map","array","callback","orig","recurse","value","index","Array","isArray","_array","map","child","i","concat","argsCount","_function","maxArgumentCount","Object","defineProperty","createMapTransform","_is","_factory","_compileInlineExpression","factory","name","dependencies","_ref","mapTransform","args","math","scope","x","compile","evaluate","isSymbolNode","isFunctionAssignmentNode","compileInlineExpression","typed","rawArgs","ArrayFunction","MatrixFunction","create","valueOf","isTransformFunction"]
}
