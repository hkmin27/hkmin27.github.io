shadow$provide.module$node_modules$mathjs$lib$cjs$function$algebra$solver$lusolve=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createLusolve=void 0;var _is=require("module$node_modules$mathjs$lib$cjs$utils$is");global=require("module$node_modules$mathjs$lib$cjs$utils$factory");var _solveValidation=require("module$node_modules$mathjs$lib$cjs$function$algebra$solver$utils$solveValidation"),_csIpvec=require("module$node_modules$mathjs$lib$cjs$function$algebra$sparse$csIpvec");
require=(0,global.factory)("lusolve","typed matrix lup slu usolve lsolve DenseMatrix".split(" "),function(_ref){function _toMatrix(a){if((0,_is.isMatrix)(a))return a;if((0,_is.isArray)(a))return matrix(a);throw new TypeError("Invalid Matrix LU decomposition");}function _lusolve(l,u,p,q,b){l=_toMatrix(l);u=_toMatrix(u);p&&(b=solveValidation(l,b,!0),b._data=(0,_csIpvec.csIpvec)(p,b._data));l=lsolve(l,b);u=usolve(u,l);q&&(u._data=(0,_csIpvec.csIpvec)(q,u._data));return u}var typed=_ref.typed,matrix=
_ref.matrix,lup=_ref.lup,slu=_ref.slu,usolve=_ref.usolve,lsolve=_ref.lsolve;_ref=_ref.DenseMatrix;var solveValidation=(0,_solveValidation.createSolveValidation)({DenseMatrix:_ref});return typed("lusolve",{"Array, Array | Matrix":function(a,b){a=matrix(a);a=lup(a);return _lusolve(a.L,a.U,a.p,null,b).valueOf()},"DenseMatrix, Array | Matrix":function(a,b){a=lup(a);return _lusolve(a.L,a.U,a.p,null,b)},"SparseMatrix, Array | Matrix":function(a,b){a=lup(a);return _lusolve(a.L,a.U,a.p,null,b)},"SparseMatrix, Array | Matrix, number, number":function(a,
b,order,threshold){a=slu(a,order,threshold);return _lusolve(a.L,a.U,a.p,a.q,b)},"Object, Array | Matrix":function(d,b){return _lusolve(d.L,d.U,d.p,d.q,b)}})});exports.createLusolve=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$function$algebra$solver$lusolve.js.map
