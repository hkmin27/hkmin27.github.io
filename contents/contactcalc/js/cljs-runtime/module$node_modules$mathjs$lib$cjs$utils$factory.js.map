{
"version":3,
"file":"module$node_modules$mathjs$lib$cjs$utils$factory.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/mathjs/lib/cjs/utils/factory.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mathjs$lib$cjs$utils$factory\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.factory = factory;\nexports.sortFactories = sortFactories;\nexports.create = create;\nexports.isFactory = isFactory;\nexports.assertDependencies = assertDependencies;\nexports.isOptionalDependency = isOptionalDependency;\nexports.stripOptionalNotation = stripOptionalNotation;\n\nvar _array = require(\"./array.js\");\n\nvar _object = require(\"./object.js\");\n\n/**\n * Create a factory function, which can be used to inject dependencies.\n *\n * The created functions are memoized, a consecutive call of the factory\n * with the exact same inputs will return the same function instance.\n * The memoized cache is exposed on `factory.cache` and can be cleared\n * if needed.\n *\n * Example:\n *\n *     const name = 'log'\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\n *\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\n *       // ... create the function log here and return it\n *     }\n *\n * @param {string} name           Name of the function to be created\n * @param {string[]} dependencies The names of all required dependencies\n * @param {function} create       Callback function called with an object with all dependencies\n * @param {Object} [meta]         Optional object with meta information that will be attached\n *                                to the created factory function as property `meta`.\n * @returns {function}\n */\nfunction factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = (0, _object.pickShallow)(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n\n  return assertAndCreate;\n}\n/**\n * Sort all factories such that when loading in order, the dependencies are resolved.\n *\n * @param {Array} factories\n * @returns {Array} Returns a new array with the sorted factories.\n */\n\n\nfunction sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(function (factory) {\n    factoriesByName[factory.fn] = factory;\n  });\n\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if ((0, _array.contains)(factory.dependencies, dependency.fn || dependency.name)) {\n        return true;\n      }\n\n      if (factory.dependencies.some(function (d) {\n        return containsDependency(factoriesByName[d], dependency);\n      })) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var sorted = [];\n\n  function addFactory(factory) {\n    var index = 0;\n\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n\n    sorted.splice(index, 0, factory);\n  } // sort regular factory functions\n\n\n  factories.filter(isFactory).forEach(addFactory); // sort legacy factory functions AFTER the regular factory functions\n\n  factories.filter(function (factory) {\n    return !isFactory(factory);\n  }).forEach(addFactory);\n  return sorted;\n} // TODO: comment or cleanup if unused in the end\n\n\nfunction create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(function (factory) {\n    return factory(scope);\n  });\n  return scope;\n}\n/**\n * Test whether an object is a factory. This is the case when it has\n * properties name, dependencies, and a function create.\n * @param {*} obj\n * @returns {boolean}\n */\n\n\nfunction isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n/**\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\n *\n * Will throw an exception when there are dependencies missing.\n *\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\n * @param {string[]} dependencies\n * @param {Object} scope\n */\n\n\nfunction assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(function (dependency) {\n    return !isOptionalDependency(dependency);\n  }) // filter optionals\n  .every(function (dependency) {\n    return scope[dependency] !== undefined;\n  });\n\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(function (dependency) {\n      return scope[dependency] === undefined;\n    }); // TODO: create a custom error class for this, a MathjsError or something like that\n\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(function (d) {\n      return \"\\\"\".concat(d, \"\\\"\");\n    }).join(', '), \".\"));\n  }\n}\n\nfunction isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\n\nfunction stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}\n};"],
"names":["shadow$provide","global","require","module","exports","sortFactories","factories","containsDependency","factory","dependency","isFactory","_array","contains","dependencies","fn","name","some","d","factoriesByName","addFactory","index","sorted","length","splice","forEach","filter","obj","Array","isArray","assertDependencies","scope","isOptionalDependency","every","allDefined","undefined","missingDependencies","Error","concat","map","join","stripOptionalNotation","slice","Object","defineProperty","value","create","meta","assertAndCreate","deps","_object","pickShallow","sort","arguments"]
}
