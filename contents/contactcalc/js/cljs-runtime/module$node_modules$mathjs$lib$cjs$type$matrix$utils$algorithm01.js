shadow$provide.module$node_modules$mathjs$lib$cjs$type$matrix$utils$algorithm01=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.createAlgorithm01=void 0;global=require("module$node_modules$mathjs$lib$cjs$utils$factory");var _DimensionError=require("module$node_modules$mathjs$lib$cjs$error$DimensionError");require=(0,global.factory)("algorithm01",["typed"],function(_ref){var typed=_ref.typed;return function(denseMatrix,sparseMatrix,callback,inverse){var adata=
denseMatrix._data,asize=denseMatrix._size,adt=denseMatrix._datatype,bvalues=sparseMatrix._values,bindex=sparseMatrix._index,bptr=sparseMatrix._ptr,bsize=sparseMatrix._size;sparseMatrix=sparseMatrix._datatype;if(asize.length!==bsize.length)throw new _DimensionError.DimensionError(asize.length,bsize.length);if(asize[0]!==bsize[0]||asize[1]!==bsize[1])throw new RangeError("Dimension mismatch. Matrix A ("+asize+") must match Matrix B ("+bsize+")");if(!bvalues)throw Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
bsize=asize[0];asize=asize[1];callback=(adt="string"===typeof adt&&adt===sparseMatrix?adt:void 0)?typed.find(callback,[adt,adt]):callback;var j,cdata=[];for(sparseMatrix=0;sparseMatrix<bsize;sparseMatrix++)cdata[sparseMatrix]=[];var x=[],w=[];for(j=0;j<asize;j++){for(var mark=j+1,k1=bptr[j+1],k=bptr[j];k<k1;k++)sparseMatrix=bindex[k],x[sparseMatrix]=inverse?callback(bvalues[k],adata[sparseMatrix][j]):callback(adata[sparseMatrix][j],bvalues[k]),w[sparseMatrix]=mark;for(sparseMatrix=0;sparseMatrix<
bsize;sparseMatrix++)cdata[sparseMatrix][j]=w[sparseMatrix]===mark?x[sparseMatrix]:adata[sparseMatrix][j]}return denseMatrix.createDenseMatrix({data:cdata,size:[bsize,asize],datatype:adt})}});exports.createAlgorithm01=require}
//# sourceMappingURL=module$node_modules$mathjs$lib$cjs$type$matrix$utils$algorithm01.js.map
